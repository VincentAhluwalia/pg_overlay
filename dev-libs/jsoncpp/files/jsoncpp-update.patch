diff --git a/.clang-format b/.clang-format
index dd51247..2a372fc 100644
--- a/.clang-format
+++ b/.clang-format
@@ -29,8 +29,8 @@ PenaltyExcessCharacter: 1000000
 PenaltyReturnTypeOnItsOwnLine: 60
 PointerBindsToType: true
 SpacesBeforeTrailingComments: 1
-Cpp11BracedListStyle: false
-Standard:        Cpp03
+Cpp11BracedListStyle: true
+Standard:        Cpp11
 IndentWidth:     2
 TabWidth:        8
 UseTab:          Never
diff --git a/.travis.yml b/.travis.yml
index b218c02..fe71962 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -1,56 +1,77 @@
-# Build matrix / environment variable are explained on:
+# Build matrix / environment variables are explained on:
 # http://about.travis-ci.org/docs/user/build-configuration/
 # This file can be validated on:
 # http://lint.travis-ci.org/
 # See also
 # http://stackoverflow.com/questions/22111549/travis-ci-with-clang-3-4-and-c11/30925448#30925448
 # to allow C++11, though we are not yet building with -std=c++11
-
-before_install: pyenv install 3.5.4 && pyenv global 3.5.4
-install:
-- if [[ $TRAVIS_OS_NAME == osx ]]; then
-     brew update;
-     brew install python3 ninja;
-     python3 -m venv venv;
-     source venv/bin/activate;
-  elif [[ $TRAVIS_OS_NAME == linux ]]; then
-     wget https://github.com/ninja-build/ninja/releases/download/v1.7.2/ninja-linux.zip;
-     unzip -q ninja-linux.zip -d build;
-  fi
-- pip3 install meson
-# /usr/bin/gcc is 4.6 always, but gcc-X.Y is available.
-- if [[ $CXX = g++ ]]; then export CXX="g++-4.9" CC="gcc-4.9"; fi
-# /usr/bin/clang has a conflict with gcc, so use clang-X.Y.
-- if [[ $CXX = clang++ ]]; then export CXX="clang++-3.5" CC="clang-3.5"; fi
-- echo ${PATH}
-- ls /usr/local
-- ls /usr/local/bin
-- export PATH="${PWD}"/build:/usr/local/bin:/usr/bin:${PATH}
-- echo ${CXX}
-- ${CXX} --version
-- which valgrind
+language: cpp
+sudo: false
 addons:
+  homebrew:
+    packages:
+    - meson
+    - ninja
+    update: false # do not update homebrew by default
   apt:
     sources:
-    - ubuntu-toolchain-r-test
+    #- ubuntu-toolchain-r-test
     - llvm-toolchain-precise-3.5
     packages:
-    - gcc-4.9
-    - g++-4.9
+    #- gcc-4.9
+    #- g++-4.9
     - clang-3.5
     - valgrind
-os:
-  - linux
-language: cpp
-compiler:
-  - gcc
-  - clang
-script: ./travis.sh
-env:
-  matrix:
-    - LIB_TYPE=static BUILD_TYPE=release
-    - LIB_TYPE=shared BUILD_TYPE=debug
+matrix:
+  allow_failures:
+    - os: osx
+  include:
+    - name: Mac clang meson static release testing
+      os: osx
+      osx_image: xcode9.4
+      compiler: clang
+      env: 
+         CXX="clang++-3.5" 
+         CC="clang-3.5"
+         LIB_TYPE=static
+         BUILD_TYPE=release
+      script: ./.travis_scripts/meson_builder.sh
+    - name: trusty clang meson static release testing
+      os: linux
+      dist: trusty
+      compiler: clang
+      env: 
+         CXX="clang++-3.5" 
+         CC="clang-3.5"
+         LIB_TYPE=static
+         BUILD_TYPE=release
+      # before_install and install steps only needed for linux meson builds
+      before_install:
+          - source ./.travis_scripts/travis.before_install.${TRAVIS_OS_NAME}.sh
+      install:
+           - source ./.travis_scripts/travis.install.${TRAVIS_OS_NAME}.sh
+      script: ./.travis_scripts/meson_builder.sh
+    - name: xenial gcc cmake coverage
+      os: linux
+      dist: xenial
+      compiler: gcc
+      env: 
+        CXX=g++
+        CC=gcc
+        DO_Coverage=ON
+        BUILD_TOOL="Unix Makefiles"
+        BUILD_TYPE=Debug 
+        LIB_TYPE=shared 
+        DESTDIR=/tmp/cmake_json_cpp
+      script: ./.travis_scripts/cmake_builder.sh
+#   Valgrind has too many false positives from the python wrapping.  Need a good suppression file
+#    - name: xenial gcc cmake coverage
+#      os: linux
+#      dist: xenial
+#      compiler: gcc
+#      env: DO_MemCheck=ON CXX=/usr/bin/g++  BUILD_TOOL="Unix Makefiles" BUILD_TYPE=Debug LIB_TYPE=shared DESTDIR=/tmp/cmake_json_cpp
+#      script: ./.travis_scripts/cmake_builder.sh
 notifications:
   email: false
-dist: trusty
-sudo: false
+
+
diff --git a/.travis_scripts/cmake_builder.sh b/.travis_scripts/cmake_builder.sh
new file mode 100755
index 0000000..c011878
--- /dev/null
+++ b/.travis_scripts/cmake_builder.sh
@@ -0,0 +1,130 @@
+#!/usr/bin/env sh
+# This script can be used on the command line directly to configure several
+# different build environments.
+# This is called by `.travis.yml` via Travis CI.
+# Travis supplies $TRAVIS_OS_NAME.
+#  http://docs.travis-ci.com/user/multi-os/
+# Our .travis.yml also defines:
+
+#   - BUILD_TYPE=Release/Debug
+#   - LIB_TYPE=static/shared
+#
+# Optional environmental variables
+#   - DESTDIR <- used for setting the install prefix
+#   - BUILD_TOOL=["Unix Makefile"|"Ninja"]
+#   - BUILDNAME <-- how to identify this build on the dashboard
+#   - DO_MemCheck <- if set, try to use valgrind
+#   - DO_Coverage    <- if set, try to do dashboard coverage testing
+#   
+
+env_set=1
+if ${BUILD_TYPE+false}; then
+  echo "BUILD_TYPE not set in environment."
+  env_set=0
+fi
+if ${LIB_TYPE+false}; then
+  echo "LIB_TYPE not set in environment."
+  env_set=0
+fi
+if ${CXX+false}; then
+  echo "CXX not set in environment."
+  env_set=0
+fi
+
+
+if [ ${env_set} -eq 0 ]; then
+  echo "USAGE:  CXX=$(which clang++)  BUILD_TYPE=[Release|Debug] LIB_TYPE=[static|shared] $0"
+  echo ""
+  echo "Examples:"
+  echo "           CXX=$(which clang++) BUILD_TYPE=Release LIB_TYPE=shared DESTDIR=/tmp/cmake_json_cpp $0"
+  echo "           CXX=$(which clang++) BUILD_TYPE=Debug   LIB_TYPE=shared DESTDIR=/tmp/cmake_json_cpp $0"
+  echo "           CXX=$(which clang++) BUILD_TYPE=Release LIB_TYPE=static DESTDIR=/tmp/cmake_json_cpp $0"
+  echo "           CXX=$(which clang++) BUILD_TYPE=Debug   LIB_TYPE=static DESTDIR=/tmp/cmake_json_cpp $0"
+
+  echo "           CXX=$(which g++)     BUILD_TYPE=Release LIB_TYPE=shared DESTDIR=/tmp/cmake_json_cpp $0"
+  echo "           CXX=$(which g++)     BUILD_TYPE=Debug   LIB_TYPE=shared DESTDIR=/tmp/cmake_json_cpp $0"
+  echo "           CXX=$(which g++)     BUILD_TYPE=Release LIB_TYPE=static DESTDIR=/tmp/cmake_json_cpp $0"
+  echo "           CXX=$(which g++)     BUILD_TYPE=Debug   LIB_TYPE=static DESTDIR=/tmp/cmake_json_cpp $0"
+
+  exit -1
+fi
+
+if ${DESTDIR+false}; then
+  DESTDIR="/usr/local"
+fi
+
+# -e: fail on error
+# -v: show commands
+# -x: show expanded commands
+set -vex
+
+env | sort
+
+which cmake
+cmake --version
+
+echo ${CXX}
+${CXX} --version
+_COMPILER_NAME=`basename ${CXX}`
+if [ "${BUILD_TYPE}" == "shared" ]; then
+  _CMAKE_BUILD_SHARED_LIBS=ON
+else
+  _CMAKE_BUILD_SHARED_LIBS=OFF
+fi
+
+CTEST_TESTING_OPTION="-D ExperimentalTest"
+#   - DO_MemCheck <- if set, try to use valgrind
+if ! ${DO_MemCheck+false}; then
+   valgrind --version
+   CTEST_TESTING_OPTION="-D ExperimentalMemCheck"
+else
+#   - DO_Coverage    <- if set, try to do dashboard coverage testing
+  if ! ${DO_Coverage+false}; then
+     export CXXFLAGS="-fprofile-arcs -ftest-coverage"
+     export LDFLAGS="-fprofile-arcs -ftest-coverage"
+     CTEST_TESTING_OPTION="-D ExperimentalTest -D ExperimentalCoverage"
+     #gcov --version
+  fi
+fi
+
+#  Ninja                        = Generates build.ninja files.
+if ${BUILD_TOOL+false}; then
+  BUILD_TOOL="Ninja"
+  export _BUILD_EXE=ninja
+  which ninja
+  ninja --version
+else
+#  Unix Makefiles               = Generates standard UNIX makefiles.
+  export _BUILD_EXE=make
+fi
+
+_BUILD_DIR_NAME="build-cmake_${BUILD_TYPE}_${LIB_TYPE}_${_COMPILER_NAME}_${_BUILD_EXE}"
+mkdir -p ${_BUILD_DIR_NAME}
+cd "${_BUILD_DIR_NAME}"
+  if ${BUILDNAME+false}; then
+     _HOSTNAME=`hostname -s`
+     BUILDNAME="${_HOSTNAME}_${BUILD_TYPE}_${LIB_TYPE}_${_COMPILER_NAME}_${_BUILD_EXE}"
+  fi
+  cmake \
+    -G "${BUILD_TOOL}" \
+    -DBUILDNAME:STRING="${BUILDNAME}" \
+    -DCMAKE_CXX_COMPILER:PATH=${CXX} \
+    -DCMAKE_BUILD_TYPE:STRING=${BUILD_TYPE} \
+    -DBUILD_SHARED_LIBS:BOOL=${_CMAKE_BUILD_SHARED_LIBS} \
+    -DCMAKE_INSTALL_PREFIX:PATH=${DESTDIR} \
+    ../
+
+  ctest -C ${BUILD_TYPE} -D ExperimentalStart -D ExperimentalConfigure -D ExperimentalBuild ${CTEST_TESTING_OPTION} -D ExperimentalSubmit
+  # Final step is to verify that installation succeeds
+  cmake --build . --config ${BUILD_TYPE} --target install
+  
+  if [ "${DESTDIR}" != "/usr/local" ]; then
+     ${_BUILD_EXE} install
+  fi
+cd -
+
+if ${CLEANUP+false}; then
+  echo "Skipping cleanup:  build directory will persist."
+else
+  rm -r "${_BUILD_DIR_NAME}"
+fi
diff --git a/.travis_scripts/meson_builder.sh b/.travis_scripts/meson_builder.sh
new file mode 100755
index 0000000..dbf03cb
--- /dev/null
+++ b/.travis_scripts/meson_builder.sh
@@ -0,0 +1,81 @@
+#!/usr/bin/env sh
+# This script can be used on the command line directly to configure several
+# different build environments.
+# This is called by `.travis.yml` via Travis CI.
+# Travis supplies $TRAVIS_OS_NAME.
+#  http://docs.travis-ci.com/user/multi-os/
+# Our .travis.yml also defines:
+
+#   - BUILD_TYPE=release/debug
+#   - LIB_TYPE=static/shared
+
+env_set=1
+if ${BUILD_TYPE+false}; then
+  echo "BUILD_TYPE not set in environment."
+  env_set=0
+fi
+if ${LIB_TYPE+false}; then
+  echo "LIB_TYPE not set in environment."
+  env_set=0
+fi
+if ${CXX+false}; then
+  echo "CXX not set in environment."
+  env_set=0
+fi
+
+
+if [ ${env_set} -eq 0 ]; then
+  echo "USAGE:  CXX=$(which clang++)  BUILD_TYPE=[release|debug] LIB_TYPE=[static|shared] $0"
+  echo ""
+  echo "Examples:"
+  echo "           CXX=$(which clang++) BUILD_TYPE=release LIB_TYPE=shared DESTDIR=/tmp/meson_json_cpp $0"
+  echo "           CXX=$(which clang++) BUILD_TYPE=debug   LIB_TYPE=shared DESTDIR=/tmp/meson_json_cpp $0"
+  echo "           CXX=$(which clang++) BUILD_TYPE=release LIB_TYPE=static DESTDIR=/tmp/meson_json_cpp $0"
+  echo "           CXX=$(which clang++) BUILD_TYPE=debug   LIB_TYPE=static DESTDIR=/tmp/meson_json_cpp $0"
+
+  echo "           CXX=$(which g++)     BUILD_TYPE=release LIB_TYPE=shared DESTDIR=/tmp/meson_json_cpp $0"
+  echo "           CXX=$(which g++)     BUILD_TYPE=debug   LIB_TYPE=shared DESTDIR=/tmp/meson_json_cpp $0"
+  echo "           CXX=$(which g++)     BUILD_TYPE=release LIB_TYPE=static DESTDIR=/tmp/meson_json_cpp $0"
+  echo "           CXX=$(which g++)     BUILD_TYPE=debug   LIB_TYPE=static DESTDIR=/tmp/meson_json_cpp $0"
+
+  exit -1
+fi
+
+if ${DESTDIR+false}; then
+  DESTDIR="/usr/local"
+fi
+
+# -e: fail on error
+# -v: show commands
+# -x: show expanded commands
+set -vex
+
+
+env | sort
+
+which python3
+which meson
+which ninja
+echo ${CXX}
+${CXX} --version
+python3 --version
+meson --version
+ninja --version
+_COMPILER_NAME=`basename ${CXX}`
+_BUILD_DIR_NAME="build-${BUILD_TYPE}_${LIB_TYPE}_${_COMPILER_NAME}"
+meson --buildtype ${BUILD_TYPE} --default-library ${LIB_TYPE} . "${_BUILD_DIR_NAME}"
+ninja -v -j 2 -C "${_BUILD_DIR_NAME}"
+#ninja -v -j 2 -C "${_BUILD_DIR_NAME}" test
+cd "${_BUILD_DIR_NAME}"
+  meson test --no-rebuild --print-errorlogs
+
+  if [ "${DESTDIR}" != "/usr/local" ]; then
+     ninja install
+  fi
+cd -
+
+if ${CLEANUP+false}; then
+  echo "Skipping cleanup:  build directory will persist."
+else
+  rm -r "${_BUILD_DIR_NAME}"
+fi
diff --git a/.travis_scripts/travis.before_install.linux.sh b/.travis_scripts/travis.before_install.linux.sh
new file mode 100644
index 0000000..18e019d
--- /dev/null
+++ b/.travis_scripts/travis.before_install.linux.sh
@@ -0,0 +1,7 @@
+set -vex
+#before_install: pyenv install 3.5.4 && pyenv global 3.5.4
+#before_install: pyenv global 3.6
+# https://docs.travis-ci.com/user/languages/python/
+# "for Trusty, this means 2.7.6 and 3.4.3"
+
+pyenv global 3.6
diff --git a/.travis_scripts/travis.before_install.osx.sh b/.travis_scripts/travis.before_install.osx.sh
new file mode 100644
index 0000000..d7d11a5
--- /dev/null
+++ b/.travis_scripts/travis.before_install.osx.sh
@@ -0,0 +1,5 @@
+# NOTHING TO DO HERE
+# set -vex
+ 
+#brew install pyenv
+#which pyenv
diff --git a/.travis_scripts/travis.install.linux.sh b/.travis_scripts/travis.install.linux.sh
new file mode 100644
index 0000000..84c3a61
--- /dev/null
+++ b/.travis_scripts/travis.install.linux.sh
@@ -0,0 +1,10 @@
+set -vex
+
+wget https://github.com/ninja-build/ninja/releases/download/v1.7.2/ninja-linux.zip
+unzip -q ninja-linux.zip -d build
+
+pip3 install meson
+echo ${PATH}
+ls /usr/local
+ls /usr/local/bin
+export PATH="${PWD}"/build:/usr/local/bin:/usr/bin:${PATH}
diff --git a/.travis_scripts/travis.install.osx.sh b/.travis_scripts/travis.install.osx.sh
new file mode 100644
index 0000000..1c6c6f0
--- /dev/null
+++ b/.travis_scripts/travis.install.osx.sh
@@ -0,0 +1,5 @@
+# NOTHING TO DO HERE
+# set -vex
+
+#python3 -m venv venv
+#source venv/bin/activate
diff --git a/CMakeLists.txt b/CMakeLists.txt
index ddcc165..a992437 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,159 +1,186 @@
 # vim: et ts=4 sts=4 sw=4 tw=0
 
-CMAKE_MINIMUM_REQUIRED(VERSION 3.1)
-PROJECT(jsoncpp)
-ENABLE_TESTING()
-
-OPTION(JSONCPP_WITH_TESTS "Compile and (for jsoncpp_check) run JsonCpp test executables" ON)
-OPTION(JSONCPP_WITH_POST_BUILD_UNITTEST "Automatically run unit-tests as a post build step" ON)
-OPTION(JSONCPP_WITH_WARNING_AS_ERROR "Force compilation to fail if a warning occurs" OFF)
-OPTION(JSONCPP_WITH_STRICT_ISO "Issue all the warnings demanded by strict ISO C and ISO C++" ON)
-OPTION(JSONCPP_WITH_PKGCONFIG_SUPPORT "Generate and install .pc files" ON)
-OPTION(JSONCPP_WITH_CMAKE_PACKAGE "Generate and install cmake package files" OFF)
-OPTION(BUILD_SHARED_LIBS "Build jsoncpp_lib as a shared library." OFF)
-OPTION(BUILD_STATIC_LIBS "Build jsoncpp_lib static library." ON)
-
-# Ensures that CMAKE_BUILD_TYPE is visible in cmake-gui on Unix
-IF(NOT WIN32)
-    IF(NOT CMAKE_BUILD_TYPE)
-        SET(CMAKE_BUILD_TYPE Release CACHE STRING
-            "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel Coverage."
-            FORCE)
-    ENDIF()
-ENDIF()
+# ==== Define cmake build policies that affect compilation and linkage default behaviors
+#
+# Set the JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION string to the newest cmake version
+# policies that provide successful builds. By setting JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION
+# to a value greater than the oldest policies, all policies between
+# JSONCPP_OLDEST_VALIDATED_POLICIES_VERSION and CMAKE_VERSION (used for this build)
+# are set to their NEW behaivor, thereby suppressing policy warnings related to policies
+# between the JSONCPP_OLDEST_VALIDATED_POLICIES_VERSION and CMAKE_VERSION.
+#
+# CMake versions greater than the JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION policies will
+# continue to generate policy warnings "CMake Warning (dev)...Policy CMP0XXX is not set:"
+#
+set(JSONCPP_OLDEST_VALIDATED_POLICIES_VERSION "3.1.0")
+set(JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION "3.13.2")
+cmake_minimum_required(VERSION ${JSONCPP_OLDEST_VALIDATED_POLICIES_VERSION})
+if("${CMAKE_VERSION}" VERSION_LESS "${JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION}")
+    #Set and use the newest available cmake policies that are validated to work
+    set(JSONCPP_CMAKE_POLICY_VERSION "${CMAKE_VERSION}")
+else()
+    set(JSONCPP_CMAKE_POLICY_VERSION "${JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION}")
+endif()
+cmake_policy(VERSION ${JSONCPP_CMAKE_POLICY_VERSION})
+#
+# Now enumerate specific policies newer than JSONCPP_NEWEST_VALIDATED_POLICIES_VERSION
+# that may need to be individually set to NEW/OLD
+#
+foreach(pnew "") # Currently Empty
+    if(POLICY ${pnew})
+        cmake_policy(SET ${pnew} NEW)
+    endif()
+endforeach()
+foreach(pold "") # Currently Empty
+    if(POLICY ${pold})
+        cmake_policy(SET ${pold} OLD)
+    endif()
+endforeach()
+
+# ==== Define language standard configurations requiring at least c++11 standard
+if(CMAKE_CXX_STANDARD EQUAL "98" )
+    message(FATAL_ERROR "CMAKE_CXX_STANDARD:STRING=98 is not supported.")
+endif()
+
+#####
+##  Set the default target properties
+if(NOT CMAKE_CXX_STANDARD)
+    set(CMAKE_CXX_STANDARD 11) # Supported values are ``11``, ``14``, and ``17``.
+endif()
+if(NOT CMAKE_CXX_STANDARD_REQUIRED)
+    set(CMAKE_CXX_STANDARD_REQUIRED ON)
+endif()
+if(NOT CMAKE_CXX_EXTENSIONS)
+    set(CMAKE_CXX_EXTENSIONS OFF)
+endif()
+
+# ====
+
+# Ensures that CMAKE_BUILD_TYPE has a default value
+if(NOT DEFINED CMAKE_BUILD_TYPE)
+    set(CMAKE_BUILD_TYPE Release CACHE STRING
+        "Choose the type of build, options are: None Debug Release RelWithDebInfo MinSizeRel Coverage.")
+endif()
+
+project(JSONCPP
+        VERSION 1.9.0 # <major>[.<minor>[.<patch>[.<tweak>]]]
+        LANGUAGES CXX)
+
+set( JSONCPP_VERSION ${JSONCPP_VERSION_MAJOR}.${JSONCPP_VERSION_MINOR}.${JSONCPP_VERSION_PATCH} )
+message(STATUS "JsonCpp Version: ${JSONCPP_VERSION_MAJOR}.${JSONCPP_VERSION_MINOR}.${JSONCPP_VERSION_PATCH}")
+set( JSONCPP_SOVERSION 21 )
+
+option(JSONCPP_WITH_TESTS "Compile and (for jsoncpp_check) run JsonCpp test executables" ON)
+option(JSONCPP_WITH_POST_BUILD_UNITTEST "Automatically run unit-tests as a post build step" ON)
+option(JSONCPP_WITH_WARNING_AS_ERROR "Force compilation to fail if a warning occurs" OFF)
+option(JSONCPP_WITH_STRICT_ISO "Issue all the warnings demanded by strict ISO C and ISO C++" ON)
+option(JSONCPP_WITH_PKGCONFIG_SUPPORT "Generate and install .pc files" ON)
+option(JSONCPP_WITH_CMAKE_PACKAGE "Generate and install cmake package files" ON)
+option(BUILD_SHARED_LIBS "Build jsoncpp_lib as a shared library." OFF)
 
 # Enable runtime search path support for dynamic libraries on OSX
-IF(APPLE)
-    SET(CMAKE_MACOSX_RPATH 1)
-ENDIF()
+if(APPLE)
+    set(CMAKE_MACOSX_RPATH 1)
+endif()
 
 # Adhere to GNU filesystem layout conventions
-INCLUDE(GNUInstallDirs)
+include(GNUInstallDirs)
 
-SET(DEBUG_LIBNAME_SUFFIX "" CACHE STRING "Optional suffix to append to the library name for a debug build")
+set(DEBUG_LIBNAME_SUFFIX "" CACHE STRING "Optional suffix to append to the library name for a debug build")
 
 # Set variable named ${VAR_NAME} to value ${VALUE}
-FUNCTION(set_using_dynamic_name VAR_NAME VALUE)
-    SET( "${VAR_NAME}" "${VALUE}" PARENT_SCOPE)
-ENDFUNCTION()
-
-# Extract major, minor, patch from version text
-# Parse a version string "X.Y.Z" and outputs
-# version parts in ${OUPUT_PREFIX}_MAJOR, _MINOR, _PATCH.
-# If parse succeeds then ${OUPUT_PREFIX}_FOUND is TRUE.
-MACRO(jsoncpp_parse_version VERSION_TEXT OUPUT_PREFIX)
-    SET(VERSION_REGEX "[0-9]+\\.[0-9]+\\.[0-9]+(-[a-zA-Z0-9_]+)?")
-    IF( ${VERSION_TEXT} MATCHES ${VERSION_REGEX} )
-        STRING(REGEX MATCHALL "[0-9]+|-([A-Za-z0-9_]+)" VERSION_PARTS ${VERSION_TEXT})
-        LIST(GET VERSION_PARTS 0 ${OUPUT_PREFIX}_MAJOR)
-        LIST(GET VERSION_PARTS 1 ${OUPUT_PREFIX}_MINOR)
-        LIST(GET VERSION_PARTS 2 ${OUPUT_PREFIX}_PATCH)
-        set_using_dynamic_name( "${OUPUT_PREFIX}_FOUND" TRUE )
-    ELSE( ${VERSION_TEXT} MATCHES ${VERSION_REGEX} )
-        set_using_dynamic_name( "${OUPUT_PREFIX}_FOUND" FALSE )
-    ENDIF()
-ENDMACRO()
-
-# Read out version from "version" file
-#FILE(STRINGS "version" JSONCPP_VERSION)
-#SET( JSONCPP_VERSION_MAJOR X )
-#SET( JSONCPP_VERSION_MINOR Y )
-#SET( JSONCPP_VERSION_PATCH Z )
-SET( JSONCPP_VERSION 1.8.4 )
-jsoncpp_parse_version( ${JSONCPP_VERSION} JSONCPP_VERSION )
-#IF(NOT JSONCPP_VERSION_FOUND)
-#    MESSAGE(FATAL_ERROR "Failed to parse version string properly. Expect X.Y.Z")
-#ENDIF(NOT JSONCPP_VERSION_FOUND)
-SET( JSONCPP_SOVERSION 19 )
-SET( JSONCPP_USE_SECURE_MEMORY "0" CACHE STRING "-D...=1 to use memory-wiping allocator for STL" )
-
-MESSAGE(STATUS "JsonCpp Version: ${JSONCPP_VERSION_MAJOR}.${JSONCPP_VERSION_MINOR}.${JSONCPP_VERSION_PATCH}")
+function(set_using_dynamic_name VAR_NAME VALUE)
+    set( "${VAR_NAME}" "${VALUE}" PARENT_SCOPE)
+endfunction()
+
+set( JSONCPP_USE_SECURE_MEMORY "0" CACHE STRING "-D...=1 to use memory-wiping allocator for STL" )
+
 # File version.h is only regenerated on CMake configure step
-CONFIGURE_FILE( "${PROJECT_SOURCE_DIR}/src/lib_json/version.h.in"
-                "${PROJECT_SOURCE_DIR}/include/json/version.h"
+configure_file( "${PROJECT_SOURCE_DIR}/src/lib_json/version.h.in"
+                "${PROJECT_BINARY_DIR}/include/json/version.h"
                 NEWLINE_STYLE UNIX )
-CONFIGURE_FILE( "${PROJECT_SOURCE_DIR}/version.in"
-                "${PROJECT_SOURCE_DIR}/version"
+configure_file( "${PROJECT_SOURCE_DIR}/version.in"
+                "${PROJECT_BINARY_DIR}/version"
                 NEWLINE_STYLE UNIX )
 
-MACRO(UseCompilationWarningAsError)
-    IF(MSVC)
+macro(UseCompilationWarningAsError)
+    if(MSVC)
         # Only enabled in debug because some old versions of VS STL generate
         # warnings when compiled in release configuration.
-        SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /WX ")
-    ELSEIF(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
-        SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror")
-        IF(JSONCPP_WITH_STRICT_ISO)
-            SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic-errors")
-        ENDIF()
-    ENDIF()
-ENDMACRO()
+        set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /WX ")
+    elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
+        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror")
+        if(JSONCPP_WITH_STRICT_ISO)
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic-errors")
+        endif()
+    endif()
+endmacro()
 
 # Include our configuration header
-INCLUDE_DIRECTORIES( ${jsoncpp_SOURCE_DIR}/include )
+include_directories( ${jsoncpp_SOURCE_DIR}/include )
 
-IF(MSVC)
+if(MSVC)
     # Only enabled in debug because some old versions of VS STL generate
     # unreachable code warning when compiled in release configuration.
-    SET(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /W4 ")
-ENDIF()
-
-# Require C++11 support, prefer ISO C++ over GNU variants,
-# as relying solely on ISO C++ is more portable.
-SET(CMAKE_CXX_STANDARD 11)
-SET(CMAKE_CXX_STANDARD_REQUIRED ON)
-SET(CMAKE_CXX_EXTENSIONS OFF)
+    set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} /W4 ")
+endif()
 
-IF(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
+if(CMAKE_CXX_COMPILER_ID MATCHES "Clang")
     # using regular Clang or AppleClang
-    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wconversion -Wshadow -Werror=conversion -Werror=sign-compare")
-ELSEIF(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wconversion -Wshadow -Werror=conversion -Werror=sign-compare")
+elseif(CMAKE_CXX_COMPILER_ID STREQUAL "GNU")
     # using GCC
-    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wconversion -Wshadow -Wextra")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wconversion -Wshadow -Wextra")
     # not yet ready for -Wsign-conversion
 
-    IF(JSONCPP_WITH_STRICT_ISO)
-        SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic")
-    ENDIF()
-    IF(JSONCPP_WITH_WARNING_AS_ERROR)
-        SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror=conversion")
-    ENDIF()
-ELSEIF(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
+    if(JSONCPP_WITH_STRICT_ISO)
+        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic")
+    endif()
+    if(JSONCPP_WITH_WARNING_AS_ERROR)
+        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror=conversion")
+    endif()
+elseif(CMAKE_CXX_COMPILER_ID STREQUAL "Intel")
     # using Intel compiler
-    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wconversion -Wshadow -Wextra -Werror=conversion")
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wconversion -Wshadow -Wextra -Werror=conversion")
 
-    IF(JSONCPP_WITH_STRICT_ISO AND NOT JSONCPP_WITH_WARNING_AS_ERROR)
-        SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic")
-    ENDIF()
-ENDIF()
+    if(JSONCPP_WITH_STRICT_ISO AND NOT JSONCPP_WITH_WARNING_AS_ERROR)
+        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pedantic")
+    endif()
+endif()
 
-FIND_PROGRAM(CCACHE_FOUND ccache)
-IF(CCACHE_FOUND)
-    SET_PROPERTY(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)
-    SET_PROPERTY(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)
-ENDIF(CCACHE_FOUND)
+find_program(CCACHE_FOUND ccache)
+if(CCACHE_FOUND)
+    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE ccache)
+    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK ccache)
+endif(CCACHE_FOUND)
 
-IF(JSONCPP_WITH_WARNING_AS_ERROR)
+if(JSONCPP_WITH_WARNING_AS_ERROR)
     UseCompilationWarningAsError()
-ENDIF()
+endif()
 
-IF(JSONCPP_WITH_PKGCONFIG_SUPPORT)
-    CONFIGURE_FILE(
+if(JSONCPP_WITH_PKGCONFIG_SUPPORT)
+    configure_file(
         "pkg-config/jsoncpp.pc.in"
         "pkg-config/jsoncpp.pc"
         @ONLY)
-    INSTALL(FILES "${CMAKE_CURRENT_BINARY_DIR}/pkg-config/jsoncpp.pc"
+    install(FILES "${CMAKE_CURRENT_BINARY_DIR}/pkg-config/jsoncpp.pc"
         DESTINATION "${CMAKE_INSTALL_LIBDIR}/pkgconfig")
-ENDIF()
+endif()
 
-IF(JSONCPP_WITH_CMAKE_PACKAGE)
-        INSTALL(EXPORT jsoncpp
+if(JSONCPP_WITH_CMAKE_PACKAGE)
+        install(EXPORT jsoncpp
                 DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/jsoncpp
                 FILE        jsoncppConfig.cmake)
-ENDIF()
+endif()
+
+if(JSONCPP_WITH_TESTS)
+  enable_testing()
+  include(CTest)
+endif()
 
 # Build the different applications
-ADD_SUBDIRECTORY( src )
+add_subdirectory( src )
 
 #install the includes
-ADD_SUBDIRECTORY( include )
+add_subdirectory( include )
+
diff --git a/CTestConfig.cmake b/CTestConfig.cmake
new file mode 100644
index 0000000..b8fc6d5
--- /dev/null
+++ b/CTestConfig.cmake
@@ -0,0 +1,15 @@
+## This file should be placed in the root directory of your project.
+## Then modify the CMakeLists.txt file in the root directory of your
+## project to incorporate the testing dashboard.
+##
+## # The following are required to submit to the CDash dashboard:
+##   ENABLE_TESTING()
+##   INCLUDE(CTest)
+
+set(CTEST_PROJECT_NAME "jsoncpp")
+set(CTEST_NIGHTLY_START_TIME "01:23:45 UTC")
+
+set(CTEST_DROP_METHOD "https")
+set(CTEST_DROP_SITE "my.cdash.org")
+set(CTEST_DROP_LOCATION "/submit.php?project=jsoncpp")
+set(CTEST_DROP_SITE_CDASH TRUE)
diff --git a/README.md b/README.md
index 8332742..2e64092 100644
--- a/README.md
+++ b/README.md
@@ -1,6 +1,6 @@
 # JsonCpp
 
-[![badge](https://img.shields.io/badge/conan.io-jsoncpp%2F1.8.0-green.svg?logo=data:image/png;base64%2CiVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAMAAAAolt3jAAAA1VBMVEUAAABhlctjlstkl8tlmMtlmMxlmcxmmcxnmsxpnMxpnM1qnc1sn85voM91oM11oc1xotB2oc56pNF6pNJ2ptJ8ptJ8ptN9ptN8p9N5qNJ9p9N9p9R8qtOBqdSAqtOAqtR%2BrNSCrNJ/rdWDrNWCsNWCsNaJs9eLs9iRvNuVvdyVv9yXwd2Zwt6axN6dxt%2Bfx%2BChyeGiyuGjyuCjyuGly%2BGlzOKmzOGozuKoz%2BKqz%2BOq0OOv1OWw1OWw1eWx1eWy1uay1%2Baz1%2Baz1%2Bez2Oe02Oe12ee22ujUGwH3AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfgBQkREyOxFIh/AAAAiklEQVQI12NgAAMbOwY4sLZ2NtQ1coVKWNvoc/Eq8XDr2wB5Ig62ekza9vaOqpK2TpoMzOxaFtwqZua2Bm4makIM7OzMAjoaCqYuxooSUqJALjs7o4yVpbowvzSUy87KqSwmxQfnsrPISyFzWeWAXCkpMaBVIC4bmCsOdgiUKwh3JojLgAQ4ZCE0AMm2D29tZwe6AAAAAElFTkSuQmCC)](http://www.conan.io/source/jsoncpp/1.8.0/theirix/ci)
+[![badge](https://img.shields.io/badge/conan.io-jsoncpp%2F1.8.0-green.svg?logo=data:image/png;base64%2CiVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAMAAAAolt3jAAAA1VBMVEUAAABhlctjlstkl8tlmMtlmMxlmcxmmcxnmsxpnMxpnM1qnc1sn85voM91oM11oc1xotB2oc56pNF6pNJ2ptJ8ptJ8ptN9ptN8p9N5qNJ9p9N9p9R8qtOBqdSAqtOAqtR%2BrNSCrNJ/rdWDrNWCsNWCsNaJs9eLs9iRvNuVvdyVv9yXwd2Zwt6axN6dxt%2Bfx%2BChyeGiyuGjyuCjyuGly%2BGlzOKmzOGozuKoz%2BKqz%2BOq0OOv1OWw1OWw1eWx1eWy1uay1%2Baz1%2Baz1%2Bez2Oe02Oe12ee22ujUGwH3AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfgBQkREyOxFIh/AAAAiklEQVQI12NgAAMbOwY4sLZ2NtQ1coVKWNvoc/Eq8XDr2wB5Ig62ekza9vaOqpK2TpoMzOxaFtwqZua2Bm4makIM7OzMAjoaCqYuxooSUqJALjs7o4yVpbowvzSUy87KqSwmxQfnsrPISyFzWeWAXCkpMaBVIC4bmCsOdgiUKwh3JojLgAQ4ZCE0AMm2D29tZwe6AAAAAElFTkSuQmCC)](https://bintray.com/theirix/conan-repo/jsoncpp%3Atheirix)
 
 [JSON][json-org] is a lightweight data-interchange format. It can represent
 numbers, strings, ordered sequences of values, and collections of name/value
@@ -30,8 +30,19 @@ format to store user input files.
 
 ## Contributing to JsonCpp
 
+### Building
+
+Both CMake and Meson tools are capable of generating a variety of build environments for you preferred development environment.
+Using cmake or meson you can generate an XCode, Visual Studio, Unix Makefile, Ninja, or other environment that fits your needs.
+
+An example of a common Meson/Ninja environment is described next.
+
 ### Building and testing with Meson/Ninja
-Thanks to David Seifert (@SoapGentoo), we (the maintainers) now use [meson](http://mesonbuild.com/) and [ninja](https://ninja-build.org/) to build for debugging, as well as for continuous integration (see [`travis.sh`](travis.sh) ). Other systems may work, but minor things like version strings might break.
+Thanks to David Seifert (@SoapGentoo), we (the maintainers) now use
+[meson](http://mesonbuild.com/) and [ninja](https://ninja-build.org/) to build
+for debugging, as well as for continuous integration (see
+[`./travis_scripts/meson_builder.sh`](./travis_scripts/meson_builder.sh) ). Other systems may work, but minor
+things like version strings might break.
 
 First, install both meson (which requires Python3) and ninja.
 If you wish to install to a directory other than /usr/local, set an environment variable called DESTDIR with the desired path:
@@ -45,8 +56,10 @@ Then,
     LIB_TYPE=shared
     #LIB_TYPE=static
     meson --buildtype ${BUILD_TYPE} --default-library ${LIB_TYPE} . build-${LIB_TYPE}
-    ninja -v -C build-${LIB_TYPE} test
+    #ninja -v -C build-${LIB_TYPE} test # This stopped working on my Mac.
+    ninja -v -C build-${LIB_TYPE}
     cd build-${LIB_TYPE}
+    meson test --no-rebuild --print-errorlogs
     sudo ninja install
 
 ### Building and testing with other build systems
@@ -126,6 +139,9 @@ When a test is run, output files are generated beside the input test files. Belo
 ### Amalgamated source
 https://github.com/open-source-parsers/jsoncpp/wiki/Amalgamated
 
+### The Meson Build System
+If you are using the [Meson Build System](http://mesonbuild.com), then you can get a wrap file by downloading it from [Meson WrapDB](https://wrapdb.mesonbuild.com/jsoncpp), or simply use `meson wrap install jsoncpp`.
+
 ### Other ways
 If you have trouble, see the Wiki, or post a question as an Issue.
 
diff --git a/amalgamate.py b/amalgamate.py
index f4bff4d..c12215a 100644
--- a/amalgamate.py
+++ b/amalgamate.py
@@ -67,7 +67,7 @@ def amalgamate_source(source_top_dir=None,
     header.add_text("/// to prevent private header inclusion.")
     header.add_text("#define JSON_IS_AMALGAMATION")
     header.add_file("include/json/version.h")
-    #header.add_file("include/json/allocator.h") # Not available here.
+    header.add_file("include/json/allocator.h")
     header.add_file("include/json/config.h")
     header.add_file("include/json/forwards.h")
     header.add_file("include/json/features.h")
diff --git a/appveyor.yml b/appveyor.yml
index 5d497de..447a212 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -10,7 +10,11 @@ environment:
 build_script:
   - cmake --version
   - cd c:\projects\jsoncpp
-  - cmake -G "%CMAKE_GENERATOR%" -DCMAKE_INSTALL_PREFIX=%CD:\=/%/install -DCMAKE_BUILD_TYPE=Release -DBUILD_SHARED_LIBS=ON .
+  - cmake -G "%CMAKE_GENERATOR%" -DCMAKE_INSTALL_PREFIX:PATH=%CD:\=/%/install -DBUILD_SHARED_LIBS:BOOL=ON .
+  # Use ctest to make a dashboard build ctest -D Experimental(Start|Update|Configure|Build|Test|Coverage|MemCheck|Submit)
+  #NOTE Testing on window is not yet finished - ctest -C Release -D ExperimentalStart -D ExperimentalConfigure -D ExperimentalBuild -D ExperimentalTest -D ExperimentalSubmit
+  - ctest -C Release -D ExperimentalStart -D ExperimentalConfigure -D ExperimentalBuild -D ExperimentalSubmit
+    # Final step is to verify that installation succeeds
   - cmake --build . --config Release --target install
 
 deploy:
diff --git a/dev.makefile b/dev.makefile
index 7e4b3fb..1a4be6a 100644
--- a/dev.makefile
+++ b/dev.makefile
@@ -1,6 +1,6 @@
 # This is only for jsoncpp developers/contributors.
 # We use this to sign releases, generate documentation, etc.
-VER?=$(shell cat version)
+VER?=$(shell cat version.txt)
 
 default:
 	@echo "VER=${VER}"
diff --git a/doc/doxyfile.in b/doc/doxyfile.in
index 7bbe9bc..dcf514e 100644
--- a/doc/doxyfile.in
+++ b/doc/doxyfile.in
@@ -1072,7 +1072,7 @@ HTML_STYLESHEET        =
 # defined cascading style sheet that is included after the standard style sheets
 # created by doxygen. Using this option one can overrule certain style aspects.
 # This is preferred over using HTML_STYLESHEET since it does not replace the
-# standard style sheet and is therefor more robust against future updates.
+# standard style sheet and is therefore more robust against future updates.
 # Doxygen will copy the style sheet file to the output directory. For an example
 # see the documentation.
 # This tag requires that the tag GENERATE_HTML is set to YES.
@@ -1944,7 +1944,7 @@ INCLUDE_FILE_PATTERNS  = *.h
 # recursively expanded use the := operator instead of the = operator.
 # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
 
-PREDEFINED             = "_MSC_VER=1400" \
+PREDEFINED             = "_MSC_VER=1800" \
                          _CPPRTTI \
                          _WIN32 \
                          JSONCPP_DOC_EXCLUDE_IMPLEMENTATION
diff --git a/doc/web_doxyfile.in b/doc/web_doxyfile.in
index 7b4c934..df09dcc 100644
--- a/doc/web_doxyfile.in
+++ b/doc/web_doxyfile.in
@@ -1072,7 +1072,7 @@ HTML_STYLESHEET        =
 # defined cascading style sheet that is included after the standard style sheets
 # created by doxygen. Using this option one can overrule certain style aspects.
 # This is preferred over using HTML_STYLESHEET since it does not replace the
-# standard style sheet and is therefor more robust against future updates.
+# standard style sheet and is therefore more robust against future updates.
 # Doxygen will copy the style sheet file to the output directory. For an example
 # see the documentation.
 # This tag requires that the tag GENERATE_HTML is set to YES.
@@ -1932,7 +1932,7 @@ INCLUDE_FILE_PATTERNS  = *.h
 # recursively expanded use the := operator instead of the = operator.
 # This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
 
-PREDEFINED             = "_MSC_VER=1400" \
+PREDEFINED             = "_MSC_VER=1800" \
                          _CPPRTTI \
                          _WIN32 \
                          JSONCPP_DOC_EXCLUDE_IMPLEMENTATION
diff --git a/include/CMakeLists.txt b/include/CMakeLists.txt
index cc866f1..7f1cb98 100644
--- a/include/CMakeLists.txt
+++ b/include/CMakeLists.txt
@@ -1,2 +1,2 @@
-FILE(GLOB INCLUDE_FILES "json/*.h")
-INSTALL(FILES ${INCLUDE_FILES} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/json)
+file(GLOB INCLUDE_FILES "json/*.h")
+install(FILES ${INCLUDE_FILES} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/json)
diff --git a/include/json/allocator.h b/include/json/allocator.h
index 9c7e573..d5f987e 100644
--- a/include/json/allocator.h
+++ b/include/json/allocator.h
@@ -12,86 +12,77 @@
 #pragma pack(push, 8)
 
 namespace Json {
-template<typename T>
-class SecureAllocator {
-	public:
-		// Type definitions
-		using value_type      = T;
-		using pointer         = T*;
-		using const_pointer   = const T*;
-		using reference       = T&;
-		using const_reference = const T&;
-		using size_type       = std::size_t;
-		using difference_type = std::ptrdiff_t;
-
-		/**
-		 * Allocate memory for N items using the standard allocator.
-		 */
-		pointer allocate(size_type n) {
-			// allocate using "global operator new"
-			return static_cast<pointer>(::operator new(n * sizeof(T)));
-		}
-
-		/**
-		 * Release memory which was allocated for N items at pointer P.
-		 *
-		 * The memory block is filled with zeroes before being released.
-		 * The pointer argument is tagged as "volatile" to prevent the
-		 * compiler optimizing out this critical step.
-		 */
-		void deallocate(volatile pointer p, size_type n) {
-			std::memset(p, 0, n * sizeof(T));
-			// free using "global operator delete"
-			::operator delete(p);
-		}
-
-		/**
-		 * Construct an item in-place at pointer P.
-		 */
-		template<typename... Args>
-		void construct(pointer p, Args&&... args) {
-			// construct using "placement new" and "perfect forwarding"
-			::new (static_cast<void*>(p)) T(std::forward<Args>(args)...);
-		}
-
-		size_type max_size() const {
-			return size_t(-1) / sizeof(T);
-		}
-
-		pointer address( reference x ) const {
-			return std::addressof(x);
-		}
-
-		const_pointer address( const_reference x ) const {
-			return std::addressof(x);
-		}
-
-		/**
-		 * Destroy an item in-place at pointer P.
-		 */
-		void destroy(pointer p) {
-			// destroy using "explicit destructor"
-			p->~T();
-		}
-
-		// Boilerplate
-		SecureAllocator() {}
-		template<typename U> SecureAllocator(const SecureAllocator<U>&) {}
-		template<typename U> struct rebind { using other = SecureAllocator<U>; };
+template <typename T> class SecureAllocator {
+public:
+  // Type definitions
+  using value_type = T;
+  using pointer = T*;
+  using const_pointer = const T*;
+  using reference = T&;
+  using const_reference = const T&;
+  using size_type = std::size_t;
+  using difference_type = std::ptrdiff_t;
+
+  /**
+   * Allocate memory for N items using the standard allocator.
+   */
+  pointer allocate(size_type n) {
+    // allocate using "global operator new"
+    return static_cast<pointer>(::operator new(n * sizeof(T)));
+  }
+
+  /**
+   * Release memory which was allocated for N items at pointer P.
+   *
+   * The memory block is filled with zeroes before being released.
+   * The pointer argument is tagged as "volatile" to prevent the
+   * compiler optimizing out this critical step.
+   */
+  void deallocate(volatile pointer p, size_type n) {
+    std::memset(p, 0, n * sizeof(T));
+    // free using "global operator delete"
+    ::operator delete(p);
+  }
+
+  /**
+   * Construct an item in-place at pointer P.
+   */
+  template <typename... Args> void construct(pointer p, Args&&... args) {
+    // construct using "placement new" and "perfect forwarding"
+    ::new (static_cast<void*>(p)) T(std::forward<Args>(args)...);
+  }
+
+  size_type max_size() const { return size_t(-1) / sizeof(T); }
+
+  pointer address(reference x) const { return std::addressof(x); }
+
+  const_pointer address(const_reference x) const { return std::addressof(x); }
+
+  /**
+   * Destroy an item in-place at pointer P.
+   */
+  void destroy(pointer p) {
+    // destroy using "explicit destructor"
+    p->~T();
+  }
+
+  // Boilerplate
+  SecureAllocator() {}
+  template <typename U> SecureAllocator(const SecureAllocator<U>&) {}
+  template <typename U> struct rebind { using other = SecureAllocator<U>; };
 };
 
-
-template<typename T, typename U>
+template <typename T, typename U>
 bool operator==(const SecureAllocator<T>&, const SecureAllocator<U>&) {
-	return true;
+  return true;
 }
 
-template<typename T, typename U>
+template <typename T, typename U>
 bool operator!=(const SecureAllocator<T>&, const SecureAllocator<U>&) {
-	return false;
+  return false;
 }
 
-} //namespace Json
+} // namespace Json
 
 #pragma pack(pop)
 
diff --git a/include/json/assertions.h b/include/json/assertions.h
index 1cca28d..20716b0 100644
--- a/include/json/assertions.h
+++ b/include/json/assertions.h
@@ -6,7 +6,7 @@
 #ifndef CPPTL_JSON_ASSERTIONS_H_INCLUDED
 #define CPPTL_JSON_ASSERTIONS_H_INCLUDED
 
-#include <stdlib.h>
+#include <cstdlib>
 #include <sstream>
 
 #if !defined(JSON_IS_AMALGAMATION)
@@ -20,30 +20,35 @@
 #if JSON_USE_EXCEPTION
 
 // @todo <= add detail about condition in exception
-# define JSON_ASSERT(condition)                                                \
-  {if (!(condition)) {Json::throwLogicError( "assert json failed" );}}
+#define JSON_ASSERT(condition)                                                 \
+  {                                                                            \
+    if (!(condition)) {                                                        \
+      Json::throwLogicError("assert json failed");                             \
+    }                                                                          \
+  }
 
-# define JSON_FAIL_MESSAGE(message)                                            \
+#define JSON_FAIL_MESSAGE(message)                                             \
   {                                                                            \
-    JSONCPP_OSTRINGSTREAM oss; oss << message;                                    \
+    OStringStream oss;                                                         \
+    oss << message;                                                            \
     Json::throwLogicError(oss.str());                                          \
     abort();                                                                   \
   }
 
 #else // JSON_USE_EXCEPTION
 
-# define JSON_ASSERT(condition) assert(condition)
+#define JSON_ASSERT(condition) assert(condition)
 
 // The call to assert() will show the failure message in debug builds. In
 // release builds we abort, for a core-dump or debugger.
-# define JSON_FAIL_MESSAGE(message)                                            \
+#define JSON_FAIL_MESSAGE(message)                                             \
   {                                                                            \
-    JSONCPP_OSTRINGSTREAM oss; oss << message;                                    \
+    OStringStream oss;                                                         \
+    oss << message;                                                            \
     assert(false && oss.str().c_str());                                        \
     abort();                                                                   \
   }
 
-
 #endif
 
 #define JSON_ASSERT_MESSAGE(condition, message)                                \
diff --git a/include/json/config.h b/include/json/config.h
index d6bad30..cba6102 100644
--- a/include/json/config.h
+++ b/include/json/config.h
@@ -5,9 +5,14 @@
 
 #ifndef JSON_CONFIG_H_INCLUDED
 #define JSON_CONFIG_H_INCLUDED
-#include <stddef.h>
-#include <string> //typedef String
-#include <stdint.h> //typedef int64_t, uint64_t
+#include <cstddef>
+#include <cstdint>
+#include <istream>
+#include <memory>
+#include <ostream>
+#include <sstream>
+#include <string>
+#include <type_traits>
 
 /// If defined, indicates that json library is embedded in CppTL library.
 //# define JSON_IN_CPPTL 1
@@ -43,6 +48,8 @@
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #define JSON_API __declspec(dllexport)
 #define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
+#elif defined(__GNUC__) || defined(__clang__)
+#define JSON_API __attribute__((visibility("default")))
 #endif // if defined(_MSC_VER)
 #elif defined(JSON_DLL)
 #if defined(_MSC_VER) || defined(__MINGW32__)
@@ -54,98 +61,70 @@
 #define JSON_API
 #endif
 
+#if defined(_MSC_VER) && _MSC_VER < 1800
+#error                                                                         \
+    "ERROR:  Visual Studio 12 (2013) with _MSC_VER=1800 is the oldest supported compiler with sufficient C++11 capabilities"
+#endif
+
+#if defined(_MSC_VER) && _MSC_VER < 1900
+// As recommended at
+// https://stackoverflow.com/questions/2915672/snprintf-and-visual-studio-2010
+extern JSON_API int
+msvc_pre1900_c99_snprintf(char* outBuf, size_t size, const char* format, ...);
+#define jsoncpp_snprintf msvc_pre1900_c99_snprintf
+#else
+#define jsoncpp_snprintf std::snprintf
+#endif
+
 // If JSON_NO_INT64 is defined, then Json only support C++ "int" type for
 // integer
 // Storages, and 64 bits integer support is disabled.
 // #define JSON_NO_INT64 1
 
-#if defined(_MSC_VER) // MSVC
-#  if _MSC_VER <= 1200 // MSVC 6
-    // Microsoft Visual Studio 6 only support conversion from __int64 to double
-    // (no conversion from unsigned __int64).
-#    define JSON_USE_INT64_DOUBLE_CONVERSION 1
-    // Disable warning 4786 for VS6 caused by STL (identifier was truncated to '255'
-    // characters in the debug information)
-    // All projects I've ever seen with VS6 were using this globally (not bothering
-    // with pragma push/pop).
-#    pragma warning(disable : 4786)
-#  endif // MSVC 6
-
-#  if _MSC_VER >= 1500 // MSVC 2008
-    /// Indicates that the following function is deprecated.
-#    define JSONCPP_DEPRECATED(message) __declspec(deprecated(message))
-#  endif
-
-#endif // defined(_MSC_VER)
-
-// In c++11 the override keyword allows you to explicitly define that a function
-// is intended to override the base-class version.  This makes the code more
-// managable and fixes a set of common hard-to-find bugs.
+// JSONCPP_OVERRIDE is maintained for backwards compatibility of external tools.
+// C++11 should be used directly in JSONCPP.
+#define JSONCPP_OVERRIDE override
+
 #if __cplusplus >= 201103L
-# define JSONCPP_OVERRIDE override
-# define JSONCPP_NOEXCEPT noexcept
-#elif defined(_MSC_VER) && _MSC_VER > 1600 && _MSC_VER < 1900
-# define JSONCPP_OVERRIDE override
-# define JSONCPP_NOEXCEPT throw()
+#define JSONCPP_NOEXCEPT noexcept
+#define JSONCPP_OP_EXPLICIT explicit
+#elif defined(_MSC_VER) && _MSC_VER < 1900
+#define JSONCPP_NOEXCEPT throw()
+#define JSONCPP_OP_EXPLICIT explicit
 #elif defined(_MSC_VER) && _MSC_VER >= 1900
-# define JSONCPP_OVERRIDE override
-# define JSONCPP_NOEXCEPT noexcept
+#define JSONCPP_NOEXCEPT noexcept
+#define JSONCPP_OP_EXPLICIT explicit
 #else
-# define JSONCPP_OVERRIDE
-# define JSONCPP_NOEXCEPT throw()
+#define JSONCPP_NOEXCEPT throw()
+#define JSONCPP_OP_EXPLICIT
 #endif
 
-#ifndef JSON_HAS_RVALUE_REFERENCES
-
-#if defined(_MSC_VER) && _MSC_VER >= 1600 // MSVC >= 2010
-#define JSON_HAS_RVALUE_REFERENCES 1
-#endif // MSVC >= 2010
-
 #ifdef __clang__
-#if __has_feature(cxx_rvalue_references)
-#define JSON_HAS_RVALUE_REFERENCES 1
-#endif  // has_feature
-
-#elif defined __GNUC__ // not clang (gcc comes later since clang emulates gcc)
-#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus >= 201103L)
-#define JSON_HAS_RVALUE_REFERENCES 1
-#endif  // GXX_EXPERIMENTAL
-
-#endif // __clang__ || __GNUC__
-
-#endif // not defined JSON_HAS_RVALUE_REFERENCES
-
-#ifndef JSON_HAS_RVALUE_REFERENCES
-#define JSON_HAS_RVALUE_REFERENCES 0
+#if __has_extension(attribute_deprecated_with_message)
+#define JSONCPP_DEPRECATED(message) __attribute__((deprecated(message)))
 #endif
-
-#ifdef __clang__
-#  if __has_extension(attribute_deprecated_with_message)
-#    define JSONCPP_DEPRECATED(message)  __attribute__ ((deprecated(message)))
-#  endif
 #elif defined __GNUC__ // not clang (gcc comes later since clang emulates gcc)
-#  if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
-#    define JSONCPP_DEPRECATED(message)  __attribute__ ((deprecated(message)))
-#  elif (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
-#    define JSONCPP_DEPRECATED(message)  __attribute__((__deprecated__))
-#  endif  // GNUC version
-#endif // __clang__ || __GNUC__
+#if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
+#define JSONCPP_DEPRECATED(message) __attribute__((deprecated(message)))
+#elif (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
+#define JSONCPP_DEPRECATED(message) __attribute__((__deprecated__))
+#endif // GNUC version
+#elif defined(_MSC_VER) // MSVC (after clang because clang on Windows emulates MSVC)
+#define JSONCPP_DEPRECATED(message) __declspec(deprecated(message))
+#endif // __clang__ || __GNUC__ || _MSC_VER
 
 #if !defined(JSONCPP_DEPRECATED)
 #define JSONCPP_DEPRECATED(message)
 #endif // if !defined(JSONCPP_DEPRECATED)
 
 #if __GNUC__ >= 6
-#  define JSON_USE_INT64_DOUBLE_CONVERSION 1
+#define JSON_USE_INT64_DOUBLE_CONVERSION 1
 #endif
 
 #if !defined(JSON_IS_AMALGAMATION)
 
-# include "version.h"
-
-# if JSONCPP_USING_SECURE_MEMORY
-#  include "allocator.h" //typedef Allocator
-# endif
+#include "allocator.h"
+#include "version.h"
 
 #endif // if !defined(JSON_IS_AMALGAMATION)
 
@@ -164,24 +143,32 @@ typedef unsigned __int64 UInt64;
 #else                 // if defined(_MSC_VER) // Other platforms, use long long
 typedef int64_t Int64;
 typedef uint64_t UInt64;
-#endif // if defined(_MSC_VER)
+#endif                // if defined(_MSC_VER)
 typedef Int64 LargestInt;
 typedef UInt64 LargestUInt;
 #define JSON_HAS_INT64
 #endif // if defined(JSON_NO_INT64)
-#if JSONCPP_USING_SECURE_MEMORY
-#define JSONCPP_STRING        std::basic_string<char, std::char_traits<char>, Json::SecureAllocator<char> >
-#define JSONCPP_OSTRINGSTREAM std::basic_ostringstream<char, std::char_traits<char>, Json::SecureAllocator<char> >
-#define JSONCPP_OSTREAM       std::basic_ostream<char, std::char_traits<char>>
-#define JSONCPP_ISTRINGSTREAM std::basic_istringstream<char, std::char_traits<char>, Json::SecureAllocator<char> >
-#define JSONCPP_ISTREAM       std::istream
-#else
-#define JSONCPP_STRING        std::string
-#define JSONCPP_OSTRINGSTREAM std::ostringstream
-#define JSONCPP_OSTREAM       std::ostream
-#define JSONCPP_ISTRINGSTREAM std::istringstream
-#define JSONCPP_ISTREAM       std::istream
-#endif // if JSONCPP_USING_SECURE_MEMORY
-} // end namespace Json
+
+template <typename T>
+using Allocator = typename std::conditional<JSONCPP_USING_SECURE_MEMORY,
+                                            SecureAllocator<T>,
+                                            std::allocator<T>>::type;
+using String = std::basic_string<char, std::char_traits<char>, Allocator<char>>;
+using IStringStream = std::basic_istringstream<String::value_type,
+                                               String::traits_type,
+                                               String::allocator_type>;
+using OStringStream = std::basic_ostringstream<String::value_type,
+                                               String::traits_type,
+                                               String::allocator_type>;
+using IStream = std::istream;
+using OStream = std::ostream;
+} // namespace Json
+
+// Legacy names (formerly macros).
+using JSONCPP_STRING = Json::String;
+using JSONCPP_ISTRINGSTREAM = Json::IStringStream;
+using JSONCPP_OSTRINGSTREAM = Json::OStringStream;
+using JSONCPP_ISTREAM = Json::IStream;
+using JSONCPP_OSTREAM = Json::OStream;
 
 #endif // JSON_CONFIG_H_INCLUDED
diff --git a/include/json/features.h b/include/json/features.h
index 72eb6a8..ba25e8d 100644
--- a/include/json/features.h
+++ b/include/json/features.h
@@ -41,17 +41,17 @@ public:
   Features();
 
   /// \c true if comments are allowed. Default: \c true.
-  bool allowComments_;
+  bool allowComments_{true};
 
   /// \c true if root must be either an array or an object value. Default: \c
   /// false.
-  bool strictRoot_;
+  bool strictRoot_{false};
 
   /// \c true if dropped null placeholders are allowed. Default: \c false.
-  bool allowDroppedNullPlaceholders_;
+  bool allowDroppedNullPlaceholders_{false};
 
   /// \c true if numeric object key are allowed. Default: \c false.
-  bool allowNumericKeys_;
+  bool allowNumericKeys_{false};
 };
 
 } // namespace Json
diff --git a/include/json/json.h b/include/json/json.h
index 3d2798a..19f14c2 100644
--- a/include/json/json.h
+++ b/include/json/json.h
@@ -7,9 +7,9 @@
 #define JSON_JSON_H_INCLUDED
 
 #include "autolink.h"
-#include "value.h"
+#include "features.h"
 #include "reader.h"
+#include "value.h"
 #include "writer.h"
-#include "features.h"
 
 #endif // JSON_JSON_H_INCLUDED
diff --git a/include/json/reader.h b/include/json/reader.h
index 82859fd..111e5dd 100644
--- a/include/json/reader.h
+++ b/include/json/reader.h
@@ -12,9 +12,9 @@
 #endif // if !defined(JSON_IS_AMALGAMATION)
 #include <deque>
 #include <iosfwd>
+#include <istream>
 #include <stack>
 #include <string>
-#include <istream>
 
 // Disable warning C4251: <data member>: <type> needs to have dll-interface to
 // be used by...
@@ -32,7 +32,7 @@ namespace Json {
  *
  * \deprecated Use CharReader and CharReaderBuilder.
  */
-class JSONCPP_DEPRECATED("Use CharReader and CharReaderBuilder instead") JSON_API Reader {
+class JSON_API Reader {
 public:
   typedef char Char;
   typedef const Char* Location;
@@ -46,17 +46,19 @@ public:
   struct StructuredError {
     ptrdiff_t offset_start;
     ptrdiff_t offset_limit;
-    JSONCPP_STRING message;
+    String message;
   };
 
   /** \brief Constructs a Reader allowing all features
    * for parsing.
    */
+  JSONCPP_DEPRECATED("Use CharReader and CharReaderBuilder instead")
   Reader();
 
   /** \brief Constructs a Reader allowing the specified feature set
    * for parsing.
    */
+  JSONCPP_DEPRECATED("Use CharReader and CharReaderBuilder instead")
   Reader(const Features& features);
 
   /** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
@@ -101,7 +103,7 @@ public:
 
   /// \brief Parse from input stream.
   /// \see Json::operator>>(std::istream&, Json::Value&).
-  bool parse(JSONCPP_ISTREAM& is, Value& root, bool collectComments = true);
+  bool parse(IStream& is, Value& root, bool collectComments = true);
 
   /** \brief Returns a user friendly string that list errors in the parsed
    * document.
@@ -113,7 +115,7 @@ public:
    * \deprecated Use getFormattedErrorMessages() instead (typo fix).
    */
   JSONCPP_DEPRECATED("Use getFormattedErrorMessages() instead.")
-  JSONCPP_STRING getFormatedErrorMessages() const;
+  String getFormatedErrorMessages() const;
 
   /** \brief Returns a user friendly string that list errors in the parsed
    * document.
@@ -123,7 +125,7 @@ public:
    * occurred
    *         during parsing.
    */
-  JSONCPP_STRING getFormattedErrorMessages() const;
+  String getFormattedErrorMessages() const;
 
   /** \brief Returns a vector of structured erros encounted while parsing.
    * \return A (possibly empty) vector of StructuredError objects. Currently
@@ -140,7 +142,7 @@ public:
    * \return \c true if the error was successfully added, \c false if the
    * Value offset exceeds the document size.
    */
-  bool pushError(const Value& value, const JSONCPP_STRING& message);
+  bool pushError(const Value& value, const String& message);
 
   /** \brief Add a semantic error message with extra context.
    * \param value JSON Value location associated with the error
@@ -149,7 +151,7 @@ public:
    * \return \c true if the error was successfully added, \c false if either
    * Value offset exceeds the document size.
    */
-  bool pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra);
+  bool pushError(const Value& value, const String& message, const Value& extra);
 
   /** \brief Return whether there are any errors.
    * \return \c true if there are no errors to report \c false if
@@ -185,7 +187,7 @@ private:
   class ErrorInfo {
   public:
     Token token_;
-    JSONCPP_STRING message_;
+    String message_;
     Location extra_;
   };
 
@@ -205,7 +207,7 @@ private:
   bool decodeNumber(Token& token);
   bool decodeNumber(Token& token, Value& decoded);
   bool decodeString(Token& token);
-  bool decodeString(Token& token, JSONCPP_STRING& decoded);
+  bool decodeString(Token& token, String& decoded);
   bool decodeDouble(Token& token);
   bool decodeDouble(Token& token, Value& decoded);
   bool decodeUnicodeCodePoint(Token& token,
@@ -216,9 +218,9 @@ private:
                                    Location& current,
                                    Location end,
                                    unsigned int& unicode);
-  bool addError(const JSONCPP_STRING& message, Token& token, Location extra = 0);
+  bool addError(const String& message, Token& token, Location extra = nullptr);
   bool recoverFromError(TokenType skipUntilToken);
-  bool addErrorAndRecover(const JSONCPP_STRING& message,
+  bool addErrorAndRecover(const String& message,
                           Token& token,
                           TokenType skipUntilToken);
   void skipUntilSpace();
@@ -226,35 +228,36 @@ private:
   Char getNextChar();
   void
   getLocationLineAndColumn(Location location, int& line, int& column) const;
-  JSONCPP_STRING getLocationLineAndColumn(Location location) const;
+  String getLocationLineAndColumn(Location location) const;
   void addComment(Location begin, Location end, CommentPlacement placement);
   void skipCommentTokens(Token& token);
 
   static bool containsNewLine(Location begin, Location end);
-  static JSONCPP_STRING normalizeEOL(Location begin, Location end);
+  static String normalizeEOL(Location begin, Location end);
 
   typedef std::stack<Value*> Nodes;
   Nodes nodes_;
   Errors errors_;
-  JSONCPP_STRING document_;
-  Location begin_;
-  Location end_;
-  Location current_;
-  Location lastValueEnd_;
-  Value* lastValue_;
-  JSONCPP_STRING commentsBefore_;
+  String document_;
+  Location begin_{};
+  Location end_{};
+  Location current_{};
+  Location lastValueEnd_{};
+  Value* lastValue_{};
+  String commentsBefore_;
   Features features_;
-  bool collectComments_;
-};  // Reader
+  bool collectComments_{};
+}; // Reader
 
 /** Interface for reading JSON from a char array.
  */
 class JSON_API CharReader {
 public:
-  virtual ~CharReader() {}
+  virtual ~CharReader() = default;
   /** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
    document.
-   * The document must be a UTF-8 encoded string containing the document to read.
+   * The document must be a UTF-8 encoded string containing the document to
+   read.
    *
    * \param beginDoc Pointer on the beginning of the UTF-8 encoded string of the
    document to read.
@@ -269,19 +272,20 @@ public:
    * \return \c true if the document was successfully parsed, \c false if an
    error occurred.
    */
-  virtual bool parse(
-      char const* beginDoc, char const* endDoc,
-      Value* root, JSONCPP_STRING* errs) = 0;
+  virtual bool parse(char const* beginDoc,
+                     char const* endDoc,
+                     Value* root,
+                     String* errs) = 0;
 
   class JSON_API Factory {
   public:
-    virtual ~Factory() {}
+    virtual ~Factory() = default;
     /** \brief Allocate a CharReader via operator new().
      * \throw std::exception if something goes wrong (e.g. invalid settings)
      */
     virtual CharReader* newCharReader() const = 0;
-  };  // Factory
-};  // CharReader
+  }; // Factory
+};   // CharReader
 
 /** \brief Build a CharReader implementation.
 
@@ -291,7 +295,7 @@ Usage:
   CharReaderBuilder builder;
   builder["collectComments"] = false;
   Value value;
-  JSONCPP_STRING errs;
+  String errs;
   bool ok = parseFromStream(builder, std::cin, &value, &errs);
 \endcode
 */
@@ -311,7 +315,8 @@ public:
     - `"strictRoot": false or true`
       - true if root must be either an array or an object value
     - `"allowDroppedNullPlaceholders": false or true`
-      - true if dropped null placeholders are allowed. (See StreamWriterBuilder.)
+      - true if dropped null placeholders are allowed. (See
+    StreamWriterBuilder.)
     - `"allowNumericKeys": false or true`
       - true if numeric object keys are allowed.
     - `"allowSingleQuotes": false or true`
@@ -325,9 +330,10 @@ public:
       - If true, `parse()` returns false when extra non-whitespace trails
         the JSON value in the input string.
     - `"rejectDupKeys": false or true`
-      - If true, `parse()` returns false when a key is duplicated within an object.
+      - If true, `parse()` returns false when a key is duplicated within an
+    object.
     - `"allowSpecialFloats": false or true`
-      - If true, special float values (NaNs and infinities) are allowed 
+      - If true, special float values (NaNs and infinities) are allowed
         and their values are lossfree restorable.
 
     You can examine 'settings_` yourself
@@ -338,9 +344,9 @@ public:
   Json::Value settings_;
 
   CharReaderBuilder();
-  ~CharReaderBuilder() JSONCPP_OVERRIDE;
+  ~CharReaderBuilder() override;
 
-  CharReader* newCharReader() const JSONCPP_OVERRIDE;
+  CharReader* newCharReader() const override;
 
   /** \return true if 'settings' are legal and consistent;
    *   otherwise, indicate bad settings via 'invalid'.
@@ -349,7 +355,7 @@ public:
 
   /** A simple way to update a specific setting.
    */
-  Value& operator[](JSONCPP_STRING key);
+  Value& operator[](const String& key);
 
   /** Called by ctor, but you can use this to reset settings_.
    * \pre 'settings' != NULL (but Json::null is fine)
@@ -366,13 +372,13 @@ public:
 };
 
 /** Consume entire stream and use its begin/end.
-  * Someday we might have a real StreamReader, but for now this
-  * is convenient.
-  */
-bool JSON_API parseFromStream(
-    CharReader::Factory const&,
-    JSONCPP_ISTREAM&,
-    Value* root, std::string* errs);
+ * Someday we might have a real StreamReader, but for now this
+ * is convenient.
+ */
+bool JSON_API parseFromStream(CharReader::Factory const&,
+                              IStream&,
+                              Value* root,
+                              std::string* errs);
 
 /** \brief Read from 'sin' into 'root'.
 
@@ -398,7 +404,7 @@ bool JSON_API parseFromStream(
  \throw std::exception on parse error.
  \see Json::operator<<()
 */
-JSON_API JSONCPP_ISTREAM& operator>>(JSONCPP_ISTREAM&, Value&);
+JSON_API IStream& operator>>(IStream&, Value&);
 
 } // namespace Json
 
diff --git a/include/json/value.h b/include/json/value.h
index 67d0333..5f8d214 100644
--- a/include/json/value.h
+++ b/include/json/value.h
@@ -9,9 +9,11 @@
 #if !defined(JSON_IS_AMALGAMATION)
 #include "forwards.h"
 #endif // if !defined(JSON_IS_AMALGAMATION)
+#include <array>
+#include <exception>
+#include <memory>
 #include <string>
 #include <vector>
-#include <exception>
 
 #ifndef JSON_USE_CPPTL_SMALLMAP
 #include <map>
@@ -22,17 +24,17 @@
 #include <cpptl/forwards.h>
 #endif
 
-//Conditional NORETURN attribute on the throw functions would:
+// Conditional NORETURN attribute on the throw functions would:
 // a) suppress false positives from static code analysis
 // b) possibly improve optimization opportunities.
 #if !defined(JSONCPP_NORETURN)
-#  if defined(_MSC_VER)
-#    define JSONCPP_NORETURN __declspec(noreturn)
-#  elif defined(__GNUC__)
-#    define JSONCPP_NORETURN __attribute__ ((__noreturn__))
-#  else
-#    define JSONCPP_NORETURN
-#  endif
+#if defined(_MSC_VER)
+#define JSONCPP_NORETURN __declspec(noreturn)
+#elif defined(__GNUC__)
+#define JSONCPP_NORETURN __attribute__((__noreturn__))
+#else
+#define JSONCPP_NORETURN
+#endif
 #endif
 
 // Disable warning C4251: <data member>: <type> needs to have dll-interface to
@@ -54,11 +56,12 @@ namespace Json {
  */
 class JSON_API Exception : public std::exception {
 public:
-  Exception(JSONCPP_STRING const& msg);
-  ~Exception() JSONCPP_NOEXCEPT JSONCPP_OVERRIDE;
-  char const* what() const JSONCPP_NOEXCEPT JSONCPP_OVERRIDE;
+  Exception(String msg);
+  ~Exception() JSONCPP_NOEXCEPT override;
+  char const* what() const JSONCPP_NOEXCEPT override;
+
 protected:
-  JSONCPP_STRING msg_;
+  String msg_;
 };
 
 /** Exceptions which the user cannot easily avoid.
@@ -69,7 +72,7 @@ protected:
  */
 class JSON_API RuntimeError : public Exception {
 public:
-  RuntimeError(JSONCPP_STRING const& msg);
+  RuntimeError(String const& msg);
 };
 
 /** Exceptions thrown by JSON_ASSERT/JSON_FAIL macros.
@@ -80,13 +83,13 @@ public:
  */
 class JSON_API LogicError : public Exception {
 public:
-  LogicError(JSONCPP_STRING const& msg);
+  LogicError(String const& msg);
 };
 
 /// used internally
-JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg);
+JSONCPP_NORETURN void throwRuntimeError(String const& msg);
 /// used internally
-JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg);
+JSONCPP_NORETURN void throwLogicError(String const& msg);
 
 /** \brief Type of the value held by a Value object.
  */
@@ -109,6 +112,13 @@ enum CommentPlacement {
   numberOfCommentPlacement
 };
 
+/** \brief Type of precision for formatting of real values.
+ */
+enum PrecisionType {
+  significantDigits = 0, ///< we set max number of significant digits in string
+  decimalPlaces          ///< we set max number of digits after "." in string
+};
+
 //# ifdef JSON_USE_CPPTL
 //   typedef CppTL::AnyEnumerator<const char *> EnumMemberNames;
 //   typedef CppTL::AnyEnumerator<const Value &> EnumValues;
@@ -165,7 +175,7 @@ private:
  * The get() methods can be used to obtain default value in the case the
  * required element does not exist.
  *
- * It is possible to iterate over the list of a #objectValue values using
+ * It is possible to iterate over the list of member keys of an object using
  * the getMemberNames() method.
  *
  * \note #Value string-length fit in size_t, but keys must be < 2^30.
@@ -176,8 +186,9 @@ private:
  */
 class JSON_API Value {
   friend class ValueIteratorBase;
+
 public:
-  typedef std::vector<JSONCPP_STRING> Members;
+  typedef std::vector<String> Members;
   typedef ValueIterator iterator;
   typedef ValueConstIterator const_iterator;
   typedef Json::UInt UInt;
@@ -193,8 +204,10 @@ public:
   // Required for boost integration, e. g. BOOST_TEST
   typedef std::string value_type;
 
-  static const Value& null;  ///< We regret this reference to a global instance; prefer the simpler Value().
-  static const Value& nullRef;  ///< just a kludge for binary-compatibility; same as null
+  static const Value& null; ///< We regret this reference to a global instance;
+                            ///< prefer the simpler Value().
+  static const Value& nullRef; ///< just a kludge for binary-compatibility; same
+                               ///< as null
   static Value const& nullSingleton(); ///< Prefer this to null or nullRef.
 
   /// Minimum signed integer value that can be stored in a Json::Value.
@@ -220,32 +233,33 @@ public:
   static const UInt64 maxUInt64;
 #endif // defined(JSON_HAS_INT64)
 
+  /// Default precision for real value for string representation.
+  static const UInt defaultRealPrecision;
+
+// Workaround for bug in the NVIDIAs CUDA 9.1 nvcc compiler
+// when using gcc and clang backend compilers.  CZString
+// cannot be defined as private.  See issue #486
+#ifdef __NVCC__
+public:
+#else
 private:
+#endif
 #ifndef JSONCPP_DOC_EXCLUDE_IMPLEMENTATION
   class CZString {
   public:
-    enum DuplicationPolicy {
-      noDuplication = 0,
-      duplicate,
-      duplicateOnCopy
-    };
+    enum DuplicationPolicy { noDuplication = 0, duplicate, duplicateOnCopy };
     CZString(ArrayIndex index);
     CZString(char const* str, unsigned length, DuplicationPolicy allocate);
     CZString(CZString const& other);
-#if JSON_HAS_RVALUE_REFERENCES
     CZString(CZString&& other);
-#endif
     ~CZString();
     CZString& operator=(const CZString& other);
-
-#if JSON_HAS_RVALUE_REFERENCES
     CZString& operator=(CZString&& other);
-#endif
 
     bool operator<(CZString const& other) const;
     bool operator==(CZString const& other) const;
     ArrayIndex index() const;
-    //const char* c_str() const; ///< \deprecated
+    // const char* c_str() const; ///< \deprecated
     char const* data() const;
     unsigned length() const;
     bool isStaticString() const;
@@ -254,11 +268,11 @@ private:
     void swap(CZString& other);
 
     struct StringStorage {
-      unsigned policy_: 2;
-      unsigned length_: 30; // 1GB max
+      unsigned policy_ : 2;
+      unsigned length_ : 30; // 1GB max
     };
 
-    char const* cstr_;  // actually, a prefixed string, unless policy is noDup
+    char const* cstr_; // actually, a prefixed string, unless policy is noDup
     union {
       ArrayIndex index_;
       StringStorage storage_;
@@ -315,22 +329,20 @@ Json::Value obj_value(Json::objectValue); // {}
    * \endcode
    */
   Value(const StaticString& value);
-  Value(const JSONCPP_STRING& value); ///< Copy data() til size(). Embedded zeroes too.
+  Value(const String& value); ///< Copy data() til size(). Embedded
+                              ///< zeroes too.
 #ifdef JSON_USE_CPPTL
   Value(const CppTL::ConstString& value);
 #endif
   Value(bool value);
-  /// Deep copy.
   Value(const Value& other);
-#if JSON_HAS_RVALUE_REFERENCES
-  /// Move constructor
   Value(Value&& other);
-#endif
   ~Value();
 
-  /// Deep copy, then swap(other).
-  /// \note Over-write existing comments. To preserve comments, use #swapPayload().
-  Value& operator=(Value other);
+  /// \note Overwrite existing comments. To preserve comments, use
+  /// #swapPayload().
+  Value& operator=(const Value& other);
+  Value& operator=(Value&& other);
 
   /// Swap everything.
   void swap(Value& other);
@@ -355,14 +367,14 @@ Json::Value obj_value(Json::objectValue); // {}
 
   const char* asCString() const; ///< Embedded zeroes could cause you trouble!
 #if JSONCPP_USING_SECURE_MEMORY
-  unsigned getCStringLength() const; //Allows you to understand the length of the CString
+  unsigned getCStringLength() const; // Allows you to understand the length of
+                                     // the CString
 #endif
-  JSONCPP_STRING asString() const; ///< Embedded zeroes are possible.
+  String asString() const; ///< Embedded zeroes are possible.
   /** Get raw char* of string-value.
    *  \return false if !string. (Seg-fault if str or end are NULL.)
    */
-  bool getString(
-      char const** begin, char const** end) const;
+  bool getString(char const** begin, char const** end) const;
 #ifdef JSON_USE_CPPTL
   CppTL::ConstString asConstString() const;
 #endif
@@ -401,19 +413,19 @@ Json::Value obj_value(Json::objectValue); // {}
   bool empty() const;
 
   /// Return !isNull()
-  explicit operator bool() const;
+  JSONCPP_OP_EXPLICIT operator bool() const;
 
   /// Remove all object members and array elements.
   /// \pre type() is arrayValue, objectValue, or nullValue
   /// \post type() is unchanged
   void clear();
 
-  /// Resize the array to size elements.
+  /// Resize the array to newSize elements.
   /// New elements are initialized to null.
   /// May only be called on nullValue or arrayValue.
   /// \pre type() is arrayValue or nullValue
   /// \post type() is arrayValue
-  void resize(ArrayIndex size);
+  void resize(ArrayIndex newSize);
 
   /// Access an array element (zero based index ).
   /// If the array contains less than index element, then null value are
@@ -451,10 +463,7 @@ Json::Value obj_value(Json::objectValue); // {}
   ///
   /// Equivalent to jsonvalue[jsonvalue.size()] = value;
   Value& append(const Value& value);
-
-#if JSON_HAS_RVALUE_REFERENCES
   Value& append(Value&& value);
-#endif
 
   /// Access an object value by name, create a null member if it does not exist.
   /// \note Because of our implementation, keys are limited to 2^30 -1 chars.
@@ -465,15 +474,16 @@ Json::Value obj_value(Json::objectValue); // {}
   const Value& operator[](const char* key) const;
   /// Access an object value by name, create a null member if it does not exist.
   /// \param key may contain embedded nulls.
-  Value& operator[](const JSONCPP_STRING& key);
+  Value& operator[](const String& key);
   /// Access an object value by name, returns null if there is no member with
   /// that name.
   /// \param key may contain embedded nulls.
-  const Value& operator[](const JSONCPP_STRING& key) const;
+  const Value& operator[](const String& key) const;
   /** \brief Access an object value by name, create a null member if it does not
    exist.
 
-   * If the object has no entry for that name, then the member name used to store
+   * If the object has no entry for that name, then the member name used to
+   store
    * the new entry is not duplicated.
    * Example of use:
    * \code
@@ -496,11 +506,12 @@ Json::Value obj_value(Json::objectValue); // {}
   /// Return the member named key if it exist, defaultValue otherwise.
   /// \note deep copy
   /// \note key may contain embedded nulls.
-  Value get(const char* begin, const char* end, const Value& defaultValue) const;
+  Value
+  get(const char* begin, const char* end, const Value& defaultValue) const;
   /// Return the member named key if it exist, defaultValue otherwise.
   /// \note deep copy
   /// \param key may contain embedded nulls.
-  Value get(const JSONCPP_STRING& key, const Value& defaultValue) const;
+  Value get(const String& key, const Value& defaultValue) const;
 #ifdef JSON_USE_CPPTL
   /// Return the member named key if it exist, defaultValue otherwise.
   /// \note deep copy
@@ -513,19 +524,16 @@ Json::Value obj_value(Json::objectValue); // {}
   /// Most general and efficient version of object-mutators.
   /// \note As stated elsewhere, behavior is undefined if (end-begin) >= 2^30
   /// \return non-zero, but JSON_ASSERT if this is neither object nor nullValue.
-  Value const* demand(char const* begin, char const* end);
+  Value* demand(char const* begin, char const* end);
   /// \brief Remove and return the named member.
   ///
   /// Do nothing if it did not exist.
-  /// \return the removed Value, or null.
   /// \pre type() is objectValue or nullValue
   /// \post type() is unchanged
-  /// \deprecated
   void removeMember(const char* key);
   /// Same as removeMember(const char*)
   /// \param key may contain embedded nulls.
-  /// \deprecated
-  void removeMember(const JSONCPP_STRING& key);
+  void removeMember(const String& key);
   /// Same as removeMember(const char* begin, const char* end, Value* removed),
   /// but 'key' is null-terminated.
   bool removeMember(const char* key, Value* removed);
@@ -535,24 +543,24 @@ Json::Value obj_value(Json::objectValue); // {}
       \param key may contain embedded nulls.
       \return true iff removed (no exceptions)
   */
-  bool removeMember(JSONCPP_STRING const& key, Value* removed);
-  /// Same as removeMember(JSONCPP_STRING const& key, Value* removed)
+  bool removeMember(String const& key, Value* removed);
+  /// Same as removeMember(String const& key, Value* removed)
   bool removeMember(const char* begin, const char* end, Value* removed);
   /** \brief Remove the indexed array element.
 
       O(n) expensive operations.
       Update 'removed' iff removed.
-      \return true iff removed (no exceptions)
+      \return true if removed (no exceptions)
   */
-  bool removeIndex(ArrayIndex i, Value* removed);
+  bool removeIndex(ArrayIndex index, Value* removed);
 
   /// Return true if the object has a member named key.
   /// \note 'key' must be null-terminated.
   bool isMember(const char* key) const;
   /// Return true if the object has a member named key.
   /// \param key may contain embedded nulls.
-  bool isMember(const JSONCPP_STRING& key) const;
-  /// Same as isMember(JSONCPP_STRING const& key)const
+  bool isMember(const String& key) const;
+  /// Same as isMember(String const& key)const
   bool isMember(const char* begin, const char* end) const;
 #ifdef JSON_USE_CPPTL
   /// Return true if the object has a member named key.
@@ -572,17 +580,21 @@ Json::Value obj_value(Json::objectValue); // {}
   //# endif
 
   /// \deprecated Always pass len.
-  JSONCPP_DEPRECATED("Use setComment(JSONCPP_STRING const&) instead.")
-  void setComment(const char* comment, CommentPlacement placement);
+  JSONCPP_DEPRECATED("Use setComment(String const&) instead.")
+  void setComment(const char* comment, CommentPlacement placement) {
+    setComment(String(comment, strlen(comment)), placement);
+  }
   /// Comments must be //... or /* ... */
-  void setComment(const char* comment, size_t len, CommentPlacement placement);
+  void setComment(const char* comment, size_t len, CommentPlacement placement) {
+    setComment(String(comment, len), placement);
+  }
   /// Comments must be //... or /* ... */
-  void setComment(const JSONCPP_STRING& comment, CommentPlacement placement);
+  void setComment(String comment, CommentPlacement placement);
   bool hasComment(CommentPlacement placement) const;
   /// Include delimiters and embedded newlines.
-  JSONCPP_STRING getComment(CommentPlacement placement) const;
+  String getComment(CommentPlacement placement) const;
 
-  JSONCPP_STRING toStyledString() const;
+  String toStyledString() const;
 
   const_iterator begin() const;
   const_iterator end() const;
@@ -598,20 +610,18 @@ Json::Value obj_value(Json::objectValue); // {}
   ptrdiff_t getOffsetLimit() const;
 
 private:
+  void setType(ValueType v) { bits_.value_type_ = static_cast<unsigned char> (v); }
+  bool isAllocated() const { return bits_.allocated_; }
+  void setIsAllocated(bool v) { bits_.allocated_ = v; }
+
   void initBasic(ValueType type, bool allocated = false);
+  void dupPayload(const Value& other);
+  void releasePayload();
+  void dupMeta(const Value& other);
 
   Value& resolveReference(const char* key);
   Value& resolveReference(const char* key, const char* end);
 
-  struct CommentInfo {
-    CommentInfo();
-    ~CommentInfo();
-
-    void setComment(const char* text, size_t len);
-
-    char* comment_;
-  };
-
   // struct MemberNamesTransform
   //{
   //   typedef const char *result_type;
@@ -626,13 +636,33 @@ private:
     LargestUInt uint_;
     double real_;
     bool bool_;
-    char* string_;  // actually ptr to unsigned, followed by str, unless !allocated_
+    char* string_; // if allocated_, ptr to { unsigned, char[] }.
     ObjectValues* map_;
   } value_;
-  ValueType type_ : 8;
-  unsigned int allocated_ : 1; // Notes: if declared as bool, bitfield is useless.
-                               // If not allocated_, string_ must be null-terminated.
-  CommentInfo* comments_;
+
+  struct {
+    // Really a ValueType, but types should agree for bitfield packing.
+    unsigned int value_type_ : 8;
+    // Unless allocated_, string_ must be null-terminated.
+    unsigned int allocated_ : 1;
+  } bits_;
+
+  class Comments {
+  public:
+    Comments() = default;
+    Comments(const Comments& that);
+    Comments(Comments&& that);
+    Comments& operator=(const Comments& that);
+    Comments& operator=(Comments&& that);
+    bool has(CommentPlacement slot) const;
+    String get(CommentPlacement slot) const;
+    void set(CommentPlacement slot, String s);
+
+  private:
+    using Array = std::array<String, numberOfCommentPlacement>;
+    std::unique_ptr<Array> ptr_;
+  };
+  Comments comments_;
 
   // [start, limit) byte offsets in the source JSON text from which this Value
   // was extracted.
@@ -650,17 +680,13 @@ public:
   PathArgument();
   PathArgument(ArrayIndex index);
   PathArgument(const char* key);
-  PathArgument(const JSONCPP_STRING& key);
+  PathArgument(const String& key);
 
 private:
-  enum Kind {
-    kindNone = 0,
-    kindIndex,
-    kindKey
-  };
-  JSONCPP_STRING key_;
-  ArrayIndex index_;
-  Kind kind_;
+  enum Kind { kindNone = 0, kindIndex, kindKey };
+  String key_;
+  ArrayIndex index_{};
+  Kind kind_{kindNone};
 };
 
 /** \brief Experimental and untested: represents a "path" to access a node.
@@ -676,7 +702,7 @@ private:
  */
 class JSON_API Path {
 public:
-  Path(const JSONCPP_STRING& path,
+  Path(const String& path,
        const PathArgument& a1 = PathArgument(),
        const PathArgument& a2 = PathArgument(),
        const PathArgument& a3 = PathArgument(),
@@ -693,12 +719,12 @@ private:
   typedef std::vector<const PathArgument*> InArgs;
   typedef std::vector<PathArgument> Args;
 
-  void makePath(const JSONCPP_STRING& path, const InArgs& in);
-  void addPathInArg(const JSONCPP_STRING& path,
+  void makePath(const String& path, const InArgs& in);
+  void addPathInArg(const String& path,
                     const InArgs& in,
                     InArgs::const_iterator& itInArg,
                     PathArgument::Kind kind);
-  void invalidPath(const JSONCPP_STRING& path, int location);
+  static void invalidPath(const String& path, int location);
 
   Args args_;
 };
@@ -725,17 +751,19 @@ public:
   /// Value.
   Value key() const;
 
-  /// Return the index of the referenced Value, or -1 if it is not an arrayValue.
+  /// Return the index of the referenced Value, or -1 if it is not an
+  /// arrayValue.
   UInt index() const;
 
   /// Return the member name of the referenced Value, or "" if it is not an
   /// objectValue.
   /// \note Avoid `c_str()` on result, as embedded zeroes are possible.
-  JSONCPP_STRING name() const;
+  String name() const;
 
   /// Return the member name of the referenced Value. "" if it is not an
   /// objectValue.
-  /// \deprecated This cannot be used for UTF-8 strings, since there can be embedded nulls.
+  /// \deprecated This cannot be used for UTF-8 strings, since there can be
+  /// embedded nulls.
   JSONCPP_DEPRECATED("Use `key = name();` instead.")
   char const* memberName() const;
   /// Return the member name of the referenced Value, or NULL if it is not an
@@ -759,7 +787,7 @@ protected:
 private:
   Value::ObjectValues::iterator current_;
   // Indicates that iterator is for a null value.
-  bool isNull_;
+  bool isNull_{true};
 
 public:
   // For some reason, BORLAND needs these at the end, rather
@@ -776,8 +804,8 @@ class JSON_API ValueConstIterator : public ValueIteratorBase {
 
 public:
   typedef const Value value_type;
-  //typedef unsigned int size_t;
-  //typedef int difference_type;
+  // typedef unsigned int size_t;
+  // typedef int difference_type;
   typedef const Value& reference;
   typedef const Value* pointer;
   typedef ValueConstIterator SelfType;
@@ -786,9 +814,10 @@ public:
   ValueConstIterator(ValueIterator const& other);
 
 private:
-/*! \internal Use by Value to create an iterator.
- */
+  /*! \internal Use by Value to create an iterator.
+   */
   explicit ValueConstIterator(const Value::ObjectValues::iterator& current);
+
 public:
   SelfType& operator=(const ValueIteratorBase& other);
 
@@ -837,9 +866,10 @@ public:
   ValueIterator(const ValueIterator& other);
 
 private:
-/*! \internal Use by Value to create an iterator.
- */
+  /*! \internal Use by Value to create an iterator.
+   */
   explicit ValueIterator(const Value::ObjectValues::iterator& current);
+
 public:
   SelfType& operator=(const SelfType& other);
 
@@ -870,14 +900,9 @@ public:
   pointer operator->() const { return &deref(); }
 };
 
-} // namespace Json
+inline void swap(Value& a, Value& b) { a.swap(b); }
 
-
-namespace std {
-/// Specialize std::swap() for Json::Value.
-template<>
-inline void swap(Json::Value& a, Json::Value& b) { a.swap(b); }
-}
+} // namespace Json
 
 #pragma pack(pop)
 
diff --git a/include/json/version.h b/include/json/version.h
index 06c6187..027f731 100644
--- a/include/json/version.h
+++ b/include/json/version.h
@@ -1,14 +1,16 @@
 // DO NOT EDIT. This file (and "version") is generated by CMake.
 // Run CMake configure step to update it.
 #ifndef JSON_VERSION_H_INCLUDED
-# define JSON_VERSION_H_INCLUDED
+#define JSON_VERSION_H_INCLUDED
 
-# define JSONCPP_VERSION_STRING "1.8.4"
-# define JSONCPP_VERSION_MAJOR 1
-# define JSONCPP_VERSION_MINOR 8
-# define JSONCPP_VERSION_PATCH 4
-# define JSONCPP_VERSION_QUALIFIER
-# define JSONCPP_VERSION_HEXA ((JSONCPP_VERSION_MAJOR << 24) | (JSONCPP_VERSION_MINOR << 16) | (JSONCPP_VERSION_PATCH << 8))
+#define JSONCPP_VERSION_STRING "1.8.4"
+#define JSONCPP_VERSION_MAJOR 1
+#define JSONCPP_VERSION_MINOR 8
+#define JSONCPP_VERSION_PATCH 4
+#define JSONCPP_VERSION_QUALIFIER
+#define JSONCPP_VERSION_HEXA                                                   \
+  ((JSONCPP_VERSION_MAJOR << 24) | (JSONCPP_VERSION_MINOR << 16) |             \
+   (JSONCPP_VERSION_PATCH << 8))
 
 #ifdef JSONCPP_USING_SECURE_MEMORY
 #undef JSONCPP_USING_SECURE_MEMORY
diff --git a/include/json/writer.h b/include/json/writer.h
index 2278bc8..12fd36a 100644
--- a/include/json/writer.h
+++ b/include/json/writer.h
@@ -9,9 +9,9 @@
 #if !defined(JSON_IS_AMALGAMATION)
 #include "value.h"
 #endif // if !defined(JSON_IS_AMALGAMATION)
-#include <vector>
-#include <string>
 #include <ostream>
+#include <string>
+#include <vector>
 
 // Disable warning C4251: <data member>: <type> needs to have dll-interface to
 // be used by...
@@ -41,17 +41,17 @@ Usage:
 */
 class JSON_API StreamWriter {
 protected:
-  JSONCPP_OSTREAM* sout_;  // not owned; will not delete
+  OStream* sout_; // not owned; will not delete
 public:
   StreamWriter();
   virtual ~StreamWriter();
   /** Write Value into document as configured in sub-class.
       Do not take ownership of sout, but maintain a reference during function.
       \pre sout != NULL
-      \return zero on success (For now, we always return zero, so check the stream instead.)
-      \throw std::exception possibly, depending on configuration
+      \return zero on success (For now, we always return zero, so check the
+     stream instead.) \throw std::exception possibly, depending on configuration
    */
-  virtual int write(Value const& root, JSONCPP_OSTREAM* sout) = 0;
+  virtual int write(Value const& root, OStream* sout) = 0;
 
   /** \brief A simple abstract factory.
    */
@@ -62,14 +62,14 @@ public:
      * \throw std::exception if something goes wrong (e.g. invalid settings)
      */
     virtual StreamWriter* newStreamWriter() const = 0;
-  };  // Factory
-};  // StreamWriter
+  }; // Factory
+};   // StreamWriter
 
 /** \brief Write into stringstream, then return string, for convenience.
  * A StreamWriter will be created from the factory, used, and then deleted.
  */
-JSONCPP_STRING JSON_API writeString(StreamWriter::Factory const& factory, Value const& root);
-
+String JSON_API writeString(StreamWriter::Factory const& factory,
+                            Value const& root);
 
 /** \brief Build a StreamWriter implementation.
 
@@ -93,7 +93,8 @@ public:
   /** Configuration of this builder.
     Available settings (case-sensitive):
     - "commentStyle": "None" or "All"
-    - "indentation":  "<anything>"
+    - "indentation":  "<anything>".
+      - Setting this to an empty string also omits newline characters.
     - "enableYAMLCompatibility": false or true
       - slightly change the whitespace around colons
     - "dropNullPlaceholders": false or true
@@ -103,8 +104,12 @@ public:
         browser can handle the output just fine.
     - "useSpecialFloats": false or true
       - If true, outputs non-finite floating point values in the following way:
-        NaN values as "NaN", positive infinity as "Infinity", and negative infinity
-        as "-Infinity".
+        NaN values as "NaN", positive infinity as "Infinity", and negative
+    infinity as "-Infinity".
+    - "precision": int
+      - Number of precision digits for formatting of real values.
+    - "precisionType": "significant"(default) or "decimal"
+      - Type of precision for formatting of real values.
 
     You can examine 'settings_` yourself
     to see the defaults. You can also write and read them just like any
@@ -114,12 +119,12 @@ public:
   Json::Value settings_;
 
   StreamWriterBuilder();
-  ~StreamWriterBuilder() JSONCPP_OVERRIDE;
+  ~StreamWriterBuilder() override;
 
   /**
    * \throw std::exception if something goes wrong (e.g. invalid settings)
    */
-  StreamWriter* newStreamWriter() const JSONCPP_OVERRIDE;
+  StreamWriter* newStreamWriter() const override;
 
   /** \return true if 'settings' are legal and consistent;
    *   otherwise, indicate bad settings via 'invalid'.
@@ -127,7 +132,7 @@ public:
   bool validate(Json::Value* invalid) const;
   /** A simple way to update a specific setting.
    */
-  Value& operator[](JSONCPP_STRING key);
+  Value& operator[](const String& key);
 
   /** Called by ctor, but you can use this to reset settings_.
    * \pre 'settings' != NULL (but Json::null is fine)
@@ -144,7 +149,7 @@ class JSONCPP_DEPRECATED("Use StreamWriter instead") JSON_API Writer {
 public:
   virtual ~Writer();
 
-  virtual JSONCPP_STRING write(const Value& root) = 0;
+  virtual String write(const Value& root) = 0;
 };
 
 /** \brief Outputs a Value in <a HREF="http://www.json.org">JSON</a> format
@@ -152,18 +157,19 @@ public:
  *
  * The JSON document is written in a single line. It is not intended for 'human'
  *consumption,
- * but may be usefull to support feature such as RPC where bandwith is limited.
+ * but may be useful to support feature such as RPC where bandwidth is limited.
  * \sa Reader, Value
  * \deprecated Use StreamWriterBuilder.
  */
 #if defined(_MSC_VER)
 #pragma warning(push)
-#pragma warning(disable:4996) // Deriving from deprecated class
+#pragma warning(disable : 4996) // Deriving from deprecated class
 #endif
-class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API FastWriter : public Writer {
+class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API FastWriter
+    : public Writer {
 public:
   FastWriter();
-  ~FastWriter() JSONCPP_OVERRIDE {}
+  ~FastWriter() override = default;
 
   void enableYAMLCompatibility();
 
@@ -177,15 +183,15 @@ public:
   void omitEndingLineFeed();
 
 public: // overridden from Writer
-  JSONCPP_STRING write(const Value& root) JSONCPP_OVERRIDE;
+  String write(const Value& root) override;
 
 private:
   void writeValue(const Value& value);
 
-  JSONCPP_STRING document_;
-  bool yamlCompatibilityEnabled_;
-  bool dropNullPlaceholders_;
-  bool omitEndingLineFeed_;
+  String document_;
+  bool yamlCompatibilityEnabled_{false};
+  bool dropNullPlaceholders_{false};
+  bool omitEndingLineFeed_{false};
 };
 #if defined(_MSC_VER)
 #pragma warning(pop)
@@ -217,42 +223,43 @@ private:
  */
 #if defined(_MSC_VER)
 #pragma warning(push)
-#pragma warning(disable:4996) // Deriving from deprecated class
+#pragma warning(disable : 4996) // Deriving from deprecated class
 #endif
-class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API StyledWriter : public Writer {
+class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API
+    StyledWriter : public Writer {
 public:
   StyledWriter();
-  ~StyledWriter() JSONCPP_OVERRIDE {}
+  ~StyledWriter() override = default;
 
 public: // overridden from Writer
   /** \brief Serialize a Value in <a HREF="http://www.json.org">JSON</a> format.
    * \param root Value to serialize.
    * \return String containing the JSON document that represents the root value.
    */
-  JSONCPP_STRING write(const Value& root) JSONCPP_OVERRIDE;
+  String write(const Value& root) override;
 
 private:
   void writeValue(const Value& value);
   void writeArrayValue(const Value& value);
   bool isMultilineArray(const Value& value);
-  void pushValue(const JSONCPP_STRING& value);
+  void pushValue(const String& value);
   void writeIndent();
-  void writeWithIndent(const JSONCPP_STRING& value);
+  void writeWithIndent(const String& value);
   void indent();
   void unindent();
   void writeCommentBeforeValue(const Value& root);
   void writeCommentAfterValueOnSameLine(const Value& root);
-  bool hasCommentForValue(const Value& value);
-  static JSONCPP_STRING normalizeEOL(const JSONCPP_STRING& text);
+  static bool hasCommentForValue(const Value& value);
+  static String normalizeEOL(const String& text);
 
-  typedef std::vector<JSONCPP_STRING> ChildValues;
+  typedef std::vector<String> ChildValues;
 
   ChildValues childValues_;
-  JSONCPP_STRING document_;
-  JSONCPP_STRING indentString_;
-  unsigned int rightMargin_;
-  unsigned int indentSize_;
-  bool addChildValues_;
+  String document_;
+  String indentString_;
+  unsigned int rightMargin_{74};
+  unsigned int indentSize_{3};
+  bool addChildValues_{false};
 };
 #if defined(_MSC_VER)
 #pragma warning(pop)
@@ -285,15 +292,16 @@ private:
  */
 #if defined(_MSC_VER)
 #pragma warning(push)
-#pragma warning(disable:4996) // Deriving from deprecated class
+#pragma warning(disable : 4996) // Deriving from deprecated class
 #endif
-class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API StyledStreamWriter {
+class JSONCPP_DEPRECATED("Use StreamWriterBuilder instead") JSON_API
+    StyledStreamWriter {
 public:
-/**
- * \param indentation Each level will be indented by this amount extra.
- */
-  StyledStreamWriter(JSONCPP_STRING indentation = "\t");
-  ~StyledStreamWriter() {}
+  /**
+   * \param indentation Each level will be indented by this amount extra.
+   */
+  StyledStreamWriter(String indentation = "\t");
+  ~StyledStreamWriter() = default;
 
 public:
   /** \brief Serialize a Value in <a HREF="http://www.json.org">JSON</a> format.
@@ -302,29 +310,29 @@ public:
    * \note There is no point in deriving from Writer, since write() should not
    * return a value.
    */
-  void write(JSONCPP_OSTREAM& out, const Value& root);
+  void write(OStream& out, const Value& root);
 
 private:
   void writeValue(const Value& value);
   void writeArrayValue(const Value& value);
   bool isMultilineArray(const Value& value);
-  void pushValue(const JSONCPP_STRING& value);
+  void pushValue(const String& value);
   void writeIndent();
-  void writeWithIndent(const JSONCPP_STRING& value);
+  void writeWithIndent(const String& value);
   void indent();
   void unindent();
   void writeCommentBeforeValue(const Value& root);
   void writeCommentAfterValueOnSameLine(const Value& root);
-  bool hasCommentForValue(const Value& value);
-  static JSONCPP_STRING normalizeEOL(const JSONCPP_STRING& text);
+  static bool hasCommentForValue(const Value& value);
+  static String normalizeEOL(const String& text);
 
-  typedef std::vector<JSONCPP_STRING> ChildValues;
+  typedef std::vector<String> ChildValues;
 
   ChildValues childValues_;
-  JSONCPP_OSTREAM* document_;
-  JSONCPP_STRING indentString_;
-  unsigned int rightMargin_;
-  JSONCPP_STRING indentation_;
+  OStream* document_;
+  String indentString_;
+  unsigned int rightMargin_{74};
+  String indentation_;
   bool addChildValues_ : 1;
   bool indented_ : 1;
 };
@@ -333,18 +341,21 @@ private:
 #endif
 
 #if defined(JSON_HAS_INT64)
-JSONCPP_STRING JSON_API valueToString(Int value);
-JSONCPP_STRING JSON_API valueToString(UInt value);
+String JSON_API valueToString(Int value);
+String JSON_API valueToString(UInt value);
 #endif // if defined(JSON_HAS_INT64)
-JSONCPP_STRING JSON_API valueToString(LargestInt value);
-JSONCPP_STRING JSON_API valueToString(LargestUInt value);
-JSONCPP_STRING JSON_API valueToString(double value);
-JSONCPP_STRING JSON_API valueToString(bool value);
-JSONCPP_STRING JSON_API valueToQuotedString(const char* value);
+String JSON_API valueToString(LargestInt value);
+String JSON_API valueToString(LargestUInt value);
+String JSON_API
+valueToString(double value,
+              unsigned int precision = Value::defaultRealPrecision,
+              PrecisionType precisionType = PrecisionType::significantDigits);
+String JSON_API valueToString(bool value);
+String JSON_API valueToQuotedString(const char* value);
 
 /// \brief Output using the StyledStreamWriter.
 /// \see Json::operator>>()
-JSON_API JSONCPP_OSTREAM& operator<<(JSONCPP_OSTREAM&, const Value& root);
+JSON_API OStream& operator<<(OStream&, const Value& root);
 
 } // namespace Json
 
diff --git a/meson.build b/meson.build
index 8daab9c..106e17f 100644
--- a/meson.build
+++ b/meson.build
@@ -1,9 +1,10 @@
 project(
   'jsoncpp',
   'cpp',
-  version : '1.8.4',
+  version : '1.9.0',
   default_options : [
     'buildtype=release',
+    'cpp_std=c++11',
     'warning_level=1'],
   license : 'Public Domain',
   meson_version : '>= 0.41.1')
@@ -45,6 +46,14 @@ install_headers(
   jsoncpp_headers,
   subdir : 'json')
 
+if get_option('default_library') == 'shared' and meson.get_compiler('cpp').get_id() == 'msvc'
+  dll_export_flag = '-DJSON_DLL_BUILD'
+  dll_import_flag = '-DJSON_DLL'
+else
+  dll_export_flag = []
+  dll_import_flag = []
+endif
+
 jsoncpp_lib = library(
   'jsoncpp',
   [ jsoncpp_gen_sources,
@@ -53,9 +62,10 @@ jsoncpp_lib = library(
     'src/lib_json/json_reader.cpp',
     'src/lib_json/json_value.cpp',
     'src/lib_json/json_writer.cpp'],
-  soversion : 20,
+  soversion : 21,
   install : true,
-  include_directories : jsoncpp_include_directories)
+  include_directories : jsoncpp_include_directories,
+  cpp_args: dll_export_flag)
 
 import('pkgconfig').generate(
   libraries : jsoncpp_lib,
@@ -81,7 +91,8 @@ jsoncpp_test = executable(
     'src/test_lib_json/main.cpp'],
   include_directories : jsoncpp_include_directories,
   link_with : jsoncpp_lib,
-  install : false)
+  install : false,
+  cpp_args: dll_import_flag)
 test(
   'unittest_jsoncpp_test',
   jsoncpp_test)
@@ -91,7 +102,8 @@ jsontestrunner = executable(
   'src/jsontestrunner/main.cpp',
   include_directories : jsoncpp_include_directories,
   link_with : jsoncpp_lib,
-  install : false)
+  install : false,
+  cpp_args: dll_import_flag)
 test(
   'unittest_jsontestrunner',
   python,
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index ca8ac15..0f82a74 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -1,5 +1,5 @@
-ADD_SUBDIRECTORY(lib_json)
-IF(JSONCPP_WITH_TESTS)
-    ADD_SUBDIRECTORY(jsontestrunner)
-    ADD_SUBDIRECTORY(test_lib_json)
-ENDIF()
+add_subdirectory(lib_json)
+if(JSONCPP_WITH_TESTS)
+    add_subdirectory(jsontestrunner)
+    add_subdirectory(test_lib_json)
+endif()
diff --git a/src/jsontestrunner/CMakeLists.txt b/src/jsontestrunner/CMakeLists.txt
index 20d01e6..4ca0909 100644
--- a/src/jsontestrunner/CMakeLists.txt
+++ b/src/jsontestrunner/CMakeLists.txt
@@ -1,25 +1,36 @@
-FIND_PACKAGE(PythonInterp 2.6)
+find_package(PythonInterp 2.6)
 
-ADD_EXECUTABLE(jsontestrunner_exe
+add_executable(jsontestrunner_exe
                main.cpp
                )
 
-IF(BUILD_SHARED_LIBS)
-    ADD_DEFINITIONS( -DJSON_DLL )
-    TARGET_LINK_LIBRARIES(jsontestrunner_exe jsoncpp_lib)
-ELSE(BUILD_SHARED_LIBS)
-    TARGET_LINK_LIBRARIES(jsontestrunner_exe jsoncpp_lib_static)
-ENDIF()
+if(BUILD_SHARED_LIBS)
+    add_definitions( -DJSON_DLL )
+endif()
+target_link_libraries(jsontestrunner_exe jsoncpp_lib)
 
-SET_TARGET_PROPERTIES(jsontestrunner_exe PROPERTIES OUTPUT_NAME jsontestrunner_exe)
+set_target_properties(jsontestrunner_exe PROPERTIES OUTPUT_NAME jsontestrunner_exe)
 
-IF(PYTHONINTERP_FOUND)
+if(PYTHONINTERP_FOUND)
     # Run end to end parser/writer tests
-    SET(TEST_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../test)
-    SET(RUNJSONTESTS_PATH ${TEST_DIR}/runjsontests.py)
-    ADD_CUSTOM_TARGET(jsoncpp_readerwriter_tests
+    set(TEST_DIR ${CMAKE_CURRENT_SOURCE_DIR}/../../test)
+    set(RUNJSONTESTS_PATH ${TEST_DIR}/runjsontests.py)
+
+    # Run unit tests in post-build
+    # (default cmake workflow hides away the test result into a file, resulting in poor dev workflow?!?)
+    add_custom_target(jsoncpp_readerwriter_tests
                       "${PYTHON_EXECUTABLE}" -B "${RUNJSONTESTS_PATH}" $<TARGET_FILE:jsontestrunner_exe> "${TEST_DIR}/data"
                       DEPENDS jsontestrunner_exe jsoncpp_test
                       )
-    ADD_CUSTOM_TARGET(jsoncpp_check DEPENDS jsoncpp_readerwriter_tests)
-ENDIF()
+    add_custom_target(jsoncpp_check DEPENDS jsoncpp_readerwriter_tests)
+
+    ## Create tests for dashboard submission, allows easy review of CI results https://my.cdash.org/index.php?project=jsoncpp
+    add_test(NAME jsoncpp_readerwriter
+             COMMAND "${PYTHON_EXECUTABLE}" -B "${RUNJSONTESTS_PATH}" $<TARGET_FILE:jsontestrunner_exe> "${TEST_DIR}/data"
+             WORKING_DIRECTORY "${TEST_DIR}/data"
+    )
+    add_test(NAME jsoncpp_readerwriter_json_checker
+             COMMAND "${PYTHON_EXECUTABLE}" -B "${RUNJSONTESTS_PATH}" --with-json-checker  $<TARGET_FILE:jsontestrunner_exe> "${TEST_DIR}/data"
+             WORKING_DIRECTORY "${TEST_DIR}/data"
+    )
+endif()
diff --git a/src/jsontestrunner/main.cpp b/src/jsontestrunner/main.cpp
index 531f541..d2d41aa 100644
--- a/src/jsontestrunner/main.cpp
+++ b/src/jsontestrunner/main.cpp
@@ -13,40 +13,35 @@
 /* This executable is used for testing parser/writer using real JSON files.
  */
 
-#include <json/json.h>
 #include <algorithm> // sort
+#include <cstdio>
+#include <json/json.h>
 #include <sstream>
-#include <stdio.h>
 
-struct Options
-{
-  JSONCPP_STRING path;
+struct Options {
+  Json::String path;
   Json::Features features;
   bool parseOnly;
-  typedef JSONCPP_STRING (*writeFuncType)(Json::Value const&);
+  using writeFuncType = Json::String (*)(Json::Value const&);
   writeFuncType write;
 };
 
-static JSONCPP_STRING normalizeFloatingPointStr(double value) {
+static Json::String normalizeFloatingPointStr(double value) {
   char buffer[32];
-#if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__)
-  sprintf_s(buffer, sizeof(buffer), "%.16g", value);
-#else
-  snprintf(buffer, sizeof(buffer), "%.16g", value);
-#endif
+  jsoncpp_snprintf(buffer, sizeof(buffer), "%.16g", value);
   buffer[sizeof(buffer) - 1] = 0;
-  JSONCPP_STRING s(buffer);
-  JSONCPP_STRING::size_type index = s.find_last_of("eE");
-  if (index != JSONCPP_STRING::npos) {
-    JSONCPP_STRING::size_type hasSign =
+  Json::String s(buffer);
+  Json::String::size_type index = s.find_last_of("eE");
+  if (index != Json::String::npos) {
+    Json::String::size_type hasSign =
         (s[index + 1] == '+' || s[index + 1] == '-') ? 1 : 0;
-    JSONCPP_STRING::size_type exponentStartIndex = index + 1 + hasSign;
-    JSONCPP_STRING normalized = s.substr(0, exponentStartIndex);
-    JSONCPP_STRING::size_type indexDigit =
+    Json::String::size_type exponentStartIndex = index + 1 + hasSign;
+    Json::String normalized = s.substr(0, exponentStartIndex);
+    Json::String::size_type indexDigit =
         s.find_first_not_of('0', exponentStartIndex);
-    JSONCPP_STRING exponent = "0";
-    if (indexDigit !=
-        JSONCPP_STRING::npos) // There is an exponent different from 0
+    Json::String exponent = "0";
+    if (indexDigit != Json::String::npos) // There is an exponent different
+                                          // from 0
     {
       exponent = s.substr(indexDigit);
     }
@@ -55,17 +50,17 @@ static JSONCPP_STRING normalizeFloatingPointStr(double value) {
   return s;
 }
 
-static JSONCPP_STRING readInputTestFile(const char* path) {
+static Json::String readInputTestFile(const char* path) {
   FILE* file = fopen(path, "rb");
   if (!file)
-    return JSONCPP_STRING("");
+    return "";
   fseek(file, 0, SEEK_END);
   long const size = ftell(file);
-  unsigned long const usize = static_cast<unsigned long>(size);
+  size_t const usize = static_cast<unsigned long>(size);
   fseek(file, 0, SEEK_SET);
-  JSONCPP_STRING text;
   char* buffer = new char[size + 1];
   buffer[size] = 0;
+  Json::String text;
   if (fread(buffer, 1, usize, file) == usize)
     text = buffer;
   fclose(file);
@@ -74,7 +69,7 @@ static JSONCPP_STRING readInputTestFile(const char* path) {
 }
 
 static void
-printValueTree(FILE* fout, Json::Value& value, const JSONCPP_STRING& path = ".") {
+printValueTree(FILE* fout, Json::Value& value, const Json::String& path = ".") {
   if (value.hasComment(Json::commentBefore)) {
     fprintf(fout, "%s\n", value.getComment(Json::commentBefore).c_str());
   }
@@ -83,21 +78,15 @@ printValueTree(FILE* fout, Json::Value& value, const JSONCPP_STRING& path = ".")
     fprintf(fout, "%s=null\n", path.c_str());
     break;
   case Json::intValue:
-    fprintf(fout,
-            "%s=%s\n",
-            path.c_str(),
+    fprintf(fout, "%s=%s\n", path.c_str(),
             Json::valueToString(value.asLargestInt()).c_str());
     break;
   case Json::uintValue:
-    fprintf(fout,
-            "%s=%s\n",
-            path.c_str(),
+    fprintf(fout, "%s=%s\n", path.c_str(),
             Json::valueToString(value.asLargestUInt()).c_str());
     break;
   case Json::realValue:
-    fprintf(fout,
-            "%s=%s\n",
-            path.c_str(),
+    fprintf(fout, "%s=%s\n", path.c_str(),
             normalizeFloatingPointStr(value.asDouble()).c_str());
     break;
   case Json::stringValue:
@@ -111,11 +100,7 @@ printValueTree(FILE* fout, Json::Value& value, const JSONCPP_STRING& path = ".")
     Json::ArrayIndex size = value.size();
     for (Json::ArrayIndex index = 0; index < size; ++index) {
       static char buffer[16];
-#if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__)
-      sprintf_s(buffer, sizeof(buffer), "[%d]", index);
-#else
-      snprintf(buffer, sizeof(buffer), "[%d]", index);
-#endif
+      jsoncpp_snprintf(buffer, sizeof(buffer), "[%u]", index);
       printValueTree(fout, value[index], path + buffer);
     }
   } break;
@@ -123,11 +108,8 @@ printValueTree(FILE* fout, Json::Value& value, const JSONCPP_STRING& path = ".")
     fprintf(fout, "%s={}\n", path.c_str());
     Json::Value::Members members(value.getMemberNames());
     std::sort(members.begin(), members.end());
-    JSONCPP_STRING suffix = *(path.end() - 1) == '.' ? "" : ".";
-    for (Json::Value::Members::iterator it = members.begin();
-         it != members.end();
-         ++it) {
-      const JSONCPP_STRING name = *it;
+    Json::String suffix = *(path.end() - 1) == '.' ? "" : ".";
+    for (auto name : members) {
       printValueTree(fout, value[name], path + suffix + name);
     }
   } break;
@@ -140,18 +122,17 @@ printValueTree(FILE* fout, Json::Value& value, const JSONCPP_STRING& path = ".")
   }
 }
 
-static int parseAndSaveValueTree(const JSONCPP_STRING& input,
-                                 const JSONCPP_STRING& actual,
-                                 const JSONCPP_STRING& kind,
+static int parseAndSaveValueTree(const Json::String& input,
+                                 const Json::String& actual,
+                                 const Json::String& kind,
                                  const Json::Features& features,
                                  bool parseOnly,
-                                 Json::Value* root)
-{
+                                 Json::Value* root) {
   Json::Reader reader(features);
-  bool parsingSuccessful = reader.parse(input.data(), input.data() + input.size(), *root);
+  bool parsingSuccessful =
+      reader.parse(input.data(), input.data() + input.size(), *root);
   if (!parsingSuccessful) {
-    printf("Failed to parse %s file: \n%s\n",
-           kind.c_str(),
+    printf("Failed to parse %s file: \n%s\n", kind.c_str(),
            reader.getFormattedErrorMessages().c_str());
     return 1;
   }
@@ -166,37 +147,29 @@ static int parseAndSaveValueTree(const JSONCPP_STRING& input,
   }
   return 0;
 }
-// static JSONCPP_STRING useFastWriter(Json::Value const& root) {
+// static Json::String useFastWriter(Json::Value const& root) {
 //   Json::FastWriter writer;
 //   writer.enableYAMLCompatibility();
 //   return writer.write(root);
 // }
-static JSONCPP_STRING useStyledWriter(
-    Json::Value const& root)
-{
+static Json::String useStyledWriter(Json::Value const& root) {
   Json::StyledWriter writer;
   return writer.write(root);
 }
-static JSONCPP_STRING useStyledStreamWriter(
-    Json::Value const& root)
-{
+static Json::String useStyledStreamWriter(Json::Value const& root) {
   Json::StyledStreamWriter writer;
-  JSONCPP_OSTRINGSTREAM sout;
+  Json::OStringStream sout;
   writer.write(sout, root);
   return sout.str();
 }
-static JSONCPP_STRING useBuiltStyledStreamWriter(
-    Json::Value const& root)
-{
+static Json::String useBuiltStyledStreamWriter(Json::Value const& root) {
   Json::StreamWriterBuilder builder;
   return Json::writeString(builder, root);
 }
-static int rewriteValueTree(
-    const JSONCPP_STRING& rewritePath,
-    const Json::Value& root,
-    Options::writeFuncType write,
-    JSONCPP_STRING* rewrite)
-{
+static int rewriteValueTree(const Json::String& rewritePath,
+                            const Json::Value& root,
+                            Options::writeFuncType write,
+                            Json::String* rewrite) {
   *rewrite = write(root);
   FILE* fout = fopen(rewritePath.c_str(), "wt");
   if (!fout) {
@@ -208,13 +181,13 @@ static int rewriteValueTree(
   return 0;
 }
 
-static JSONCPP_STRING removeSuffix(const JSONCPP_STRING& path,
-                                const JSONCPP_STRING& extension) {
+static Json::String removeSuffix(const Json::String& path,
+                                 const Json::String& extension) {
   if (extension.length() >= path.length())
-    return JSONCPP_STRING("");
-  JSONCPP_STRING suffix = path.substr(path.length() - extension.length());
+    return Json::String("");
+  Json::String suffix = path.substr(path.length() - extension.length());
   if (suffix != extension)
-    return JSONCPP_STRING("");
+    return Json::String("");
   return path.substr(0, path.length() - extension.length());
 }
 
@@ -232,27 +205,25 @@ static int printUsage(const char* argv[]) {
   return 3;
 }
 
-static int parseCommandLine(
-    int argc, const char* argv[], Options* opts)
-{
+static int parseCommandLine(int argc, const char* argv[], Options* opts) {
   opts->parseOnly = false;
   opts->write = &useStyledWriter;
   if (argc < 2) {
     return printUsage(argv);
   }
   int index = 1;
-  if (JSONCPP_STRING(argv[index]) == "--json-checker") {
+  if (Json::String(argv[index]) == "--json-checker") {
     opts->features = Json::Features::strictMode();
     opts->parseOnly = true;
     ++index;
   }
-  if (JSONCPP_STRING(argv[index]) == "--json-config") {
+  if (Json::String(argv[index]) == "--json-config") {
     printConfig();
     return 3;
   }
-  if (JSONCPP_STRING(argv[index]) == "--json-writer") {
+  if (Json::String(argv[index]) == "--json-writer") {
     ++index;
-    JSONCPP_STRING const writerName(argv[index++]);
+    Json::String const writerName(argv[index++]);
     if (writerName == "StyledWriter") {
       opts->write = &useStyledWriter;
     } else if (writerName == "StyledStreamWriter") {
@@ -270,43 +241,40 @@ static int parseCommandLine(
   opts->path = argv[index];
   return 0;
 }
-static int runTest(Options const& opts)
-{
+static int runTest(Options const& opts) {
   int exitCode = 0;
 
-  JSONCPP_STRING input = readInputTestFile(opts.path.c_str());
+  Json::String input = readInputTestFile(opts.path.c_str());
   if (input.empty()) {
     printf("Failed to read input or empty input: %s\n", opts.path.c_str());
     return 3;
   }
 
-  JSONCPP_STRING basePath = removeSuffix(opts.path, ".json");
+  Json::String basePath = removeSuffix(opts.path, ".json");
   if (!opts.parseOnly && basePath.empty()) {
     printf("Bad input path. Path does not end with '.expected':\n%s\n",
-            opts.path.c_str());
+           opts.path.c_str());
     return 3;
   }
 
-  JSONCPP_STRING const actualPath = basePath + ".actual";
-  JSONCPP_STRING const rewritePath = basePath + ".rewrite";
-  JSONCPP_STRING const rewriteActualPath = basePath + ".actual-rewrite";
+  Json::String const actualPath = basePath + ".actual";
+  Json::String const rewritePath = basePath + ".rewrite";
+  Json::String const rewriteActualPath = basePath + ".actual-rewrite";
 
   Json::Value root;
-  exitCode = parseAndSaveValueTree(
-      input, actualPath, "input",
-      opts.features, opts.parseOnly, &root);
+  exitCode = parseAndSaveValueTree(input, actualPath, "input", opts.features,
+                                   opts.parseOnly, &root);
   if (exitCode || opts.parseOnly) {
     return exitCode;
   }
-  JSONCPP_STRING rewrite;
+  Json::String rewrite;
   exitCode = rewriteValueTree(rewritePath, root, opts.write, &rewrite);
   if (exitCode) {
     return exitCode;
   }
   Json::Value rewriteRoot;
-  exitCode = parseAndSaveValueTree(
-      rewrite, rewriteActualPath, "rewrite",
-      opts.features, opts.parseOnly, &rewriteRoot);
+  exitCode = parseAndSaveValueTree(rewrite, rewriteActualPath, "rewrite",
+                                   opts.features, opts.parseOnly, &rewriteRoot);
   if (exitCode) {
     return exitCode;
   }
@@ -315,14 +283,13 @@ static int runTest(Options const& opts)
 int main(int argc, const char* argv[]) {
   Options opts;
   try {
-  int exitCode = parseCommandLine(argc, argv, &opts);
-  if (exitCode != 0) {
-    printf("Failed to parse command-line.");
-    return exitCode;
-  }
+    int exitCode = parseCommandLine(argc, argv, &opts);
+    if (exitCode != 0) {
+      printf("Failed to parse command-line.");
+      return exitCode;
+    }
     return runTest(opts);
-  }
-  catch (const std::exception& e) {
+  } catch (const std::exception& e) {
     printf("Unhandled exception:\n%s\n", e.what());
     return 1;
   }
diff --git a/src/lib_json/CMakeLists.txt b/src/lib_json/CMakeLists.txt
index 9730e9a..fc4e7a0 100644
--- a/src/lib_json/CMakeLists.txt
+++ b/src/lib_json/CMakeLists.txt
@@ -1,45 +1,45 @@
-IF( CMAKE_COMPILER_IS_GNUCXX )
+if( CMAKE_COMPILER_IS_GNUCXX )
     #Get compiler version.
-    EXECUTE_PROCESS( COMMAND ${CMAKE_CXX_COMPILER} -dumpversion
+    execute_process( COMMAND ${CMAKE_CXX_COMPILER} -dumpversion
                      OUTPUT_VARIABLE GNUCXX_VERSION )
 
     #-Werror=* was introduced -after- GCC 4.1.2
-    IF( GNUCXX_VERSION VERSION_GREATER 4.1.2 )
-        SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror=strict-aliasing")
-    ENDIF()
-ENDIF( CMAKE_COMPILER_IS_GNUCXX )
+    if( GNUCXX_VERSION VERSION_GREATER 4.1.2 )
+        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Werror=strict-aliasing")
+    endif()
+endif( CMAKE_COMPILER_IS_GNUCXX )
 
-INCLUDE(CheckIncludeFileCXX)
-INCLUDE(CheckTypeSize)
-INCLUDE(CheckStructHasMember)
-INCLUDE(CheckCXXSymbolExists)
+include(CheckIncludeFileCXX)
+include(CheckTypeSize)
+include(CheckStructHasMember)
+include(CheckCXXSymbolExists)
 
 check_include_file_cxx(clocale HAVE_CLOCALE)
 check_cxx_symbol_exists(localeconv clocale HAVE_LOCALECONV)
 
-IF(CMAKE_VERSION VERSION_LESS 3.0.0)
+if(CMAKE_VERSION VERSION_LESS 3.0.0)
     # The "LANGUAGE CXX" parameter is not supported in CMake versions below 3,
     # so the C compiler and header has to be used.
     check_include_file(locale.h HAVE_LOCALE_H)
-    SET(CMAKE_EXTRA_INCLUDE_FILES locale.h)
+    set(CMAKE_EXTRA_INCLUDE_FILES locale.h)
     check_type_size("struct lconv" LCONV_SIZE)
-    UNSET(CMAKE_EXTRA_INCLUDE_FILES)
+    unset(CMAKE_EXTRA_INCLUDE_FILES)
     check_struct_has_member("struct lconv" decimal_point locale.h HAVE_DECIMAL_POINT)
-ELSE()
-    SET(CMAKE_EXTRA_INCLUDE_FILES clocale)
+else()
+    set(CMAKE_EXTRA_INCLUDE_FILES clocale)
     check_type_size(lconv LCONV_SIZE LANGUAGE CXX)
-    UNSET(CMAKE_EXTRA_INCLUDE_FILES)
+    unset(CMAKE_EXTRA_INCLUDE_FILES)
     check_struct_has_member(lconv decimal_point clocale HAVE_DECIMAL_POINT LANGUAGE CXX)
-ENDIF()
+endif()
 
-IF(NOT (HAVE_CLOCALE AND HAVE_LCONV_SIZE AND HAVE_DECIMAL_POINT AND HAVE_LOCALECONV))
-    MESSAGE(WARNING "Locale functionality is not supported")
-    ADD_DEFINITIONS(-DJSONCPP_NO_LOCALE_SUPPORT)
-ENDIF()
+if(NOT (HAVE_CLOCALE AND HAVE_LCONV_SIZE AND HAVE_DECIMAL_POINT AND HAVE_LOCALECONV))
+    message(WARNING "Locale functionality is not supported")
+    add_definitions(-DJSONCPP_NO_LOCALE_SUPPORT)
+endif()
 
-SET( JSONCPP_INCLUDE_DIR ../../include )
+set( JSONCPP_INCLUDE_DIR ../../include )
 
-SET( PUBLIC_HEADERS
+set( PUBLIC_HEADERS
     ${JSONCPP_INCLUDE_DIR}/json/config.h
     ${JSONCPP_INCLUDE_DIR}/json/forwards.h
     ${JSONCPP_INCLUDE_DIR}/json/features.h
@@ -50,9 +50,9 @@ SET( PUBLIC_HEADERS
     ${JSONCPP_INCLUDE_DIR}/json/version.h
     )
 
-SOURCE_GROUP( "Public API" FILES ${PUBLIC_HEADERS} )
+source_group( "Public API" FILES ${PUBLIC_HEADERS} )
 
-SET(jsoncpp_sources
+set(jsoncpp_sources
                 json_tool.h
                 json_reader.cpp
                 json_valueiterator.inl
@@ -61,57 +61,85 @@ SET(jsoncpp_sources
                 version.h.in)
 
 # Install instructions for this target
-IF(JSONCPP_WITH_CMAKE_PACKAGE)
-    SET(INSTALL_EXPORT EXPORT jsoncpp)
-ELSE(JSONCPP_WITH_CMAKE_PACKAGE)
-    SET(INSTALL_EXPORT)
-ENDIF()
-
-IF(BUILD_SHARED_LIBS)
-    ADD_DEFINITIONS( -DJSON_DLL_BUILD )
-    ADD_LIBRARY(jsoncpp_lib SHARED ${PUBLIC_HEADERS} ${jsoncpp_sources})
-    SET_TARGET_PROPERTIES( jsoncpp_lib PROPERTIES VERSION ${JSONCPP_VERSION} SOVERSION ${JSONCPP_SOVERSION})
-    SET_TARGET_PROPERTIES( jsoncpp_lib PROPERTIES OUTPUT_NAME jsoncpp
-                           DEBUG_OUTPUT_NAME jsoncpp${DEBUG_LIBNAME_SUFFIX} )
-
-    # Set library's runtime search path on OSX
-    IF(APPLE)
-        SET_TARGET_PROPERTIES( jsoncpp_lib PROPERTIES INSTALL_RPATH "@loader_path/." )
-    ENDIF()
-
-    INSTALL( TARGETS jsoncpp_lib ${INSTALL_EXPORT}
-             RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
-             LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-             ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
-
-    IF(NOT CMAKE_VERSION VERSION_LESS 2.8.11)
-        TARGET_INCLUDE_DIRECTORIES( jsoncpp_lib PUBLIC
-                                   $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-                                   $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/${JSONCPP_INCLUDE_DIR}>)
-    ENDIF()
-
-ENDIF()
-
-IF(BUILD_STATIC_LIBS)
-    ADD_LIBRARY(jsoncpp_lib_static STATIC ${PUBLIC_HEADERS} ${jsoncpp_sources})
-    SET_TARGET_PROPERTIES( jsoncpp_lib_static PROPERTIES VERSION ${JSONCPP_VERSION} SOVERSION ${JSONCPP_SOVERSION})
-    # avoid name clashes on windows as the shared import lib is also named jsoncpp.lib
-    if (NOT DEFINED STATIC_SUFFIX AND BUILD_SHARED_LIBS)
-      set (STATIC_SUFFIX "_static")
-    endif ()
-    set_target_properties (jsoncpp_lib_static PROPERTIES OUTPUT_NAME jsoncpp${STATIC_SUFFIX}
-                                                         DEBUG_OUTPUT_NAME jsoncpp${STATIC_SUFFIX}${DEBUG_LIBNAME_SUFFIX})
-
-    INSTALL( TARGETS jsoncpp_lib_static ${INSTALL_EXPORT}
-             RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
-             LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
-             ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
-
-    IF(NOT CMAKE_VERSION VERSION_LESS 2.8.11)
-        TARGET_INCLUDE_DIRECTORIES( jsoncpp_lib_static PUBLIC
+if(JSONCPP_WITH_CMAKE_PACKAGE)
+    set(INSTALL_EXPORT EXPORT jsoncpp)
+else(JSONCPP_WITH_CMAKE_PACKAGE)
+    set(INSTALL_EXPORT)
+endif()
+
+if(BUILD_SHARED_LIBS)
+    add_definitions( -DJSON_DLL_BUILD )
+endif()
+
+
+add_library(jsoncpp_lib ${PUBLIC_HEADERS} ${jsoncpp_sources})
+set_target_properties( jsoncpp_lib PROPERTIES VERSION ${JSONCPP_VERSION} SOVERSION ${JSONCPP_SOVERSION})
+set_target_properties( jsoncpp_lib PROPERTIES OUTPUT_NAME jsoncpp
+                        DEBUG_OUTPUT_NAME jsoncpp${DEBUG_LIBNAME_SUFFIX} )
+set_target_properties( jsoncpp_lib PROPERTIES POSITION_INDEPENDENT_CODE ON)
+
+# Set library's runtime search path on OSX
+if(APPLE)
+    set_target_properties( jsoncpp_lib PROPERTIES INSTALL_RPATH "@loader_path/." )
+endif()
+
+# Specify compiler features required when compiling a given target.
+# See https://cmake.org/cmake/help/v3.1/prop_gbl/CMAKE_CXX_KNOWN_FEATURES.html#prop_gbl:CMAKE_CXX_KNOWN_FEATURES
+# for complete list of features available
+target_compile_features(jsoncpp_lib PUBLIC
+        cxx_std_11 # Compiler mode is aware of C++ 11.
+        #MSVC 1900 cxx_alignas # Alignment control alignas, as defined in N2341.
+        #MSVC 1900 cxx_alignof # Alignment control alignof, as defined in N2341.
+        #MSVC 1900 cxx_attributes # Generic attributes, as defined in N2761.
+        cxx_auto_type # Automatic type deduction, as defined in N1984.
+        #MSVC 1900 cxx_constexpr # Constant expressions, as defined in N2235.
+        cxx_decltype # Decltype, as defined in N2343.
+        cxx_default_function_template_args # Default template arguments for function templates, as defined in DR226
+        cxx_defaulted_functions # Defaulted functions, as defined in N2346.
+        #MSVC 1900 cxx_defaulted_move_initializers # Defaulted move initializers, as defined in N3053.
+        cxx_delegating_constructors # Delegating constructors, as defined in N1986.
+        #MSVC 1900 cxx_deleted_functions # Deleted functions, as defined in N2346.
+        cxx_enum_forward_declarations # Enum forward declarations, as defined in N2764.
+        cxx_explicit_conversions # Explicit conversion operators, as defined in N2437.
+        cxx_extended_friend_declarations # Extended friend declarations, as defined in N1791.
+        cxx_extern_templates # Extern templates, as defined in N1987.
+        cxx_final # Override control final keyword, as defined in N2928, N3206 and N3272.
+        #MSVC 1900 cxx_func_identifier # Predefined __func__ identifier, as defined in N2340.
+        #MSVC 1900 cxx_generalized_initializers # Initializer lists, as defined in N2672.
+        #MSVC 1900 cxx_inheriting_constructors # Inheriting constructors, as defined in N2540.
+        #MSVC 1900 cxx_inline_namespaces # Inline namespaces, as defined in N2535.
+        cxx_lambdas # Lambda functions, as defined in N2927.
+        #MSVC 1900 cxx_local_type_template_args # Local and unnamed types as template arguments, as defined in N2657.
+        cxx_long_long_type # long long type, as defined in N1811.
+        #MSVC 1900 cxx_noexcept # Exception specifications, as defined in N3050.
+        #MSVC 1900 cxx_nonstatic_member_init # Non-static data member initialization, as defined in N2756.
+        cxx_nullptr # Null pointer, as defined in N2431.
+        cxx_override # Override control override keyword, as defined in N2928, N3206 and N3272.
+        cxx_range_for # Range-based for, as defined in N2930.
+        cxx_raw_string_literals # Raw string literals, as defined in N2442.
+        #MSVC 1900 cxx_reference_qualified_functions # Reference qualified functions, as defined in N2439.
+        cxx_right_angle_brackets # Right angle bracket parsing, as defined in N1757.
+        cxx_rvalue_references # R-value references, as defined in N2118.
+        #MSVC 1900 cxx_sizeof_member # Size of non-static data members, as defined in N2253.
+        cxx_static_assert # Static assert, as defined in N1720.
+        cxx_strong_enums # Strongly typed enums, as defined in N2347.
+        #MSVC 1900 cxx_thread_local # Thread-local variables, as defined in N2659.
+        cxx_trailing_return_types # Automatic function return type, as defined in N2541.
+        #MSVC 1900 cxx_unicode_literals # Unicode string literals, as defined in N2442.
+        cxx_uniform_initialization # Uniform initialization, as defined in N2640.
+        #MSVC 1900 cxx_unrestricted_unions # Unrestricted unions, as defined in N2544.
+        #MSVC 1900 cxx_user_literals # User-defined literals, as defined in N2765.
+        cxx_variadic_macros # Variadic macros, as defined in N1653.
+        cxx_variadic_templates # Variadic templates, as defined in N2242.
+)
+
+install( TARGETS jsoncpp_lib ${INSTALL_EXPORT}
+          RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+          LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+          ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
+
+if(NOT CMAKE_VERSION VERSION_LESS 2.8.11)
+    target_include_directories( jsoncpp_lib PUBLIC
                                 $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
-                                $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/${JSONCPP_INCLUDE_DIR}>
-                                )
-    ENDIF()
-
-ENDIF()
+                                $<BUILD_INTERFACE:${CMAKE_CURRENT_LIST_DIR}/${JSONCPP_INCLUDE_DIR}>)
+endif()
diff --git a/src/lib_json/json_reader.cpp b/src/lib_json/json_reader.cpp
index eb30843..05b238a 100644
--- a/src/lib_json/json_reader.cpp
+++ b/src/lib_json/json_reader.cpp
@@ -5,69 +5,63 @@
 // See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
 
 #if !defined(JSON_IS_AMALGAMATION)
+#include "json_tool.h"
 #include <json/assertions.h>
 #include <json/reader.h>
 #include <json/value.h>
-#include "json_tool.h"
 #endif // if !defined(JSON_IS_AMALGAMATION)
-#include <utility>
-#include <cstdio>
 #include <cassert>
 #include <cstring>
 #include <istream>
-#include <sstream>
+#include <limits>
 #include <memory>
 #include <set>
-#include <limits>
+#include <sstream>
+#include <utility>
 
-#if defined(_MSC_VER)
-#if !defined(WINCE) && defined(__STDC_SECURE_LIB__) && _MSC_VER >= 1500 // VC++ 9.0 and above 
-#define snprintf sprintf_s
-#elif _MSC_VER >= 1900 // VC++ 14.0 and above
-#define snprintf std::snprintf
-#else
-#define snprintf _snprintf
-#endif
-#elif defined(__ANDROID__) || defined(__QNXNTO__)
-#define snprintf snprintf
-#elif __cplusplus >= 201103L
-#if !defined(__MINGW32__) && !defined(__CYGWIN__)
-#define snprintf std::snprintf
-#endif
-#endif
+#include <cstdio>
+#if __cplusplus >= 201103L
 
-#if defined(__QNXNTO__)
+#if !defined(sscanf)
 #define sscanf std::sscanf
 #endif
 
-#if defined(_MSC_VER) && _MSC_VER >= 1400 // VC++ 8.0
+#endif //__cplusplus
+
+#if defined(_MSC_VER)
+#if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
+#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
+#endif //_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
+#endif //_MSC_VER
+
+#if defined(_MSC_VER)
 // Disable warning about strdup being deprecated.
 #pragma warning(disable : 4996)
 #endif
 
-// Define JSONCPP_DEPRECATED_STACK_LIMIT as an appropriate integer at compile time to change the stack limit
+// Define JSONCPP_DEPRECATED_STACK_LIMIT as an appropriate integer at compile
+// time to change the stack limit
 #if !defined(JSONCPP_DEPRECATED_STACK_LIMIT)
 #define JSONCPP_DEPRECATED_STACK_LIMIT 1000
 #endif
 
-static size_t const stackLimit_g = JSONCPP_DEPRECATED_STACK_LIMIT; // see readValue()
+static size_t const stackLimit_g =
+    JSONCPP_DEPRECATED_STACK_LIMIT; // see readValue()
 
 namespace Json {
 
 #if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER >= 520)
 typedef std::unique_ptr<CharReader> CharReaderPtr;
 #else
-typedef std::auto_ptr<CharReader>   CharReaderPtr;
+typedef std::auto_ptr<CharReader> CharReaderPtr;
 #endif
 
 // Implementation of class Features
 // ////////////////////////////////
 
-Features::Features()
-    : allowComments_(true), strictRoot_(false),
-      allowDroppedNullPlaceholders_(false), allowNumericKeys_(false) {}
+Features::Features() = default;
 
-Features Features::all() { return Features(); }
+Features Features::all() { return {}; }
 
 Features Features::strictMode() {
   Features features;
@@ -92,33 +86,32 @@ bool Reader::containsNewLine(Reader::Location begin, Reader::Location end) {
 // //////////////////////////////////////////////////////////////////
 
 Reader::Reader()
-    : errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
-      lastValue_(), commentsBefore_(), features_(Features::all()),
-      collectComments_() {}
+    : errors_(), document_(), commentsBefore_(), features_(Features::all()) {}
 
 Reader::Reader(const Features& features)
     : errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
       lastValue_(), commentsBefore_(), features_(features), collectComments_() {
 }
 
-bool
-Reader::parse(const std::string& document, Value& root, bool collectComments) {
+bool Reader::parse(const std::string& document,
+                   Value& root,
+                   bool collectComments) {
   document_.assign(document.begin(), document.end());
   const char* begin = document_.c_str();
   const char* end = begin + document_.length();
   return parse(begin, end, root, collectComments);
 }
 
-bool Reader::parse(std::istream& sin, Value& root, bool collectComments) {
-  // std::istream_iterator<char> begin(sin);
+bool Reader::parse(std::istream& is, Value& root, bool collectComments) {
+  // std::istream_iterator<char> begin(is);
   // std::istream_iterator<char> end;
   // Those would allow streamed input from a file, if parse() were a
   // template function.
 
-  // Since JSONCPP_STRING is reference-counted, this at least does not
+  // Since String is reference-counted, this at least does not
   // create an extra copy.
-  JSONCPP_STRING doc;
-  std::getline(sin, doc, (char)EOF);
+  String doc;
+  std::getline(is, doc, (char)EOF);
   return parse(doc.data(), doc.data() + doc.size(), root, collectComments);
 }
 
@@ -134,8 +127,8 @@ bool Reader::parse(const char* beginDoc,
   end_ = endDoc;
   collectComments_ = collectComments;
   current_ = begin_;
-  lastValueEnd_ = 0;
-  lastValue_ = 0;
+  lastValueEnd_ = nullptr;
+  lastValue_ = nullptr;
   commentsBefore_.clear();
   errors_.clear();
   while (!nodes_.empty())
@@ -165,9 +158,11 @@ bool Reader::parse(const char* beginDoc,
 
 bool Reader::readValue() {
   // readValue() may call itself only if it calls readObject() or ReadArray().
-  // These methods execute nodes_.push() just before and nodes_.pop)() just after calling readValue(). 
-  // parse() executes one nodes_.push(), so > instead of >=.
-  if (nodes_.size() > stackLimit_g) throwRuntimeError("Exceeded stackLimit in readValue().");
+  // These methods execute nodes_.push() just before and nodes_.pop)() just
+  // after calling readValue(). parse() executes one nodes_.push(), so > instead
+  // of >=.
+  if (nodes_.size() > stackLimit_g)
+    throwRuntimeError("Exceeded stackLimit in readValue().");
 
   Token token;
   skipCommentTokens(token);
@@ -193,30 +188,24 @@ bool Reader::readValue() {
   case tokenString:
     successful = decodeString(token);
     break;
-  case tokenTrue:
-    {
+  case tokenTrue: {
     Value v(true);
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
-  case tokenFalse:
-    {
+  } break;
+  case tokenFalse: {
     Value v(false);
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
-  case tokenNull:
-    {
+  } break;
+  case tokenNull: {
     Value v;
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
+  } break;
   case tokenArraySeparator:
   case tokenObjectEnd:
   case tokenArrayEnd:
@@ -369,16 +358,16 @@ bool Reader::readComment() {
   return true;
 }
 
-JSONCPP_STRING Reader::normalizeEOL(Reader::Location begin, Reader::Location end) {
-  JSONCPP_STRING normalized;
+String Reader::normalizeEOL(Reader::Location begin, Reader::Location end) {
+  String normalized;
   normalized.reserve(static_cast<size_t>(end - begin));
   Reader::Location current = begin;
   while (current != end) {
     char c = *current++;
     if (c == '\r') {
       if (current != end && *current == '\n')
-         // convert dos EOL
-         ++current;
+        // convert dos EOL
+        ++current;
       // convert Mac EOL
       normalized += '\n';
     } else {
@@ -388,12 +377,13 @@ JSONCPP_STRING Reader::normalizeEOL(Reader::Location begin, Reader::Location end
   return normalized;
 }
 
-void
-Reader::addComment(Location begin, Location end, CommentPlacement placement) {
+void Reader::addComment(Location begin,
+                        Location end,
+                        CommentPlacement placement) {
   assert(collectComments_);
-  const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
+  const String& normalized = normalizeEOL(begin, end);
   if (placement == commentAfterOnSameLine) {
-    assert(lastValue_ != 0);
+    assert(lastValue_ != nullptr);
     lastValue_->setComment(normalized, placement);
   } else {
     commentsBefore_ += normalized;
@@ -426,7 +416,7 @@ bool Reader::readCppStyleComment() {
 }
 
 void Reader::readNumber() {
-  const char *p = current_;
+  const char* p = current_;
   char c = '0'; // stopgap for already consumed character
   // integral part
   while (c >= '0' && c <= '9')
@@ -459,12 +449,12 @@ bool Reader::readString() {
   return c == '"';
 }
 
-bool Reader::readObject(Token& tokenStart) {
+bool Reader::readObject(Token& token) {
   Token tokenName;
-  JSONCPP_STRING name;
+  String name;
   Value init(objectValue);
   currentValue().swapPayload(init);
-  currentValue().setOffsetStart(tokenStart.start_ - begin_);
+  currentValue().setOffsetStart(token.start_ - begin_);
   while (readToken(tokenName)) {
     bool initialTokenOk = true;
     while (tokenName.type_ == tokenComment && initialTokenOk)
@@ -481,15 +471,15 @@ bool Reader::readObject(Token& tokenStart) {
       Value numberName;
       if (!decodeNumber(tokenName, numberName))
         return recoverFromError(tokenObjectEnd);
-      name = JSONCPP_STRING(numberName.asCString());
+      name = String(numberName.asCString());
     } else {
       break;
     }
 
     Token colon;
     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
-      return addErrorAndRecover(
-          "Missing ':' after object member name", colon, tokenObjectEnd);
+      return addErrorAndRecover("Missing ':' after object member name", colon,
+                                tokenObjectEnd);
     }
     Value& value = currentValue()[name];
     nodes_.push(&value);
@@ -502,8 +492,8 @@ bool Reader::readObject(Token& tokenStart) {
     if (!readToken(comma) ||
         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
          comma.type_ != tokenComment)) {
-      return addErrorAndRecover(
-          "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
+      return addErrorAndRecover("Missing ',' or '}' in object declaration",
+                                comma, tokenObjectEnd);
     }
     bool finalizeTokenOk = true;
     while (comma.type_ == tokenComment && finalizeTokenOk)
@@ -511,14 +501,14 @@ bool Reader::readObject(Token& tokenStart) {
     if (comma.type_ == tokenObjectEnd)
       return true;
   }
-  return addErrorAndRecover(
-      "Missing '}' or object member name", tokenName, tokenObjectEnd);
+  return addErrorAndRecover("Missing '}' or object member name", tokenName,
+                            tokenObjectEnd);
 }
 
-bool Reader::readArray(Token& tokenStart) {
+bool Reader::readArray(Token& token) {
   Value init(arrayValue);
   currentValue().swapPayload(init);
-  currentValue().setOffsetStart(tokenStart.start_ - begin_);
+  currentValue().setOffsetStart(token.start_ - begin_);
   skipSpaces();
   if (current_ != end_ && *current_ == ']') // empty array
   {
@@ -535,19 +525,19 @@ bool Reader::readArray(Token& tokenStart) {
     if (!ok) // error already set
       return recoverFromError(tokenArrayEnd);
 
-    Token token;
+    Token currentToken;
     // Accept Comment after last item in the array.
-    ok = readToken(token);
-    while (token.type_ == tokenComment && ok) {
-      ok = readToken(token);
+    ok = readToken(currentToken);
+    while (currentToken.type_ == tokenComment && ok) {
+      ok = readToken(currentToken);
     }
-    bool badTokenType =
-        (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
+    bool badTokenType = (currentToken.type_ != tokenArraySeparator &&
+                         currentToken.type_ != tokenArrayEnd);
     if (!ok || badTokenType) {
-      return addErrorAndRecover(
-          "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
+      return addErrorAndRecover("Missing ',' or ']' in array declaration",
+                                currentToken, tokenArrayEnd);
     }
-    if (token.type_ == tokenArrayEnd)
+    if (currentToken.type_ == tokenArrayEnd)
       break;
   }
   return true;
@@ -571,7 +561,8 @@ bool Reader::decodeNumber(Token& token, Value& decoded) {
   bool isNegative = *current == '-';
   if (isNegative)
     ++current;
-  // TODO: Help the compiler do the div and mod at compile time or get rid of them.
+  // TODO: Help the compiler do the div and mod at compile time or get rid of
+  // them.
   Value::LargestUInt maxIntegerValue =
       isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
                  : Value::maxLargestUInt;
@@ -581,7 +572,7 @@ bool Reader::decodeNumber(Token& token, Value& decoded) {
     Char c = *current++;
     if (c < '0' || c > '9')
       return decodeDouble(token, decoded);
-    Value::UInt digit(static_cast<Value::UInt>(c - '0'));
+    auto digit(static_cast<Value::UInt>(c - '0'));
     if (value >= threshold) {
       // We've hit or exceeded the max value divided by 10 (rounded down). If
       // a) we've only just touched the limit, b) this is the last digit, and
@@ -617,18 +608,17 @@ bool Reader::decodeDouble(Token& token) {
 
 bool Reader::decodeDouble(Token& token, Value& decoded) {
   double value = 0;
-  JSONCPP_STRING buffer(token.start_, token.end_);
-  JSONCPP_ISTRINGSTREAM is(buffer);
+  String buffer(token.start_, token.end_);
+  IStringStream is(buffer);
   if (!(is >> value))
-    return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
-                        "' is not a number.",
-                    token);
+    return addError(
+        "'" + String(token.start_, token.end_) + "' is not a number.", token);
   decoded = value;
   return true;
 }
 
 bool Reader::decodeString(Token& token) {
-  JSONCPP_STRING decoded_string;
+  String decoded_string;
   if (!decodeString(token, decoded_string))
     return false;
   Value decoded(decoded_string);
@@ -638,7 +628,7 @@ bool Reader::decodeString(Token& token) {
   return true;
 }
 
-bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
+bool Reader::decodeString(Token& token, String& decoded) {
   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
   Location current = token.start_ + 1; // skip '"'
   Location end = token.end_ - 1;       // do not include '"'
@@ -703,10 +693,9 @@ bool Reader::decodeUnicodeCodePoint(Token& token,
     if (end - current < 6)
       return addError(
           "additional six characters expected to parse unicode surrogate pair.",
-          token,
-          current);
-    unsigned int surrogatePair;
+          token, current);
     if (*(current++) == '\\' && *(current++) == 'u') {
+      unsigned int surrogatePair;
       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
       } else
@@ -714,8 +703,7 @@ bool Reader::decodeUnicodeCodePoint(Token& token,
     } else
       return addError("expecting another \\u token to begin the second half of "
                       "a unicode surrogate pair",
-                      token,
-                      current);
+                      token, current);
   }
   return true;
 }
@@ -726,8 +714,7 @@ bool Reader::decodeUnicodeEscapeSequence(Token& token,
                                          unsigned int& ret_unicode) {
   if (end - current < 4)
     return addError(
-        "Bad unicode escape sequence in string: four digits expected.",
-        token,
+        "Bad unicode escape sequence in string: four digits expected.", token,
         current);
   int unicode = 0;
   for (int index = 0; index < 4; ++index) {
@@ -742,15 +729,13 @@ bool Reader::decodeUnicodeEscapeSequence(Token& token,
     else
       return addError(
           "Bad unicode escape sequence in string: hexadecimal digit expected.",
-          token,
-          current);
+          token, current);
   }
   ret_unicode = static_cast<unsigned int>(unicode);
   return true;
 }
 
-bool
-Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
+bool Reader::addError(const String& message, Token& token, Location extra) {
   ErrorInfo info;
   info.token_ = token;
   info.message_ = message;
@@ -772,7 +757,7 @@ bool Reader::recoverFromError(TokenType skipUntilToken) {
   return false;
 }
 
-bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
+bool Reader::addErrorAndRecover(const String& message,
                                 Token& token,
                                 TokenType skipUntilToken) {
   addError(message, token);
@@ -810,25 +795,22 @@ void Reader::getLocationLineAndColumn(Location location,
   ++line;
 }
 
-JSONCPP_STRING Reader::getLocationLineAndColumn(Location location) const {
+String Reader::getLocationLineAndColumn(Location location) const {
   int line, column;
   getLocationLineAndColumn(location, line, column);
   char buffer[18 + 16 + 16 + 1];
-  snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
+  jsoncpp_snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
   return buffer;
 }
 
 // Deprecated. Preserved for backward compatibility
-JSONCPP_STRING Reader::getFormatedErrorMessages() const {
+String Reader::getFormatedErrorMessages() const {
   return getFormattedErrorMessages();
 }
 
-JSONCPP_STRING Reader::getFormattedErrorMessages() const {
-  JSONCPP_STRING formattedMessage;
-  for (Errors::const_iterator itError = errors_.begin();
-       itError != errors_.end();
-       ++itError) {
-    const ErrorInfo& error = *itError;
+String Reader::getFormattedErrorMessages() const {
+  String formattedMessage;
+  for (const auto& error : errors_) {
     formattedMessage +=
         "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
     formattedMessage += "  " + error.message_ + "\n";
@@ -841,10 +823,7 @@ JSONCPP_STRING Reader::getFormattedErrorMessages() const {
 
 std::vector<Reader::StructuredError> Reader::getStructuredErrors() const {
   std::vector<Reader::StructuredError> allErrors;
-  for (Errors::const_iterator itError = errors_.begin();
-       itError != errors_.end();
-       ++itError) {
-    const ErrorInfo& error = *itError;
+  for (const auto& error : errors_) {
     Reader::StructuredError structured;
     structured.offset_start = error.token_.start_ - begin_;
     structured.offset_limit = error.token_.end_ - begin_;
@@ -854,10 +833,9 @@ std::vector<Reader::StructuredError> Reader::getStructuredErrors() const {
   return allErrors;
 }
 
-bool Reader::pushError(const Value& value, const JSONCPP_STRING& message) {
+bool Reader::pushError(const Value& value, const String& message) {
   ptrdiff_t const length = end_ - begin_;
-  if(value.getOffsetStart() > length
-    || value.getOffsetLimit() > length)
+  if (value.getOffsetStart() > length || value.getOffsetLimit() > length)
     return false;
   Token token;
   token.type_ = tokenError;
@@ -866,16 +844,17 @@ bool Reader::pushError(const Value& value, const JSONCPP_STRING& message) {
   ErrorInfo info;
   info.token_ = token;
   info.message_ = message;
-  info.extra_ = 0;
+  info.extra_ = nullptr;
   errors_.push_back(info);
   return true;
 }
 
-bool Reader::pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra) {
+bool Reader::pushError(const Value& value,
+                       const String& message,
+                       const Value& extra) {
   ptrdiff_t const length = end_ - begin_;
-  if(value.getOffsetStart() > length
-    || value.getOffsetLimit() > length
-    || extra.getOffsetLimit() > length)
+  if (value.getOffsetStart() > length || value.getOffsetLimit() > length ||
+      extra.getOffsetLimit() > length)
     return false;
   Token token;
   token.type_ = tokenError;
@@ -889,9 +868,7 @@ bool Reader::pushError(const Value& value, const JSONCPP_STRING& message, const
   return true;
 }
 
-bool Reader::good() const {
-  return !errors_.size();
-}
+bool Reader::good() const { return errors_.empty(); }
 
 // exact copy of Features
 class OurFeatures {
@@ -905,13 +882,13 @@ public:
   bool failIfExtra_;
   bool rejectDupKeys_;
   bool allowSpecialFloats_;
-  int stackLimit_;
-};  // OurFeatures
+  size_t stackLimit_;
+}; // OurFeatures
 
 // exact copy of Implementation of class Features
 // ////////////////////////////////
 
-OurFeatures OurFeatures::all() { return OurFeatures(); }
+OurFeatures OurFeatures::all() { return {}; }
 
 // Implementation of class Reader
 // ////////////////////////////////
@@ -924,7 +901,7 @@ public:
   struct StructuredError {
     ptrdiff_t offset_start;
     ptrdiff_t offset_limit;
-    JSONCPP_STRING message;
+    String message;
   };
 
   OurReader(OurFeatures const& features);
@@ -932,15 +909,15 @@ public:
              const char* endDoc,
              Value& root,
              bool collectComments = true);
-  JSONCPP_STRING getFormattedErrorMessages() const;
+  String getFormattedErrorMessages() const;
   std::vector<StructuredError> getStructuredErrors() const;
-  bool pushError(const Value& value, const JSONCPP_STRING& message);
-  bool pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra);
+  bool pushError(const Value& value, const String& message);
+  bool pushError(const Value& value, const String& message, const Value& extra);
   bool good() const;
 
 private:
-  OurReader(OurReader const&);  // no impl
-  void operator=(OurReader const&);  // no impl
+  OurReader(OurReader const&);      // no impl
+  void operator=(OurReader const&); // no impl
 
   enum TokenType {
     tokenEndOfStream = 0,
@@ -972,7 +949,7 @@ private:
   class ErrorInfo {
   public:
     Token token_;
-    JSONCPP_STRING message_;
+    String message_;
     Location extra_;
   };
 
@@ -993,7 +970,7 @@ private:
   bool decodeNumber(Token& token);
   bool decodeNumber(Token& token, Value& decoded);
   bool decodeString(Token& token);
-  bool decodeString(Token& token, JSONCPP_STRING& decoded);
+  bool decodeString(Token& token, String& decoded);
   bool decodeDouble(Token& token);
   bool decodeDouble(Token& token, Value& decoded);
   bool decodeUnicodeCodePoint(Token& token,
@@ -1004,9 +981,9 @@ private:
                                    Location& current,
                                    Location end,
                                    unsigned int& unicode);
-  bool addError(const JSONCPP_STRING& message, Token& token, Location extra = 0);
+  bool addError(const String& message, Token& token, Location extra = nullptr);
   bool recoverFromError(TokenType skipUntilToken);
-  bool addErrorAndRecover(const JSONCPP_STRING& message,
+  bool addErrorAndRecover(const String& message,
                           Token& token,
                           TokenType skipUntilToken);
   void skipUntilSpace();
@@ -1014,31 +991,32 @@ private:
   Char getNextChar();
   void
   getLocationLineAndColumn(Location location, int& line, int& column) const;
-  JSONCPP_STRING getLocationLineAndColumn(Location location) const;
+  String getLocationLineAndColumn(Location location) const;
   void addComment(Location begin, Location end, CommentPlacement placement);
   void skipCommentTokens(Token& token);
 
-  static JSONCPP_STRING normalizeEOL(Location begin, Location end);
+  static String normalizeEOL(Location begin, Location end);
   static bool containsNewLine(Location begin, Location end);
 
   typedef std::stack<Value*> Nodes;
   Nodes nodes_;
   Errors errors_;
-  JSONCPP_STRING document_;
+  String document_;
   Location begin_;
   Location end_;
   Location current_;
   Location lastValueEnd_;
   Value* lastValue_;
-  JSONCPP_STRING commentsBefore_;
+  String commentsBefore_;
 
   OurFeatures const features_;
   bool collectComments_;
-};  // OurReader
+}; // OurReader
 
 // complete copy of Read impl, for OurReader
 
-bool OurReader::containsNewLine(OurReader::Location begin, OurReader::Location end) {
+bool OurReader::containsNewLine(OurReader::Location begin,
+                                OurReader::Location end) {
   for (; begin < end; ++begin)
     if (*begin == '\n' || *begin == '\r')
       return true;
@@ -1047,14 +1025,13 @@ bool OurReader::containsNewLine(OurReader::Location begin, OurReader::Location e
 
 OurReader::OurReader(OurFeatures const& features)
     : errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
-      lastValue_(), commentsBefore_(),
-      features_(features), collectComments_() {
+      lastValue_(), commentsBefore_(), features_(features), collectComments_() {
 }
 
 bool OurReader::parse(const char* beginDoc,
-                   const char* endDoc,
-                   Value& root,
-                   bool collectComments) {
+                      const char* endDoc,
+                      Value& root,
+                      bool collectComments) {
   if (!features_.allowComments_) {
     collectComments = false;
   }
@@ -1063,8 +1040,8 @@ bool OurReader::parse(const char* beginDoc,
   end_ = endDoc;
   collectComments_ = collectComments;
   current_ = begin_;
-  lastValueEnd_ = 0;
-  lastValue_ = 0;
+  lastValueEnd_ = nullptr;
+  lastValue_ = nullptr;
   commentsBefore_.clear();
   errors_.clear();
   while (!nodes_.empty())
@@ -1075,7 +1052,8 @@ bool OurReader::parse(const char* beginDoc,
   Token token;
   skipCommentTokens(token);
   if (features_.failIfExtra_) {
-    if ((features_.strictRoot_ || token.type_ != tokenError) && token.type_ != tokenEndOfStream) {
+    if ((features_.strictRoot_ || token.type_ != tokenError) &&
+        token.type_ != tokenEndOfStream) {
       addError("Extra non-whitespace after JSON value.", token);
       return false;
     }
@@ -1100,7 +1078,8 @@ bool OurReader::parse(const char* beginDoc,
 
 bool OurReader::readValue() {
   //  To preserve the old behaviour we cast size_t to int.
-  if (static_cast<int>(nodes_.size()) > features_.stackLimit_) throwRuntimeError("Exceeded stackLimit in readValue().");
+  if (nodes_.size() > features_.stackLimit_)
+    throwRuntimeError("Exceeded stackLimit in readValue().");
   Token token;
   skipCommentTokens(token);
   bool successful = true;
@@ -1125,54 +1104,42 @@ bool OurReader::readValue() {
   case tokenString:
     successful = decodeString(token);
     break;
-  case tokenTrue:
-    {
+  case tokenTrue: {
     Value v(true);
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
-  case tokenFalse:
-    {
+  } break;
+  case tokenFalse: {
     Value v(false);
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
-  case tokenNull:
-    {
+  } break;
+  case tokenNull: {
     Value v;
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
-  case tokenNaN:
-    {
+  } break;
+  case tokenNaN: {
     Value v(std::numeric_limits<double>::quiet_NaN());
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
-  case tokenPosInf:
-    {
+  } break;
+  case tokenPosInf: {
     Value v(std::numeric_limits<double>::infinity());
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
-  case tokenNegInf:
-    {
+  } break;
+  case tokenNegInf: {
     Value v(-std::numeric_limits<double>::infinity());
     currentValue().swapPayload(v);
     currentValue().setOffsetStart(token.start_ - begin_);
     currentValue().setOffsetLimit(token.end_ - begin_);
-    }
-    break;
+  } break;
   case tokenArraySeparator:
   case tokenObjectEnd:
   case tokenArrayEnd:
@@ -1234,9 +1201,9 @@ bool OurReader::readToken(Token& token) {
     break;
   case '\'':
     if (features_.allowSingleQuotes_) {
-    token.type_ = tokenString;
-    ok = readStringSingleQuote();
-    break;
+      token.type_ = tokenString;
+      ok = readStringSingleQuote();
+      break;
     } // else fall through
   case '/':
     token.type_ = tokenComment;
@@ -1354,16 +1321,17 @@ bool OurReader::readComment() {
   return true;
 }
 
-JSONCPP_STRING OurReader::normalizeEOL(OurReader::Location begin, OurReader::Location end) {
-  JSONCPP_STRING normalized;
+String OurReader::normalizeEOL(OurReader::Location begin,
+                               OurReader::Location end) {
+  String normalized;
   normalized.reserve(static_cast<size_t>(end - begin));
   OurReader::Location current = begin;
   while (current != end) {
     char c = *current++;
     if (c == '\r') {
       if (current != end && *current == '\n')
-         // convert dos EOL
-         ++current;
+        // convert dos EOL
+        ++current;
       // convert Mac EOL
       normalized += '\n';
     } else {
@@ -1373,12 +1341,13 @@ JSONCPP_STRING OurReader::normalizeEOL(OurReader::Location begin, OurReader::Loc
   return normalized;
 }
 
-void
-OurReader::addComment(Location begin, Location end, CommentPlacement placement) {
+void OurReader::addComment(Location begin,
+                           Location end,
+                           CommentPlacement placement) {
   assert(collectComments_);
-  const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
+  const String& normalized = normalizeEOL(begin, end);
   if (placement == commentAfterOnSameLine) {
-    assert(lastValue_ != 0);
+    assert(lastValue_ != nullptr);
     lastValue_->setComment(normalized, placement);
   } else {
     commentsBefore_ += normalized;
@@ -1411,7 +1380,7 @@ bool OurReader::readCppStyleComment() {
 }
 
 bool OurReader::readNumber(bool checkInf) {
-  const char *p = current_;
+  const char* p = current_;
   if (checkInf && p != end_ && *p == 'I') {
     current_ = ++p;
     return false;
@@ -1448,7 +1417,6 @@ bool OurReader::readString() {
   return c == '"';
 }
 
-
 bool OurReader::readStringSingleQuote() {
   Char c = 0;
   while (current_ != end_) {
@@ -1461,12 +1429,12 @@ bool OurReader::readStringSingleQuote() {
   return c == '\'';
 }
 
-bool OurReader::readObject(Token& tokenStart) {
+bool OurReader::readObject(Token& token) {
   Token tokenName;
-  JSONCPP_STRING name;
+  String name;
   Value init(objectValue);
   currentValue().swapPayload(init);
-  currentValue().setOffsetStart(tokenStart.start_ - begin_);
+  currentValue().setOffsetStart(token.start_ - begin_);
   while (readToken(tokenName)) {
     bool initialTokenOk = true;
     while (tokenName.type_ == tokenComment && initialTokenOk)
@@ -1490,14 +1458,14 @@ bool OurReader::readObject(Token& tokenStart) {
 
     Token colon;
     if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
-      return addErrorAndRecover(
-          "Missing ':' after object member name", colon, tokenObjectEnd);
+      return addErrorAndRecover("Missing ':' after object member name", colon,
+                                tokenObjectEnd);
     }
-    if (name.length() >= (1U<<30)) throwRuntimeError("keylength >= 2^30");
+    if (name.length() >= (1U << 30))
+      throwRuntimeError("keylength >= 2^30");
     if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
-      JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
-      return addErrorAndRecover(
-          msg, tokenName, tokenObjectEnd);
+      String msg = "Duplicate key: '" + name + "'";
+      return addErrorAndRecover(msg, tokenName, tokenObjectEnd);
     }
     Value& value = currentValue()[name];
     nodes_.push(&value);
@@ -1510,8 +1478,8 @@ bool OurReader::readObject(Token& tokenStart) {
     if (!readToken(comma) ||
         (comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
          comma.type_ != tokenComment)) {
-      return addErrorAndRecover(
-          "Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
+      return addErrorAndRecover("Missing ',' or '}' in object declaration",
+                                comma, tokenObjectEnd);
     }
     bool finalizeTokenOk = true;
     while (comma.type_ == tokenComment && finalizeTokenOk)
@@ -1519,14 +1487,14 @@ bool OurReader::readObject(Token& tokenStart) {
     if (comma.type_ == tokenObjectEnd)
       return true;
   }
-  return addErrorAndRecover(
-      "Missing '}' or object member name", tokenName, tokenObjectEnd);
+  return addErrorAndRecover("Missing '}' or object member name", tokenName,
+                            tokenObjectEnd);
 }
 
-bool OurReader::readArray(Token& tokenStart) {
+bool OurReader::readArray(Token& token) {
   Value init(arrayValue);
   currentValue().swapPayload(init);
-  currentValue().setOffsetStart(tokenStart.start_ - begin_);
+  currentValue().setOffsetStart(token.start_ - begin_);
   skipSpaces();
   if (current_ != end_ && *current_ == ']') // empty array
   {
@@ -1543,19 +1511,19 @@ bool OurReader::readArray(Token& tokenStart) {
     if (!ok) // error already set
       return recoverFromError(tokenArrayEnd);
 
-    Token token;
+    Token currentToken;
     // Accept Comment after last item in the array.
-    ok = readToken(token);
-    while (token.type_ == tokenComment && ok) {
-      ok = readToken(token);
+    ok = readToken(currentToken);
+    while (currentToken.type_ == tokenComment && ok) {
+      ok = readToken(currentToken);
     }
-    bool badTokenType =
-        (token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
+    bool badTokenType = (currentToken.type_ != tokenArraySeparator &&
+                         currentToken.type_ != tokenArrayEnd);
     if (!ok || badTokenType) {
-      return addErrorAndRecover(
-          "Missing ',' or ']' in array declaration", token, tokenArrayEnd);
+      return addErrorAndRecover("Missing ',' or ']' in array declaration",
+                                currentToken, tokenArrayEnd);
     }
-    if (token.type_ == tokenArrayEnd)
+    if (currentToken.type_ == tokenArrayEnd)
       break;
   }
   return true;
@@ -1579,9 +1547,10 @@ bool OurReader::decodeNumber(Token& token, Value& decoded) {
   bool isNegative = *current == '-';
   if (isNegative)
     ++current;
-  // TODO: Help the compiler do the div and mod at compile time or get rid of them.
+  // TODO: Help the compiler do the div and mod at compile time or get rid of
+  // them.
   Value::LargestUInt maxIntegerValue =
-      isNegative ? Value::LargestUInt(-Value::minLargestInt)
+      isNegative ? Value::LargestUInt(Value::minLargestInt)
                  : Value::maxLargestUInt;
   Value::LargestUInt threshold = maxIntegerValue / 10;
   Value::LargestUInt value = 0;
@@ -1589,7 +1558,7 @@ bool OurReader::decodeNumber(Token& token, Value& decoded) {
     Char c = *current++;
     if (c < '0' || c > '9')
       return decodeDouble(token, decoded);
-    Value::UInt digit(static_cast<Value::UInt>(c - '0'));
+    auto digit(static_cast<Value::UInt>(c - '0'));
     if (value >= threshold) {
       // We've hit or exceeded the max value divided by 10 (rounded down). If
       // a) we've only just touched the limit, b) this is the last digit, and
@@ -1631,7 +1600,7 @@ bool OurReader::decodeDouble(Token& token, Value& decoded) {
   if (length < 0) {
     return addError("Unable to parse token length", token);
   }
-  size_t const ulength = static_cast<size_t>(length);
+  auto const ulength = static_cast<size_t>(length);
 
   // Avoid using a string constant for the format control string given to
   // sscanf, as this can cause hard to debug crashes on OS X. See here for more
@@ -1647,20 +1616,19 @@ bool OurReader::decodeDouble(Token& token, Value& decoded) {
     fixNumericLocaleInput(buffer, buffer + length);
     count = sscanf(buffer, format, &value);
   } else {
-    JSONCPP_STRING buffer(token.start_, token.end_);
+    String buffer(token.start_, token.end_);
     count = sscanf(buffer.c_str(), format, &value);
   }
 
   if (count != 1)
-    return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
-                        "' is not a number.",
-                    token);
+    return addError(
+        "'" + String(token.start_, token.end_) + "' is not a number.", token);
   decoded = value;
   return true;
 }
 
 bool OurReader::decodeString(Token& token) {
-  JSONCPP_STRING decoded_string;
+  String decoded_string;
   if (!decodeString(token, decoded_string))
     return false;
   Value decoded(decoded_string);
@@ -1670,7 +1638,7 @@ bool OurReader::decodeString(Token& token) {
   return true;
 }
 
-bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
+bool OurReader::decodeString(Token& token, String& decoded) {
   decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
   Location current = token.start_ + 1; // skip '"'
   Location end = token.end_ - 1;       // do not include '"'
@@ -1724,9 +1692,9 @@ bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
 }
 
 bool OurReader::decodeUnicodeCodePoint(Token& token,
-                                    Location& current,
-                                    Location end,
-                                    unsigned int& unicode) {
+                                       Location& current,
+                                       Location end,
+                                       unsigned int& unicode) {
 
   if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
     return false;
@@ -1735,10 +1703,9 @@ bool OurReader::decodeUnicodeCodePoint(Token& token,
     if (end - current < 6)
       return addError(
           "additional six characters expected to parse unicode surrogate pair.",
-          token,
-          current);
-    unsigned int surrogatePair;
+          token, current);
     if (*(current++) == '\\' && *(current++) == 'u') {
+      unsigned int surrogatePair;
       if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
         unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
       } else
@@ -1746,20 +1713,18 @@ bool OurReader::decodeUnicodeCodePoint(Token& token,
     } else
       return addError("expecting another \\u token to begin the second half of "
                       "a unicode surrogate pair",
-                      token,
-                      current);
+                      token, current);
   }
   return true;
 }
 
 bool OurReader::decodeUnicodeEscapeSequence(Token& token,
-                                         Location& current,
-                                         Location end,
-                                         unsigned int& ret_unicode) {
+                                            Location& current,
+                                            Location end,
+                                            unsigned int& ret_unicode) {
   if (end - current < 4)
     return addError(
-        "Bad unicode escape sequence in string: four digits expected.",
-        token,
+        "Bad unicode escape sequence in string: four digits expected.", token,
         current);
   int unicode = 0;
   for (int index = 0; index < 4; ++index) {
@@ -1774,15 +1739,13 @@ bool OurReader::decodeUnicodeEscapeSequence(Token& token,
     else
       return addError(
           "Bad unicode escape sequence in string: hexadecimal digit expected.",
-          token,
-          current);
+          token, current);
   }
   ret_unicode = static_cast<unsigned int>(unicode);
   return true;
 }
 
-bool
-OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
+bool OurReader::addError(const String& message, Token& token, Location extra) {
   ErrorInfo info;
   info.token_ = token;
   info.message_ = message;
@@ -1804,9 +1767,9 @@ bool OurReader::recoverFromError(TokenType skipUntilToken) {
   return false;
 }
 
-bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
-                                Token& token,
-                                TokenType skipUntilToken) {
+bool OurReader::addErrorAndRecover(const String& message,
+                                   Token& token,
+                                   TokenType skipUntilToken) {
   addError(message, token);
   return recoverFromError(skipUntilToken);
 }
@@ -1820,8 +1783,8 @@ OurReader::Char OurReader::getNextChar() {
 }
 
 void OurReader::getLocationLineAndColumn(Location location,
-                                      int& line,
-                                      int& column) const {
+                                         int& line,
+                                         int& column) const {
   Location current = begin_;
   Location lastLineStart = current;
   line = 0;
@@ -1842,20 +1805,17 @@ void OurReader::getLocationLineAndColumn(Location location,
   ++line;
 }
 
-JSONCPP_STRING OurReader::getLocationLineAndColumn(Location location) const {
+String OurReader::getLocationLineAndColumn(Location location) const {
   int line, column;
   getLocationLineAndColumn(location, line, column);
   char buffer[18 + 16 + 16 + 1];
-  snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
+  jsoncpp_snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
   return buffer;
 }
 
-JSONCPP_STRING OurReader::getFormattedErrorMessages() const {
-  JSONCPP_STRING formattedMessage;
-  for (Errors::const_iterator itError = errors_.begin();
-       itError != errors_.end();
-       ++itError) {
-    const ErrorInfo& error = *itError;
+String OurReader::getFormattedErrorMessages() const {
+  String formattedMessage;
+  for (const auto& error : errors_) {
     formattedMessage +=
         "* " + getLocationLineAndColumn(error.token_.start_) + "\n";
     formattedMessage += "  " + error.message_ + "\n";
@@ -1868,10 +1828,7 @@ JSONCPP_STRING OurReader::getFormattedErrorMessages() const {
 
 std::vector<OurReader::StructuredError> OurReader::getStructuredErrors() const {
   std::vector<OurReader::StructuredError> allErrors;
-  for (Errors::const_iterator itError = errors_.begin();
-       itError != errors_.end();
-       ++itError) {
-    const ErrorInfo& error = *itError;
+  for (const auto& error : errors_) {
     OurReader::StructuredError structured;
     structured.offset_start = error.token_.start_ - begin_;
     structured.offset_limit = error.token_.end_ - begin_;
@@ -1881,10 +1838,9 @@ std::vector<OurReader::StructuredError> OurReader::getStructuredErrors() const {
   return allErrors;
 }
 
-bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message) {
+bool OurReader::pushError(const Value& value, const String& message) {
   ptrdiff_t length = end_ - begin_;
-  if(value.getOffsetStart() > length
-    || value.getOffsetLimit() > length)
+  if (value.getOffsetStart() > length || value.getOffsetLimit() > length)
     return false;
   Token token;
   token.type_ = tokenError;
@@ -1893,16 +1849,17 @@ bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message) {
   ErrorInfo info;
   info.token_ = token;
   info.message_ = message;
-  info.extra_ = 0;
+  info.extra_ = nullptr;
   errors_.push_back(info);
   return true;
 }
 
-bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra) {
+bool OurReader::pushError(const Value& value,
+                          const String& message,
+                          const Value& extra) {
   ptrdiff_t length = end_ - begin_;
-  if(value.getOffsetStart() > length
-    || value.getOffsetLimit() > length
-    || extra.getOffsetLimit() > length)
+  if (value.getOffsetStart() > length || value.getOffsetLimit() > length ||
+      extra.getOffsetLimit() > length)
     return false;
   Token token;
   token.type_ = tokenError;
@@ -1916,24 +1873,19 @@ bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message, con
   return true;
 }
 
-bool OurReader::good() const {
-  return !errors_.size();
-}
-
+bool OurReader::good() const { return errors_.empty(); }
 
 class OurCharReader : public CharReader {
   bool const collectComments_;
   OurReader reader_;
+
 public:
-  OurCharReader(
-    bool collectComments,
-    OurFeatures const& features)
-  : collectComments_(collectComments)
-  , reader_(features)
-  {}
-  bool parse(
-      char const* beginDoc, char const* endDoc,
-      Value* root, JSONCPP_STRING* errs) JSONCPP_OVERRIDE {
+  OurCharReader(bool collectComments, OurFeatures const& features)
+      : collectComments_(collectComments), reader_(features) {}
+  bool parse(char const* beginDoc,
+             char const* endDoc,
+             Value* root,
+             String* errs) override {
     bool ok = reader_.parse(beginDoc, endDoc, *root, collectComments_);
     if (errs) {
       *errs = reader_.getFormattedErrorMessages();
@@ -1942,29 +1894,28 @@ public:
   }
 };
 
-CharReaderBuilder::CharReaderBuilder()
-{
-  setDefaults(&settings_);
-}
-CharReaderBuilder::~CharReaderBuilder()
-{}
-CharReader* CharReaderBuilder::newCharReader() const
-{
+CharReaderBuilder::CharReaderBuilder() { setDefaults(&settings_); }
+CharReaderBuilder::~CharReaderBuilder() = default;
+CharReader* CharReaderBuilder::newCharReader() const {
   bool collectComments = settings_["collectComments"].asBool();
   OurFeatures features = OurFeatures::all();
   features.allowComments_ = settings_["allowComments"].asBool();
   features.strictRoot_ = settings_["strictRoot"].asBool();
-  features.allowDroppedNullPlaceholders_ = settings_["allowDroppedNullPlaceholders"].asBool();
+  features.allowDroppedNullPlaceholders_ =
+      settings_["allowDroppedNullPlaceholders"].asBool();
   features.allowNumericKeys_ = settings_["allowNumericKeys"].asBool();
   features.allowSingleQuotes_ = settings_["allowSingleQuotes"].asBool();
-  features.stackLimit_ = settings_["stackLimit"].asInt();
+#if defined(JSON_HAS_INT64)
+  features.stackLimit_ = settings_["stackLimit"].asUInt64();
+#else
+  features.stackLimit_ = settings_["stackLimit"].asUInt();
+#endif
   features.failIfExtra_ = settings_["failIfExtra"].asBool();
   features.rejectDupKeys_ = settings_["rejectDupKeys"].asBool();
   features.allowSpecialFloats_ = settings_["allowSpecialFloats"].asBool();
   return new OurCharReader(collectComments, features);
 }
-static void getValidReaderKeys(std::set<JSONCPP_STRING>* valid_keys)
-{
+static void getValidReaderKeys(std::set<String>* valid_keys) {
   valid_keys->clear();
   valid_keys->insert("collectComments");
   valid_keys->insert("allowComments");
@@ -1977,31 +1928,29 @@ static void getValidReaderKeys(std::set<JSONCPP_STRING>* valid_keys)
   valid_keys->insert("rejectDupKeys");
   valid_keys->insert("allowSpecialFloats");
 }
-bool CharReaderBuilder::validate(Json::Value* invalid) const
-{
+bool CharReaderBuilder::validate(Json::Value* invalid) const {
   Json::Value my_invalid;
-  if (!invalid) invalid = &my_invalid;  // so we do not need to test for NULL
+  if (!invalid)
+    invalid = &my_invalid; // so we do not need to test for NULL
   Json::Value& inv = *invalid;
-  std::set<JSONCPP_STRING> valid_keys;
+  std::set<String> valid_keys;
   getValidReaderKeys(&valid_keys);
   Value::Members keys = settings_.getMemberNames();
   size_t n = keys.size();
   for (size_t i = 0; i < n; ++i) {
-    JSONCPP_STRING const& key = keys[i];
+    String const& key = keys[i];
     if (valid_keys.find(key) == valid_keys.end()) {
       inv[key] = settings_[key];
     }
   }
-  return 0u == inv.size();
+  return inv.empty();
 }
-Value& CharReaderBuilder::operator[](JSONCPP_STRING key)
-{
+Value& CharReaderBuilder::operator[](const String& key) {
   return settings_[key];
 }
 // static
-void CharReaderBuilder::strictMode(Json::Value* settings)
-{
-//! [CharReaderBuilderStrictMode]
+void CharReaderBuilder::strictMode(Json::Value* settings) {
+  //! [CharReaderBuilderStrictMode]
   (*settings)["allowComments"] = false;
   (*settings)["strictRoot"] = true;
   (*settings)["allowDroppedNullPlaceholders"] = false;
@@ -2011,12 +1960,11 @@ void CharReaderBuilder::strictMode(Json::Value* settings)
   (*settings)["failIfExtra"] = true;
   (*settings)["rejectDupKeys"] = true;
   (*settings)["allowSpecialFloats"] = false;
-//! [CharReaderBuilderStrictMode]
+  //! [CharReaderBuilderStrictMode]
 }
 // static
-void CharReaderBuilder::setDefaults(Json::Value* settings)
-{
-//! [CharReaderBuilderDefaults]
+void CharReaderBuilder::setDefaults(Json::Value* settings) {
+  //! [CharReaderBuilderDefaults]
   (*settings)["collectComments"] = true;
   (*settings)["allowComments"] = true;
   (*settings)["strictRoot"] = false;
@@ -2027,19 +1975,19 @@ void CharReaderBuilder::setDefaults(Json::Value* settings)
   (*settings)["failIfExtra"] = false;
   (*settings)["rejectDupKeys"] = false;
   (*settings)["allowSpecialFloats"] = false;
-//! [CharReaderBuilderDefaults]
+  //! [CharReaderBuilderDefaults]
 }
 
 //////////////////////////////////
 // global functions
 
-bool parseFromStream(
-    CharReader::Factory const& fact, JSONCPP_ISTREAM& sin,
-    Value* root, JSONCPP_STRING* errs)
-{
-  JSONCPP_OSTRINGSTREAM ssin;
+bool parseFromStream(CharReader::Factory const& fact,
+                     IStream& sin,
+                     Value* root,
+                     String* errs) {
+  OStringStream ssin;
   ssin << sin.rdbuf();
-  JSONCPP_STRING doc = ssin.str();
+  String doc = ssin.str();
   char const* begin = doc.data();
   char const* end = begin + doc.size();
   // Note that we do not actually need a null-terminator.
@@ -2047,9 +1995,9 @@ bool parseFromStream(
   return reader->parse(begin, end, root, errs);
 }
 
-JSONCPP_ISTREAM& operator>>(JSONCPP_ISTREAM& sin, Value& root) {
+IStream& operator>>(IStream& sin, Value& root) {
   CharReaderBuilder b;
-  JSONCPP_STRING errs;
+  String errs;
   bool ok = parseFromStream(b, sin, &root, &errs);
   if (!ok) {
     throwRuntimeError(errs);
diff --git a/src/lib_json/json_tool.h b/src/lib_json/json_tool.h
index 4590bfc..5c13f1f 100644
--- a/src/lib_json/json_tool.h
+++ b/src/lib_json/json_tool.h
@@ -6,6 +6,9 @@
 #ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED
 #define LIB_JSONCPP_JSON_TOOL_H_INCLUDED
 
+#if !defined(JSON_IS_AMALGAMATION)
+#include <json/config.h>
+#endif
 
 // Also support old flag NO_LOCALE_SUPPORT
 #ifdef NO_LOCALE_SUPPORT
@@ -23,7 +26,7 @@
  */
 
 namespace Json {
-static char getDecimalPoint() {
+static inline char getDecimalPoint() {
 #ifdef JSONCPP_NO_LOCALE_SUPPORT
   return '\0';
 #else
@@ -33,8 +36,8 @@ static char getDecimalPoint() {
 }
 
 /// Converts a unicode code-point to UTF-8.
-static inline JSONCPP_STRING codePointToUTF8(unsigned int cp) {
-  JSONCPP_STRING result;
+static inline String codePointToUTF8(unsigned int cp) {
+  String result;
 
   // based on description from http://en.wikipedia.org/wiki/UTF-8
 
@@ -88,27 +91,44 @@ static inline void uintToString(LargestUInt value, char*& current) {
  * We had a sophisticated way, but it did not work in WinCE.
  * @see https://github.com/open-source-parsers/jsoncpp/pull/9
  */
-static inline void fixNumericLocale(char* begin, char* end) {
-  while (begin < end) {
+template <typename Iter> Iter fixNumericLocale(Iter begin, Iter end) {
+  for (; begin != end; ++begin) {
     if (*begin == ',') {
       *begin = '.';
     }
-    ++begin;
   }
+  return begin;
 }
 
-static inline void fixNumericLocaleInput(char* begin, char* end) {
+template <typename Iter> void fixNumericLocaleInput(Iter begin, Iter end) {
   char decimalPoint = getDecimalPoint();
-  if (decimalPoint != '\0' && decimalPoint != '.') {
-    while (begin < end) {
-      if (*begin == '.') {
-        *begin = decimalPoint;
-      }
-      ++begin;
+  if (decimalPoint == '\0' || decimalPoint == '.') {
+    return;
+  }
+  for (; begin != end; ++begin) {
+    if (*begin == '.') {
+      *begin = decimalPoint;
+    }
+  }
+}
+
+/**
+ * Return iterator that would be the new end of the range [begin,end), if we
+ * were to delete zeros in the end of string, but not the last zero before '.'.
+ */
+template <typename Iter> Iter fixZerosInTheEnd(Iter begin, Iter end) {
+  for (; begin != end; --end) {
+    if (*(end - 1) != '0') {
+      return end;
+    }
+    // Don't delete the last zero before the decimal point.
+    if (begin != (end - 1) && *(end - 2) == '.') {
+      return end;
     }
   }
+  return end;
 }
 
-} // namespace Json {
+} // namespace Json
 
 #endif // LIB_JSONCPP_JSON_TOOL_H_INCLUDED
diff --git a/src/lib_json/json_value.cpp b/src/lib_json/json_value.cpp
index 91d4802..b046c19 100644
--- a/src/lib_json/json_value.cpp
+++ b/src/lib_json/json_value.cpp
@@ -8,21 +8,62 @@
 #include <json/value.h>
 #include <json/writer.h>
 #endif // if !defined(JSON_IS_AMALGAMATION)
-#include <math.h>
+#include <cassert>
+#include <cmath>
+#include <cstring>
 #include <sstream>
 #include <utility>
-#include <cstring>
-#include <cassert>
 #ifdef JSON_USE_CPPTL
 #include <cpptl/conststring.h>
 #endif
-#include <cstddef> // size_t
 #include <algorithm> // min()
+#include <cstddef>   // size_t
+
+// Provide implementation equivalent of std::snprintf for older _MSC compilers
+#if defined(_MSC_VER) && _MSC_VER < 1900
+#include <stdarg.h>
+static int msvc_pre1900_c99_vsnprintf(char* outBuf,
+                                      size_t size,
+                                      const char* format,
+                                      va_list ap) {
+  int count = -1;
+  if (size != 0)
+    count = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap);
+  if (count == -1)
+    count = _vscprintf(format, ap);
+  return count;
+}
+
+int JSON_API msvc_pre1900_c99_snprintf(char* outBuf,
+                                       size_t size,
+                                       const char* format,
+                                       ...) {
+  va_list ap;
+  va_start(ap, format);
+  const int count = msvc_pre1900_c99_vsnprintf(outBuf, size, format, ap);
+  va_end(ap);
+  return count;
+}
+#endif
+
+// Disable warning C4702 : unreachable code
+#if defined(_MSC_VER)
+#pragma warning(disable : 4702)
+#endif
 
 #define JSON_ASSERT_UNREACHABLE assert(false)
 
 namespace Json {
 
+template <typename T>
+static std::unique_ptr<T> cloneUnique(const std::unique_ptr<T>& p) {
+  std::unique_ptr<T> r;
+  if (p) {
+    r = std::unique_ptr<T>(new T(*p));
+  }
+  return r;
+}
+
 // This is a walkaround to avoid the static initialization of Value::null.
 // kNull must be word-aligned to avoid crashing on ARM.  We use an alignment of
 // 8 (instead of 4) as a bit of future-proofing.
@@ -31,20 +72,19 @@ namespace Json {
 #else
 #define ALIGNAS(byte_alignment)
 #endif
-//static const unsigned char ALIGNAS(8) kNull[sizeof(Value)] = { 0 };
-//const unsigned char& kNullRef = kNull[0];
-//const Value& Value::null = reinterpret_cast<const Value&>(kNullRef);
-//const Value& Value::nullRef = null;
+// static const unsigned char ALIGNAS(8) kNull[sizeof(Value)] = { 0 };
+// const unsigned char& kNullRef = kNull[0];
+// const Value& Value::null = reinterpret_cast<const Value&>(kNullRef);
+// const Value& Value::nullRef = null;
 
 // static
-Value const& Value::nullSingleton()
-{
- static Value const nullStatic;
- return nullStatic;
+Value const& Value::nullSingleton() {
+  static Value const nullStatic;
+  return nullStatic;
 }
 
-// for backwards compatibility, we'll leave these global references around, but DO NOT
-// use them in JSONCPP library code any more!
+// for backwards compatibility, we'll leave these global references around, but
+// DO NOT use them in JSONCPP library code any more!
 Value const& Value::null = Value::nullSingleton();
 Value const& Value::nullRef = Value::nullSingleton();
 
@@ -64,17 +104,20 @@ const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
 const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
 const LargestUInt Value::maxLargestUInt = LargestUInt(-1);
 
+const UInt Value::defaultRealPrecision = 17;
+
 #if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
 template <typename T, typename U>
 static inline bool InRange(double d, T min, U max) {
   // The casts can lose precision, but we are looking only for
   // an approximate range. Might fail on edge cases though. ~cdunn
-  //return d >= static_cast<double>(min) && d <= static_cast<double>(max);
+  // return d >= static_cast<double>(min) && d <= static_cast<double>(max);
   return d >= min && d <= max;
 }
 #else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
 static inline double integerToDouble(Json::UInt64 value) {
-  return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
+  return static_cast<double>(Int64(value / 2)) * 2.0 +
+         static_cast<double>(Int64(value & 1));
 }
 
 template <typename T> static inline double integerToDouble(T value) {
@@ -94,19 +137,16 @@ static inline bool InRange(double d, T min, U max) {
  *               computed using strlen(value).
  * @return Pointer on the duplicate instance of string.
  */
-static inline char* duplicateStringValue(const char* value,
-                                         size_t length)
-{
+static inline char* duplicateStringValue(const char* value, size_t length) {
   // Avoid an integer overflow in the call to malloc below by limiting length
   // to a sane value.
   if (length >= static_cast<size_t>(Value::maxInt))
     length = Value::maxInt - 1;
 
   char* newString = static_cast<char*>(malloc(length + 1));
-  if (newString == NULL) {
-    throwRuntimeError(
-        "in Json::Value::duplicateStringValue(): "
-        "Failed to allocate string value buffer");
+  if (newString == nullptr) {
+    throwRuntimeError("in Json::Value::duplicateStringValue(): "
+                      "Failed to allocate string value buffer");
   }
   memcpy(newString, value, length);
   newString[length] = 0;
@@ -115,31 +155,30 @@ static inline char* duplicateStringValue(const char* value,
 
 /* Record the length as a prefix.
  */
-static inline char* duplicateAndPrefixStringValue(
-    const char* value,
-    unsigned int length)
-{
+static inline char* duplicateAndPrefixStringValue(const char* value,
+                                                  unsigned int length) {
   // Avoid an integer overflow in the call to malloc below by limiting length
   // to a sane value.
-  JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
+  JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) -
+                                    sizeof(unsigned) - 1U,
                       "in Json::Value::duplicateAndPrefixStringValue(): "
                       "length too big for prefixing");
   unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
   char* newString = static_cast<char*>(malloc(actualLength));
-  if (newString == 0) {
-    throwRuntimeError(
-        "in Json::Value::duplicateAndPrefixStringValue(): "
-        "Failed to allocate string value buffer");
+  if (newString == nullptr) {
+    throwRuntimeError("in Json::Value::duplicateAndPrefixStringValue(): "
+                      "Failed to allocate string value buffer");
   }
   *reinterpret_cast<unsigned*>(newString) = length;
   memcpy(newString + sizeof(unsigned), value, length);
-  newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
+  newString[actualLength - 1U] =
+      0; // to avoid buffer over-run accidents by users later
   return newString;
 }
-inline static void decodePrefixedString(
-    bool isPrefixed, char const* prefixed,
-    unsigned* length, char const** value)
-{
+inline static void decodePrefixedString(bool isPrefixed,
+                                        char const* prefixed,
+                                        unsigned* length,
+                                        char const** value) {
   if (!isPrefixed) {
     *length = static_cast<unsigned>(strlen(prefixed));
     *value = prefixed;
@@ -148,7 +187,8 @@ inline static void decodePrefixedString(
     *value = prefixed + sizeof(unsigned);
   }
 }
-/** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
+/** Free the string duplicated by
+ * duplicateStringValue()/duplicateAndPrefixStringValue().
  */
 #if JSONCPP_USING_SECURE_MEMORY
 static inline void releasePrefixedStringValue(char* value) {
@@ -161,17 +201,13 @@ static inline void releasePrefixedStringValue(char* value) {
 }
 static inline void releaseStringValue(char* value, unsigned length) {
   // length==0 => we allocated the strings memory
-  size_t size = (length==0) ? strlen(value) : length;
+  size_t size = (length == 0) ? strlen(value) : length;
   memset(value, 0, size);
   free(value);
 }
-#else // !JSONCPP_USING_SECURE_MEMORY
-static inline void releasePrefixedStringValue(char* value) {
-  free(value);
-}
-static inline void releaseStringValue(char* value, unsigned) {
-  free(value);
-}
+#else  // !JSONCPP_USING_SECURE_MEMORY
+static inline void releasePrefixedStringValue(char* value) { free(value); }
+static inline void releaseStringValue(char* value, unsigned) { free(value); }
 #endif // JSONCPP_USING_SECURE_MEMORY
 
 } // namespace Json
@@ -190,59 +226,18 @@ static inline void releaseStringValue(char* value, unsigned) {
 
 namespace Json {
 
-Exception::Exception(JSONCPP_STRING const& msg)
-  : msg_(msg)
-{}
-Exception::~Exception() JSONCPP_NOEXCEPT
-{}
-char const* Exception::what() const JSONCPP_NOEXCEPT
-{
-  return msg_.c_str();
-}
-RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
-  : Exception(msg)
-{}
-LogicError::LogicError(JSONCPP_STRING const& msg)
-  : Exception(msg)
-{}
-JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
-{
+Exception::Exception(String msg) : msg_(std::move(msg)) {}
+Exception::~Exception() JSONCPP_NOEXCEPT {}
+char const* Exception::what() const JSONCPP_NOEXCEPT { return msg_.c_str(); }
+RuntimeError::RuntimeError(String const& msg) : Exception(msg) {}
+LogicError::LogicError(String const& msg) : Exception(msg) {}
+JSONCPP_NORETURN void throwRuntimeError(String const& msg) {
   throw RuntimeError(msg);
 }
-JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
-{
+JSONCPP_NORETURN void throwLogicError(String const& msg) {
   throw LogicError(msg);
 }
 
-// //////////////////////////////////////////////////////////////////
-// //////////////////////////////////////////////////////////////////
-// //////////////////////////////////////////////////////////////////
-// class Value::CommentInfo
-// //////////////////////////////////////////////////////////////////
-// //////////////////////////////////////////////////////////////////
-// //////////////////////////////////////////////////////////////////
-
-Value::CommentInfo::CommentInfo() : comment_(0)
-{}
-
-Value::CommentInfo::~CommentInfo() {
-  if (comment_)
-    releaseStringValue(comment_, 0u);
-}
-
-void Value::CommentInfo::setComment(const char* text, size_t len) {
-  if (comment_) {
-    releaseStringValue(comment_, 0u);
-    comment_ = 0;
-  }
-  JSON_ASSERT(text != 0);
-  JSON_ASSERT_MESSAGE(
-      text[0] == '\0' || text[0] == '/',
-      "in Json::Value::setComment(): Comments must start with /");
-  // It seems that /**/ style comments are acceptable as well.
-  comment_ = duplicateStringValue(text, len);
-}
-
 // //////////////////////////////////////////////////////////////////
 // //////////////////////////////////////////////////////////////////
 // //////////////////////////////////////////////////////////////////
@@ -254,36 +249,45 @@ void Value::CommentInfo::setComment(const char* text, size_t len) {
 // Notes: policy_ indicates if the string was allocated when
 // a string is stored.
 
-Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}
+Value::CZString::CZString(ArrayIndex index) : cstr_(nullptr), index_(index) {}
 
-Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
+Value::CZString::CZString(char const* str,
+                          unsigned length,
+                          DuplicationPolicy allocate)
     : cstr_(str) {
   // allocate != duplicate
   storage_.policy_ = allocate & 0x3;
-  storage_.length_ = ulength & 0x3FFFFFFF;
+  storage_.length_ = length & 0x3FFFFFFF;
 }
 
 Value::CZString::CZString(const CZString& other) {
-  cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
-				 ? duplicateStringValue(other.cstr_, other.storage_.length_)
-				 : other.cstr_);
-  storage_.policy_ = static_cast<unsigned>(other.cstr_
-                 ? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
-                     ? noDuplication : duplicate)
-                 : static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
+  cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != nullptr
+               ? duplicateStringValue(other.cstr_, other.storage_.length_)
+               : other.cstr_);
+  storage_.policy_ =
+      static_cast<unsigned>(
+          other.cstr_
+              ? (static_cast<DuplicationPolicy>(other.storage_.policy_) ==
+                         noDuplication
+                     ? noDuplication
+                     : duplicate)
+              : static_cast<DuplicationPolicy>(other.storage_.policy_)) &
+      3U;
   storage_.length_ = other.storage_.length_;
 }
 
-#if JSON_HAS_RVALUE_REFERENCES
 Value::CZString::CZString(CZString&& other)
-  : cstr_(other.cstr_), index_(other.index_) {
+    : cstr_(other.cstr_), index_(other.index_) {
   other.cstr_ = nullptr;
 }
-#endif
 
 Value::CZString::~CZString() {
   if (cstr_ && storage_.policy_ == duplicate) {
-	  releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
+    releaseStringValue(const_cast<char*>(cstr_),
+                       storage_.length_ + 1u); // +1 for null terminating
+                                               // character for sake of
+                                               // completeness but not actually
+                                               // necessary
   }
 }
 
@@ -298,36 +302,39 @@ Value::CZString& Value::CZString::operator=(const CZString& other) {
   return *this;
 }
 
-#if JSON_HAS_RVALUE_REFERENCES
 Value::CZString& Value::CZString::operator=(CZString&& other) {
   cstr_ = other.cstr_;
   index_ = other.index_;
   other.cstr_ = nullptr;
   return *this;
 }
-#endif
 
 bool Value::CZString::operator<(const CZString& other) const {
-  if (!cstr_) return index_ < other.index_;
-  //return strcmp(cstr_, other.cstr_) < 0;
+  if (!cstr_)
+    return index_ < other.index_;
+  // return strcmp(cstr_, other.cstr_) < 0;
   // Assume both are strings.
   unsigned this_len = this->storage_.length_;
   unsigned other_len = other.storage_.length_;
   unsigned min_len = std::min<unsigned>(this_len, other_len);
   JSON_ASSERT(this->cstr_ && other.cstr_);
   int comp = memcmp(this->cstr_, other.cstr_, min_len);
-  if (comp < 0) return true;
-  if (comp > 0) return false;
+  if (comp < 0)
+    return true;
+  if (comp > 0)
+    return false;
   return (this_len < other_len);
 }
 
 bool Value::CZString::operator==(const CZString& other) const {
-  if (!cstr_) return index_ == other.index_;
-  //return strcmp(cstr_, other.cstr_) == 0;
+  if (!cstr_)
+    return index_ == other.index_;
+  // return strcmp(cstr_, other.cstr_) == 0;
   // Assume both are strings.
   unsigned this_len = this->storage_.length_;
   unsigned other_len = other.storage_.length_;
-  if (this_len != other_len) return false;
+  if (this_len != other_len)
+    return false;
   JSON_ASSERT(this->cstr_ && other.cstr_);
   int comp = memcmp(this->cstr_, other.cstr_, this_len);
   return comp == 0;
@@ -335,10 +342,12 @@ bool Value::CZString::operator==(const CZString& other) const {
 
 ArrayIndex Value::CZString::index() const { return index_; }
 
-//const char* Value::CZString::c_str() const { return cstr_; }
+// const char* Value::CZString::c_str() const { return cstr_; }
 const char* Value::CZString::data() const { return cstr_; }
 unsigned Value::CZString::length() const { return storage_.length_; }
-bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }
+bool Value::CZString::isStaticString() const {
+  return storage_.policy_ == noDuplication;
+}
 
 // //////////////////////////////////////////////////////////////////
 // //////////////////////////////////////////////////////////////////
@@ -352,10 +361,10 @@ bool Value::CZString::isStaticString() const { return storage_.policy_ == noDupl
  * memset( this, 0, sizeof(Value) )
  * This optimization is used in ValueInternalMap fast allocator.
  */
-Value::Value(ValueType vtype) {
+Value::Value(ValueType type) {
   static char const emptyString[] = "";
-  initBasic(vtype);
-  switch (vtype) {
+  initBasic(type);
+  switch (type) {
   case nullValue:
     break;
   case intValue:
@@ -408,20 +417,22 @@ Value::Value(double value) {
 
 Value::Value(const char* value) {
   initBasic(stringValue, true);
-  JSON_ASSERT_MESSAGE(value != NULL, "Null Value Passed to Value Constructor");
-  value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
+  JSON_ASSERT_MESSAGE(value != nullptr,
+                      "Null Value Passed to Value Constructor");
+  value_.string_ = duplicateAndPrefixStringValue(
+      value, static_cast<unsigned>(strlen(value)));
 }
 
-Value::Value(const char* beginValue, const char* endValue) {
+Value::Value(const char* begin, const char* end) {
   initBasic(stringValue, true);
   value_.string_ =
-      duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
+      duplicateAndPrefixStringValue(begin, static_cast<unsigned>(end - begin));
 }
 
-Value::Value(const JSONCPP_STRING& value) {
+Value::Value(const String& value) {
   initBasic(stringValue, true);
-  value_.string_ =
-      duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
+  value_.string_ = duplicateAndPrefixStringValue(
+      value.data(), static_cast<unsigned>(value.length()));
 }
 
 Value::Value(const StaticString& value) {
@@ -432,7 +443,8 @@ Value::Value(const StaticString& value) {
 #ifdef JSON_USE_CPPTL
 Value::Value(const CppTL::ConstString& value) {
   initBasic(stringValue, true);
-  value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
+  value_.string_ = duplicateAndPrefixStringValue(
+      value, static_cast<unsigned>(value.length()));
 }
 #endif
 
@@ -441,102 +453,39 @@ Value::Value(bool value) {
   value_.bool_ = value;
 }
 
-Value::Value(Value const& other)
-    : type_(other.type_), allocated_(false)
-      ,
-      comments_(0), start_(other.start_), limit_(other.limit_)
-{
-  switch (type_) {
-  case nullValue:
-  case intValue:
-  case uintValue:
-  case realValue:
-  case booleanValue:
-    value_ = other.value_;
-    break;
-  case stringValue:
-    if (other.value_.string_ && other.allocated_) {
-      unsigned len;
-      char const* str;
-      decodePrefixedString(other.allocated_, other.value_.string_,
-          &len, &str);
-      value_.string_ = duplicateAndPrefixStringValue(str, len);
-      allocated_ = true;
-    } else {
-      value_.string_ = other.value_.string_;
-      allocated_ = false;
-    }
-    break;
-  case arrayValue:
-  case objectValue:
-    value_.map_ = new ObjectValues(*other.value_.map_);
-    break;
-  default:
-    JSON_ASSERT_UNREACHABLE;
-  }
-  if (other.comments_) {
-    comments_ = new CommentInfo[numberOfCommentPlacement];
-    for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
-      const CommentInfo& otherComment = other.comments_[comment];
-      if (otherComment.comment_)
-        comments_[comment].setComment(
-            otherComment.comment_, strlen(otherComment.comment_));
-    }
-  }
+Value::Value(const Value& other) {
+  dupPayload(other);
+  dupMeta(other);
 }
 
-#if JSON_HAS_RVALUE_REFERENCES
-// Move constructor
 Value::Value(Value&& other) {
   initBasic(nullValue);
   swap(other);
 }
-#endif
 
 Value::~Value() {
-  switch (type_) {
-  case nullValue:
-  case intValue:
-  case uintValue:
-  case realValue:
-  case booleanValue:
-    break;
-  case stringValue:
-    if (allocated_)
-      releasePrefixedStringValue(value_.string_);
-    break;
-  case arrayValue:
-  case objectValue:
-    delete value_.map_;
-    break;
-  default:
-    JSON_ASSERT_UNREACHABLE;
-  }
-
-  delete[] comments_;
-
+  releasePayload();
   value_.uint_ = 0;
 }
 
-Value& Value::operator=(Value other) {
-  swap(other);
+Value& Value::operator=(const Value& other) {
+  Value(other).swap(*this);
+  return *this;
+}
+
+Value& Value::operator=(Value&& other) {
+  other.swap(*this);
   return *this;
 }
 
 void Value::swapPayload(Value& other) {
-  ValueType temp = type_;
-  type_ = other.type_;
-  other.type_ = temp;
+  std::swap(bits_, other.bits_);
   std::swap(value_, other.value_);
-  int temp2 = allocated_;
-  allocated_ = other.allocated_;
-  other.allocated_ = temp2 & 0x1;
 }
 
 void Value::copyPayload(const Value& other) {
-  type_ = other.type_;
-  value_ = other.value_;
-  allocated_ = other.allocated_;
+  releasePayload();
+  dupPayload(other);
 }
 
 void Value::swap(Value& other) {
@@ -548,12 +497,12 @@ void Value::swap(Value& other) {
 
 void Value::copy(const Value& other) {
   copyPayload(other);
-  comments_ = other.comments_;
-  start_ = other.start_;
-  limit_ = other.limit_;
+  dupMeta(other);
 }
 
-ValueType Value::type() const { return type_; }
+ValueType Value::type() const {
+  return static_cast<ValueType>(bits_.value_type_);
+}
 
 int Value::compare(const Value& other) const {
   if (*this < other)
@@ -564,10 +513,10 @@ int Value::compare(const Value& other) const {
 }
 
 bool Value::operator<(const Value& other) const {
-  int typeDelta = type_ - other.type_;
+  int typeDelta = type() - other.type();
   if (typeDelta)
     return typeDelta < 0 ? true : false;
-  switch (type_) {
+  switch (type()) {
   case nullValue:
     return false;
   case intValue:
@@ -578,23 +527,28 @@ bool Value::operator<(const Value& other) const {
     return value_.real_ < other.value_.real_;
   case booleanValue:
     return value_.bool_ < other.value_.bool_;
-  case stringValue:
-  {
-    if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
-      if (other.value_.string_) return true;
-      else return false;
+  case stringValue: {
+    if ((value_.string_ == nullptr) || (other.value_.string_ == nullptr)) {
+      if (other.value_.string_)
+        return true;
+      else
+        return false;
     }
     unsigned this_len;
     unsigned other_len;
     char const* this_str;
     char const* other_str;
-    decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
-    decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
+    decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
+                         &this_str);
+    decodePrefixedString(other.isAllocated(), other.value_.string_, &other_len,
+                         &other_str);
     unsigned min_len = std::min<unsigned>(this_len, other_len);
     JSON_ASSERT(this_str && other_str);
     int comp = memcmp(this_str, other_str, min_len);
-    if (comp < 0) return true;
-    if (comp > 0) return false;
+    if (comp < 0)
+      return true;
+    if (comp > 0)
+      return false;
     return (this_len < other_len);
   }
   case arrayValue:
@@ -617,14 +571,9 @@ bool Value::operator>=(const Value& other) const { return !(*this < other); }
 bool Value::operator>(const Value& other) const { return other < *this; }
 
 bool Value::operator==(const Value& other) const {
-  // if ( type_ != other.type_ )
-  // GCC 2.95.3 says:
-  // attempt to take address of bit-field structure member `Json::Value::type_'
-  // Beats me, but a temp solves the problem.
-  int temp = other.type_;
-  if (type_ != temp)
+  if (type() != other.type())
     return false;
-  switch (type_) {
+  switch (type()) {
   case nullValue:
     return true;
   case intValue:
@@ -635,18 +584,20 @@ bool Value::operator==(const Value& other) const {
     return value_.real_ == other.value_.real_;
   case booleanValue:
     return value_.bool_ == other.value_.bool_;
-  case stringValue:
-  {
-    if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
+  case stringValue: {
+    if ((value_.string_ == nullptr) || (other.value_.string_ == nullptr)) {
       return (value_.string_ == other.value_.string_);
     }
     unsigned this_len;
     unsigned other_len;
     char const* this_str;
     char const* other_str;
-    decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
-    decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
-    if (this_len != other_len) return false;
+    decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
+                         &this_str);
+    decodePrefixedString(other.isAllocated(), other.value_.string_, &other_len,
+                         &other_str);
+    if (this_len != other_len)
+      return false;
     JSON_ASSERT(this_str && other_str);
     int comp = memcmp(this_str, other_str, this_len);
     return comp == 0;
@@ -664,47 +615,55 @@ bool Value::operator==(const Value& other) const {
 bool Value::operator!=(const Value& other) const { return !(*this == other); }
 
 const char* Value::asCString() const {
-  JSON_ASSERT_MESSAGE(type_ == stringValue,
+  JSON_ASSERT_MESSAGE(type() == stringValue,
                       "in Json::Value::asCString(): requires stringValue");
-  if (value_.string_ == 0) return 0;
+  if (value_.string_ == nullptr)
+    return nullptr;
   unsigned this_len;
   char const* this_str;
-  decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
+  decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
+                       &this_str);
   return this_str;
 }
 
 #if JSONCPP_USING_SECURE_MEMORY
 unsigned Value::getCStringLength() const {
-  JSON_ASSERT_MESSAGE(type_ == stringValue,
-	                  "in Json::Value::asCString(): requires stringValue");
-  if (value_.string_ == 0) return 0;
+  JSON_ASSERT_MESSAGE(type() == stringValue,
+                      "in Json::Value::asCString(): requires stringValue");
+  if (value_.string_ == 0)
+    return 0;
   unsigned this_len;
   char const* this_str;
-  decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
+  decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
+                       &this_str);
   return this_len;
 }
 #endif
 
-bool Value::getString(char const** str, char const** cend) const {
-  if (type_ != stringValue) return false;
-  if (value_.string_ == 0) return false;
+bool Value::getString(char const** begin, char const** end) const {
+  if (type() != stringValue)
+    return false;
+  if (value_.string_ == nullptr)
+    return false;
   unsigned length;
-  decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
-  *cend = *str + length;
+  decodePrefixedString(this->isAllocated(), this->value_.string_, &length,
+                       begin);
+  *end = *begin + length;
   return true;
 }
 
-JSONCPP_STRING Value::asString() const {
-  switch (type_) {
+String Value::asString() const {
+  switch (type()) {
   case nullValue:
     return "";
-  case stringValue:
-  {
-    if (value_.string_ == 0) return "";
+  case stringValue: {
+    if (value_.string_ == nullptr)
+      return "";
     unsigned this_len;
     char const* this_str;
-    decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
-    return JSONCPP_STRING(this_str, this_len);
+    decodePrefixedString(this->isAllocated(), this->value_.string_, &this_len,
+                         &this_str);
+    return String(this_str, this_len);
   }
   case booleanValue:
     return value_.bool_ ? "true" : "false";
@@ -723,14 +682,13 @@ JSONCPP_STRING Value::asString() const {
 CppTL::ConstString Value::asConstString() const {
   unsigned len;
   char const* str;
-  decodePrefixedString(allocated_, value_.string_,
-      &len, &str);
+  decodePrefixedString(isAllocated(), value_.string_, &len, &str);
   return CppTL::ConstString(str, len);
 }
 #endif
 
 Value::Int Value::asInt() const {
-  switch (type_) {
+  switch (type()) {
   case intValue:
     JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
     return Int(value_.int_);
@@ -752,7 +710,7 @@ Value::Int Value::asInt() const {
 }
 
 Value::UInt Value::asUInt() const {
-  switch (type_) {
+  switch (type()) {
   case intValue:
     JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
     return UInt(value_.int_);
@@ -776,7 +734,7 @@ Value::UInt Value::asUInt() const {
 #if defined(JSON_HAS_INT64)
 
 Value::Int64 Value::asInt64() const {
-  switch (type_) {
+  switch (type()) {
   case intValue:
     return Int64(value_.int_);
   case uintValue:
@@ -797,7 +755,7 @@ Value::Int64 Value::asInt64() const {
 }
 
 Value::UInt64 Value::asUInt64() const {
-  switch (type_) {
+  switch (type()) {
   case intValue:
     JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
     return UInt64(value_.int_);
@@ -835,7 +793,7 @@ LargestUInt Value::asLargestUInt() const {
 }
 
 double Value::asDouble() const {
-  switch (type_) {
+  switch (type()) {
   case intValue:
     return static_cast<double>(value_.int_);
   case uintValue:
@@ -857,7 +815,7 @@ double Value::asDouble() const {
 }
 
 float Value::asFloat() const {
-  switch (type_) {
+  switch (type()) {
   case intValue:
     return static_cast<float>(value_.int_);
   case uintValue:
@@ -880,7 +838,7 @@ float Value::asFloat() const {
 }
 
 bool Value::asBool() const {
-  switch (type_) {
+  switch (type()) {
   case booleanValue:
     return value_.bool_;
   case nullValue:
@@ -902,30 +860,30 @@ bool Value::isConvertibleTo(ValueType other) const {
   switch (other) {
   case nullValue:
     return (isNumeric() && asDouble() == 0.0) ||
-           (type_ == booleanValue && value_.bool_ == false) ||
-           (type_ == stringValue && asString().empty()) ||
-           (type_ == arrayValue && value_.map_->size() == 0) ||
-           (type_ == objectValue && value_.map_->size() == 0) ||
-           type_ == nullValue;
+           (type() == booleanValue && value_.bool_ == false) ||
+           (type() == stringValue && asString().empty()) ||
+           (type() == arrayValue && value_.map_->empty()) ||
+           (type() == objectValue && value_.map_->empty()) ||
+           type() == nullValue;
   case intValue:
     return isInt() ||
-           (type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
-           type_ == booleanValue || type_ == nullValue;
+           (type() == realValue && InRange(value_.real_, minInt, maxInt)) ||
+           type() == booleanValue || type() == nullValue;
   case uintValue:
     return isUInt() ||
-           (type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
-           type_ == booleanValue || type_ == nullValue;
+           (type() == realValue && InRange(value_.real_, 0, maxUInt)) ||
+           type() == booleanValue || type() == nullValue;
   case realValue:
-    return isNumeric() || type_ == booleanValue || type_ == nullValue;
+    return isNumeric() || type() == booleanValue || type() == nullValue;
   case booleanValue:
-    return isNumeric() || type_ == booleanValue || type_ == nullValue;
+    return isNumeric() || type() == booleanValue || type() == nullValue;
   case stringValue:
-    return isNumeric() || type_ == booleanValue || type_ == stringValue ||
-           type_ == nullValue;
+    return isNumeric() || type() == booleanValue || type() == stringValue ||
+           type() == nullValue;
   case arrayValue:
-    return type_ == arrayValue || type_ == nullValue;
+    return type() == arrayValue || type() == nullValue;
   case objectValue:
-    return type_ == objectValue || type_ == nullValue;
+    return type() == objectValue || type() == nullValue;
   }
   JSON_ASSERT_UNREACHABLE;
   return false;
@@ -933,7 +891,7 @@ bool Value::isConvertibleTo(ValueType other) const {
 
 /// Number of values in array or object
 ArrayIndex Value::size() const {
-  switch (type_) {
+  switch (type()) {
   case nullValue:
   case intValue:
   case uintValue:
@@ -962,15 +920,15 @@ bool Value::empty() const {
     return false;
 }
 
-Value::operator bool() const { return ! isNull(); }
+Value::operator bool() const { return !isNull(); }
 
 void Value::clear() {
-  JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
-                          type_ == objectValue,
+  JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue ||
+                          type() == objectValue,
                       "in Json::Value::clear(): requires complex value");
   start_ = 0;
   limit_ = 0;
-  switch (type_) {
+  switch (type()) {
   case arrayValue:
   case objectValue:
     value_.map_->clear();
@@ -981,15 +939,15 @@ void Value::clear() {
 }
 
 void Value::resize(ArrayIndex newSize) {
-  JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
+  JSON_ASSERT_MESSAGE(type() == nullValue || type() == arrayValue,
                       "in Json::Value::resize(): requires arrayValue");
-  if (type_ == nullValue)
+  if (type() == nullValue)
     *this = Value(arrayValue);
   ArrayIndex oldSize = size();
   if (newSize == 0)
     clear();
   else if (newSize > oldSize)
-    (*this)[newSize - 1];
+    this->operator[](newSize - 1);
   else {
     for (ArrayIndex index = newSize; index < oldSize; ++index) {
       value_.map_->erase(index);
@@ -1000,12 +958,12 @@ void Value::resize(ArrayIndex newSize) {
 
 Value& Value::operator[](ArrayIndex index) {
   JSON_ASSERT_MESSAGE(
-      type_ == nullValue || type_ == arrayValue,
+      type() == nullValue || type() == arrayValue,
       "in Json::Value::operator[](ArrayIndex): requires arrayValue");
-  if (type_ == nullValue)
+  if (type() == nullValue)
     *this = Value(arrayValue);
   CZString key(index);
-  ObjectValues::iterator it = value_.map_->lower_bound(key);
+  auto it = value_.map_->lower_bound(key);
   if (it != value_.map_->end() && (*it).first == key)
     return (*it).second;
 
@@ -1023,9 +981,9 @@ Value& Value::operator[](int index) {
 
 const Value& Value::operator[](ArrayIndex index) const {
   JSON_ASSERT_MESSAGE(
-      type_ == nullValue || type_ == arrayValue,
+      type() == nullValue || type() == arrayValue,
       "in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
-  if (type_ == nullValue)
+  if (type() == nullValue)
     return nullSingleton();
   CZString key(index);
   ObjectValues::const_iterator it = value_.map_->find(key);
@@ -1041,26 +999,85 @@ const Value& Value::operator[](int index) const {
   return (*this)[ArrayIndex(index)];
 }
 
-void Value::initBasic(ValueType vtype, bool allocated) {
-  type_ = vtype;
-  allocated_ = allocated;
-  comments_ = 0;
+void Value::initBasic(ValueType type, bool allocated) {
+  setType(type);
+  setIsAllocated(allocated);
+  comments_ = Comments{};
   start_ = 0;
   limit_ = 0;
 }
 
+void Value::dupPayload(const Value& other) {
+  setType(other.type());
+  setIsAllocated(false);
+  switch (type()) {
+  case nullValue:
+  case intValue:
+  case uintValue:
+  case realValue:
+  case booleanValue:
+    value_ = other.value_;
+    break;
+  case stringValue:
+    if (other.value_.string_ && other.isAllocated()) {
+      unsigned len;
+      char const* str;
+      decodePrefixedString(other.isAllocated(), other.value_.string_, &len,
+                           &str);
+      value_.string_ = duplicateAndPrefixStringValue(str, len);
+      setIsAllocated(true);
+    } else {
+      value_.string_ = other.value_.string_;
+    }
+    break;
+  case arrayValue:
+  case objectValue:
+    value_.map_ = new ObjectValues(*other.value_.map_);
+    break;
+  default:
+    JSON_ASSERT_UNREACHABLE;
+  }
+}
+
+void Value::releasePayload() {
+  switch (type()) {
+  case nullValue:
+  case intValue:
+  case uintValue:
+  case realValue:
+  case booleanValue:
+    break;
+  case stringValue:
+    if (isAllocated())
+      releasePrefixedStringValue(value_.string_);
+    break;
+  case arrayValue:
+  case objectValue:
+    delete value_.map_;
+    break;
+  default:
+    JSON_ASSERT_UNREACHABLE;
+  }
+}
+
+void Value::dupMeta(const Value& other) {
+  comments_ = other.comments_;
+  start_ = other.start_;
+  limit_ = other.limit_;
+}
+
 // Access an object value by name, create a null member if it does not exist.
 // @pre Type of '*this' is object or null.
 // @param key is null-terminated.
 Value& Value::resolveReference(const char* key) {
   JSON_ASSERT_MESSAGE(
-      type_ == nullValue || type_ == objectValue,
+      type() == nullValue || type() == objectValue,
       "in Json::Value::resolveReference(): requires objectValue");
-  if (type_ == nullValue)
+  if (type() == nullValue)
     *this = Value(objectValue);
-  CZString actualKey(
-      key, static_cast<unsigned>(strlen(key)), CZString::noDuplication); // NOTE!
-  ObjectValues::iterator it = value_.map_->lower_bound(actualKey);
+  CZString actualKey(key, static_cast<unsigned>(strlen(key)),
+                     CZString::noDuplication); // NOTE!
+  auto it = value_.map_->lower_bound(actualKey);
   if (it != value_.map_->end() && (*it).first == actualKey)
     return (*it).second;
 
@@ -1071,16 +1088,15 @@ Value& Value::resolveReference(const char* key) {
 }
 
 // @param key is not null-terminated.
-Value& Value::resolveReference(char const* key, char const* cend)
-{
+Value& Value::resolveReference(char const* key, char const* end) {
   JSON_ASSERT_MESSAGE(
-      type_ == nullValue || type_ == objectValue,
+      type() == nullValue || type() == objectValue,
       "in Json::Value::resolveReference(key, end): requires objectValue");
-  if (type_ == nullValue)
+  if (type() == nullValue)
     *this = Value(objectValue);
-  CZString actualKey(
-      key, static_cast<unsigned>(cend-key), CZString::duplicateOnCopy);
-  ObjectValues::iterator it = value_.map_->lower_bound(actualKey);
+  CZString actualKey(key, static_cast<unsigned>(end - key),
+                     CZString::duplicateOnCopy);
+  auto it = value_.map_->lower_bound(actualKey);
   if (it != value_.map_->end() && (*it).first == actualKey)
     return (*it).second;
 
@@ -1097,27 +1113,35 @@ Value Value::get(ArrayIndex index, const Value& defaultValue) const {
 
 bool Value::isValidIndex(ArrayIndex index) const { return index < size(); }
 
-Value const* Value::find(char const* key, char const* cend) const
-{
-  JSON_ASSERT_MESSAGE(
-      type_ == nullValue || type_ == objectValue,
-      "in Json::Value::find(key, end, found): requires objectValue or nullValue");
-  if (type_ == nullValue) return NULL;
-  CZString actualKey(key, static_cast<unsigned>(cend-key), CZString::noDuplication);
+Value const* Value::find(char const* begin, char const* end) const {
+  JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,
+                      "in Json::Value::find(begin, end): requires "
+                      "objectValue or nullValue");
+  if (type() == nullValue)
+    return nullptr;
+  CZString actualKey(begin, static_cast<unsigned>(end - begin),
+                     CZString::noDuplication);
   ObjectValues::const_iterator it = value_.map_->find(actualKey);
-  if (it == value_.map_->end()) return NULL;
+  if (it == value_.map_->end())
+    return nullptr;
   return &(*it).second;
 }
-const Value& Value::operator[](const char* key) const
-{
+Value* Value::demand(char const* begin, char const* end) {
+  JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,
+                      "in Json::Value::demand(begin, end): requires "
+                      "objectValue or nullValue");
+  return &resolveReference(begin, end);
+}
+const Value& Value::operator[](const char* key) const {
   Value const* found = find(key, key + strlen(key));
-  if (!found) return nullSingleton();
+  if (!found)
+    return nullSingleton();
   return *found;
 }
-Value const& Value::operator[](JSONCPP_STRING const& key) const
-{
+Value const& Value::operator[](const String& key) const {
   Value const* found = find(key.data(), key.data() + key.length());
-  if (!found) return nullSingleton();
+  if (!found)
+    return nullSingleton();
   return *found;
 }
 
@@ -1125,7 +1149,7 @@ Value& Value::operator[](const char* key) {
   return resolveReference(key, key + strlen(key));
 }
 
-Value& Value::operator[](const JSONCPP_STRING& key) {
+Value& Value::operator[](const String& key) {
   return resolveReference(key.data(), key.data() + key.length());
 }
 
@@ -1137,90 +1161,84 @@ Value& Value::operator[](const StaticString& key) {
 Value& Value::operator[](const CppTL::ConstString& key) {
   return resolveReference(key.c_str(), key.end_c_str());
 }
-Value const& Value::operator[](CppTL::ConstString const& key) const
-{
+Value const& Value::operator[](CppTL::ConstString const& key) const {
   Value const* found = find(key.c_str(), key.end_c_str());
-  if (!found) return nullSingleton();
+  if (!found)
+    return nullSingleton();
   return *found;
 }
 #endif
 
 Value& Value::append(const Value& value) { return (*this)[size()] = value; }
 
-#if JSON_HAS_RVALUE_REFERENCES
-  Value& Value::append(Value&& value) { return (*this)[size()] = std::move(value); }
-#endif
+Value& Value::append(Value&& value) {
+  return (*this)[size()] = std::move(value);
+}
 
-Value Value::get(char const* key, char const* cend, Value const& defaultValue) const
-{
-  Value const* found = find(key, cend);
+Value Value::get(char const* begin,
+                 char const* end,
+                 Value const& defaultValue) const {
+  Value const* found = find(begin, end);
   return !found ? defaultValue : *found;
 }
-Value Value::get(char const* key, Value const& defaultValue) const
-{
+Value Value::get(char const* key, Value const& defaultValue) const {
   return get(key, key + strlen(key), defaultValue);
 }
-Value Value::get(JSONCPP_STRING const& key, Value const& defaultValue) const
-{
+Value Value::get(String const& key, Value const& defaultValue) const {
   return get(key.data(), key.data() + key.length(), defaultValue);
 }
 
-
-bool Value::removeMember(const char* key, const char* cend, Value* removed)
-{
-  if (type_ != objectValue) {
+bool Value::removeMember(const char* begin, const char* end, Value* removed) {
+  if (type() != objectValue) {
     return false;
   }
-  CZString actualKey(key, static_cast<unsigned>(cend-key), CZString::noDuplication);
-  ObjectValues::iterator it = value_.map_->find(actualKey);
+  CZString actualKey(begin, static_cast<unsigned>(end - begin),
+                     CZString::noDuplication);
+  auto it = value_.map_->find(actualKey);
   if (it == value_.map_->end())
     return false;
-  *removed = it->second;
+  if (removed)
+    *removed = std::move(it->second);
   value_.map_->erase(it);
   return true;
 }
-bool Value::removeMember(const char* key, Value* removed)
-{
+bool Value::removeMember(const char* key, Value* removed) {
   return removeMember(key, key + strlen(key), removed);
 }
-bool Value::removeMember(JSONCPP_STRING const& key, Value* removed)
-{
+bool Value::removeMember(String const& key, Value* removed) {
   return removeMember(key.data(), key.data() + key.length(), removed);
 }
-void Value::removeMember(const char* key)
-{
-  JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == objectValue,
+void Value::removeMember(const char* key) {
+  JSON_ASSERT_MESSAGE(type() == nullValue || type() == objectValue,
                       "in Json::Value::removeMember(): requires objectValue");
-  if (type_ == nullValue)
+  if (type() == nullValue)
     return;
 
   CZString actualKey(key, unsigned(strlen(key)), CZString::noDuplication);
   value_.map_->erase(actualKey);
 }
-void Value::removeMember(const JSONCPP_STRING& key)
-{
-  removeMember(key.c_str());
-}
+void Value::removeMember(const String& key) { removeMember(key.c_str()); }
 
 bool Value::removeIndex(ArrayIndex index, Value* removed) {
-  if (type_ != arrayValue) {
+  if (type() != arrayValue) {
     return false;
   }
   CZString key(index);
-  ObjectValues::iterator it = value_.map_->find(key);
+  auto it = value_.map_->find(key);
   if (it == value_.map_->end()) {
     return false;
   }
-  *removed = it->second;
+  if (removed)
+    *removed = it->second;
   ArrayIndex oldSize = size();
   // shift left all items left, into the place of the "removed"
-  for (ArrayIndex i = index; i < (oldSize - 1); ++i){
+  for (ArrayIndex i = index; i < (oldSize - 1); ++i) {
     CZString keey(i);
     (*value_.map_)[keey] = (*this)[i + 1];
   }
   // erase the last one ("leftover")
   CZString keyLast(oldSize - 1);
-  ObjectValues::iterator itLast = value_.map_->find(keyLast);
+  auto itLast = value_.map_->find(keyLast);
   value_.map_->erase(itLast);
   return true;
 }
@@ -1232,17 +1250,14 @@ Value Value::get(const CppTL::ConstString& key,
 }
 #endif
 
-bool Value::isMember(char const* key, char const* cend) const
-{
-  Value const* value = find(key, cend);
-  return NULL != value;
+bool Value::isMember(char const* begin, char const* end) const {
+  Value const* value = find(begin, end);
+  return nullptr != value;
 }
-bool Value::isMember(char const* key) const
-{
+bool Value::isMember(char const* key) const {
   return isMember(key, key + strlen(key));
 }
-bool Value::isMember(JSONCPP_STRING const& key) const
-{
+bool Value::isMember(String const& key) const {
   return isMember(key.data(), key.data() + key.length());
 }
 
@@ -1254,17 +1269,16 @@ bool Value::isMember(const CppTL::ConstString& key) const {
 
 Value::Members Value::getMemberNames() const {
   JSON_ASSERT_MESSAGE(
-      type_ == nullValue || type_ == objectValue,
+      type() == nullValue || type() == objectValue,
       "in Json::Value::getMemberNames(), value must be objectValue");
-  if (type_ == nullValue)
+  if (type() == nullValue)
     return Value::Members();
   Members members;
   members.reserve(value_.map_->size());
   ObjectValues::const_iterator it = value_.map_->begin();
   ObjectValues::const_iterator itEnd = value_.map_->end();
   for (; it != itEnd; ++it) {
-    members.push_back(JSONCPP_STRING((*it).first.data(),
-                                  (*it).first.length()));
+    members.push_back(String((*it).first.data(), (*it).first.length()));
   }
   return members;
 }
@@ -1273,7 +1287,7 @@ Value::Members Value::getMemberNames() const {
 // EnumMemberNames
 // Value::enumMemberNames() const
 //{
-//   if ( type_ == objectValue )
+//   if ( type() == objectValue )
 //   {
 //      return CppTL::Enum::any(  CppTL::Enum::transform(
 //         CppTL::Enum::keys( *(value_.map_), CppTL::Type<const CZString &>() ),
@@ -1286,7 +1300,7 @@ Value::Members Value::getMemberNames() const {
 // EnumValues
 // Value::enumValues() const
 //{
-//   if ( type_ == objectValue  ||  type_ == arrayValue )
+//   if ( type() == objectValue  ||  type() == arrayValue )
 //      return CppTL::Enum::anyValues( *(value_.map_),
 //                                     CppTL::Type<const Value &>() );
 //   return EnumValues();
@@ -1299,12 +1313,12 @@ static bool IsIntegral(double d) {
   return modf(d, &integral_part) == 0.0;
 }
 
-bool Value::isNull() const { return type_ == nullValue; }
+bool Value::isNull() const { return type() == nullValue; }
 
-bool Value::isBool() const { return type_ == booleanValue; }
+bool Value::isBool() const { return type() == booleanValue; }
 
 bool Value::isInt() const {
-  switch (type_) {
+  switch (type()) {
   case intValue:
 #if defined(JSON_HAS_INT64)
     return value_.int_ >= minInt && value_.int_ <= maxInt;
@@ -1323,7 +1337,7 @@ bool Value::isInt() const {
 }
 
 bool Value::isUInt() const {
-  switch (type_) {
+  switch (type()) {
   case intValue:
 #if defined(JSON_HAS_INT64)
     return value_.int_ >= 0 && LargestUInt(value_.int_) <= LargestUInt(maxUInt);
@@ -1347,7 +1361,7 @@ bool Value::isUInt() const {
 
 bool Value::isInt64() const {
 #if defined(JSON_HAS_INT64)
-  switch (type_) {
+  switch (type()) {
   case intValue:
     return true;
   case uintValue:
@@ -1367,7 +1381,7 @@ bool Value::isInt64() const {
 
 bool Value::isUInt64() const {
 #if defined(JSON_HAS_INT64)
-  switch (type_) {
+  switch (type()) {
   case intValue:
     return value_.int_ >= 0;
   case uintValue:
@@ -1386,61 +1400,90 @@ bool Value::isUInt64() const {
 }
 
 bool Value::isIntegral() const {
-  switch (type_) {
-    case intValue:
-    case uintValue:
-      return true;
-    case realValue:
+  switch (type()) {
+  case intValue:
+  case uintValue:
+    return true;
+  case realValue:
 #if defined(JSON_HAS_INT64)
-      // Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
-      // double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
-      // require the value to be strictly less than the limit.
-      return value_.real_ >= double(minInt64) && value_.real_ < maxUInt64AsDouble && IsIntegral(value_.real_);
+    // Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
+    // double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
+    // require the value to be strictly less than the limit.
+    return value_.real_ >= double(minInt64) &&
+           value_.real_ < maxUInt64AsDouble && IsIntegral(value_.real_);
 #else
-      return value_.real_ >= minInt && value_.real_ <= maxUInt && IsIntegral(value_.real_);
+    return value_.real_ >= minInt && value_.real_ <= maxUInt &&
+           IsIntegral(value_.real_);
 #endif // JSON_HAS_INT64
-    default:
-      break;
+  default:
+    break;
   }
   return false;
 }
 
-bool Value::isDouble() const { return type_ == intValue || type_ == uintValue || type_ == realValue; }
+bool Value::isDouble() const {
+  return type() == intValue || type() == uintValue || type() == realValue;
+}
 
 bool Value::isNumeric() const { return isDouble(); }
 
-bool Value::isString() const { return type_ == stringValue; }
+bool Value::isString() const { return type() == stringValue; }
 
-bool Value::isArray() const { return type_ == arrayValue; }
+bool Value::isArray() const { return type() == arrayValue; }
 
-bool Value::isObject() const { return type_ == objectValue; }
+bool Value::isObject() const { return type() == objectValue; }
 
-void Value::setComment(const char* comment, size_t len, CommentPlacement placement) {
-  if (!comments_)
-    comments_ = new CommentInfo[numberOfCommentPlacement];
-  if ((len > 0) && (comment[len-1] == '\n')) {
-    // Always discard trailing newline, to aid indentation.
-    len -= 1;
-  }
-  comments_[placement].setComment(comment, len);
+Value::Comments::Comments(const Comments& that)
+    : ptr_{cloneUnique(that.ptr_)} {}
+
+Value::Comments::Comments(Comments&& that)
+    : ptr_{std::move(that.ptr_)} {}
+
+Value::Comments& Value::Comments::operator=(const Comments& that) {
+  ptr_ = cloneUnique(that.ptr_);
+  return *this;
 }
 
-void Value::setComment(const char* comment, CommentPlacement placement) {
-  setComment(comment, strlen(comment), placement);
+Value::Comments& Value::Comments::operator=(Comments&& that) {
+  ptr_ = std::move(that.ptr_);
+  return *this;
 }
 
-void Value::setComment(const JSONCPP_STRING& comment, CommentPlacement placement) {
-  setComment(comment.c_str(), comment.length(), placement);
+bool Value::Comments::has(CommentPlacement slot) const {
+  return ptr_ && !(*ptr_)[slot].empty();
+}
+
+String Value::Comments::get(CommentPlacement slot) const {
+  if (!ptr_)
+    return {};
+  return (*ptr_)[slot];
+}
+
+void Value::Comments::set(CommentPlacement slot, String comment) {
+  if (!ptr_) {
+    ptr_ = std::unique_ptr<Array>(new Array());
+  }
+  (*ptr_)[slot] = std::move(comment);
+}
+
+void Value::setComment(String comment, CommentPlacement placement) {
+  if (!comment.empty() && (comment.back() == '\n')) {
+    // Always discard trailing newline, to aid indentation.
+    comment.pop_back();
+  }
+  JSON_ASSERT(!comment.empty());
+  JSON_ASSERT_MESSAGE(
+      comment[0] == '\0' || comment[0] == '/',
+      "in Json::Value::setComment(): Comments must start with /");
+  comments_.set(placement, std::move(comment));
 }
 
 bool Value::hasComment(CommentPlacement placement) const {
-  return comments_ != 0 && comments_[placement].comment_ != 0;
+  return comments_.has(placement);
 }
 
-JSONCPP_STRING Value::getComment(CommentPlacement placement) const {
-  if (hasComment(placement))
-    return comments_[placement].comment_;
-  return "";
+String Value::getComment(CommentPlacement placement) const {
+  return comments_.get(placement);
 }
 
 void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }
@@ -1451,18 +1494,18 @@ ptrdiff_t Value::getOffsetStart() const { return start_; }
 
 ptrdiff_t Value::getOffsetLimit() const { return limit_; }
 
-JSONCPP_STRING Value::toStyledString() const {
+String Value::toStyledString() const {
   StreamWriterBuilder builder;
 
-  JSONCPP_STRING out = this->hasComment(commentBefore) ? "\n" : "";
+  String out = this->hasComment(commentBefore) ? "\n" : "";
   out += Json::writeString(builder, *this);
-  out += "\n";
+  out += '\n';
 
   return out;
 }
 
 Value::const_iterator Value::begin() const {
-  switch (type_) {
+  switch (type()) {
   case arrayValue:
   case objectValue:
     if (value_.map_)
@@ -1471,11 +1514,11 @@ Value::const_iterator Value::begin() const {
   default:
     break;
   }
-  return const_iterator();
+  return {};
 }
 
 Value::const_iterator Value::end() const {
-  switch (type_) {
+  switch (type()) {
   case arrayValue:
   case objectValue:
     if (value_.map_)
@@ -1484,11 +1527,11 @@ Value::const_iterator Value::end() const {
   default:
     break;
   }
-  return const_iterator();
+  return {};
 }
 
 Value::iterator Value::begin() {
-  switch (type_) {
+  switch (type()) {
   case arrayValue:
   case objectValue:
     if (value_.map_)
@@ -1501,7 +1544,7 @@ Value::iterator Value::begin() {
 }
 
 Value::iterator Value::end() {
-  switch (type_) {
+  switch (type()) {
   case arrayValue:
   case objectValue:
     if (value_.map_)
@@ -1516,7 +1559,7 @@ Value::iterator Value::end() {
 // class PathArgument
 // //////////////////////////////////////////////////////////////////
 
-PathArgument::PathArgument() : key_(), index_(), kind_(kindNone) {}
+PathArgument::PathArgument() : key_() {}
 
 PathArgument::PathArgument(ArrayIndex index)
     : key_(), index_(index), kind_(kindIndex) {}
@@ -1524,13 +1567,13 @@ PathArgument::PathArgument(ArrayIndex index)
 PathArgument::PathArgument(const char* key)
     : key_(key), index_(), kind_(kindKey) {}
 
-PathArgument::PathArgument(const JSONCPP_STRING& key)
+PathArgument::PathArgument(const String& key)
     : key_(key.c_str()), index_(), kind_(kindKey) {}
 
 // class Path
 // //////////////////////////////////////////////////////////////////
 
-Path::Path(const JSONCPP_STRING& path,
+Path::Path(const String& path,
            const PathArgument& a1,
            const PathArgument& a2,
            const PathArgument& a3,
@@ -1546,10 +1589,10 @@ Path::Path(const JSONCPP_STRING& path,
   makePath(path, in);
 }
 
-void Path::makePath(const JSONCPP_STRING& path, const InArgs& in) {
+void Path::makePath(const String& path, const InArgs& in) {
   const char* current = path.c_str();
   const char* end = current + path.length();
-  InArgs::const_iterator itInArg = in.begin();
+  auto itInArg = in.begin();
   while (current != end) {
     if (*current == '[') {
       ++current;
@@ -1572,12 +1615,12 @@ void Path::makePath(const JSONCPP_STRING& path, const InArgs& in) {
       const char* beginName = current;
       while (current != end && !strchr("[.", *current))
         ++current;
-      args_.push_back(JSONCPP_STRING(beginName, current));
+      args_.push_back(String(beginName, current));
     }
   }
 }
 
-void Path::addPathInArg(const JSONCPP_STRING& /*path*/,
+void Path::addPathInArg(const String& /*path*/,
                         const InArgs& in,
                         InArgs::const_iterator& itInArg,
                         PathArgument::Kind kind) {
@@ -1590,14 +1633,13 @@ void Path::addPathInArg(const JSONCPP_STRING& /*path*/,
   }
 }
 
-void Path::invalidPath(const JSONCPP_STRING& /*path*/, int /*location*/) {
+void Path::invalidPath(const String& /*path*/, int /*location*/) {
   // Error: invalid path.
 }
 
 const Value& Path::resolve(const Value& root) const {
   const Value* node = &root;
-  for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
-    const PathArgument& arg = *it;
+  for (const auto& arg : args_) {
     if (arg.kind_ == PathArgument::kindIndex) {
       if (!node->isArray() || !node->isValidIndex(arg.index_)) {
         // Error: unable to resolve path (array value expected at position...
@@ -1622,8 +1664,7 @@ const Value& Path::resolve(const Value& root) const {
 
 Value Path::resolve(const Value& root, const Value& defaultValue) const {
   const Value* node = &root;
-  for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
-    const PathArgument& arg = *it;
+  for (const auto& arg : args_) {
     if (arg.kind_ == PathArgument::kindIndex) {
       if (!node->isArray() || !node->isValidIndex(arg.index_))
         return defaultValue;
@@ -1641,8 +1682,7 @@ Value Path::resolve(const Value& root, const Value& defaultValue) const {
 
 Value& Path::make(Value& root) const {
   Value* node = &root;
-  for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
-    const PathArgument& arg = *it;
+  for (const auto& arg : args_) {
     if (arg.kind_ == PathArgument::kindIndex) {
       if (!node->isArray()) {
         // Error: node is not an array at position ...
diff --git a/src/lib_json/json_valueiterator.inl b/src/lib_json/json_valueiterator.inl
index 5243bfe..4a3d210 100644
--- a/src/lib_json/json_valueiterator.inl
+++ b/src/lib_json/json_valueiterator.inl
@@ -15,25 +15,17 @@ namespace Json {
 // //////////////////////////////////////////////////////////////////
 // //////////////////////////////////////////////////////////////////
 
-ValueIteratorBase::ValueIteratorBase()
-    : current_(), isNull_(true) {
-}
+ValueIteratorBase::ValueIteratorBase() : current_() {}
 
 ValueIteratorBase::ValueIteratorBase(
     const Value::ObjectValues::iterator& current)
     : current_(current), isNull_(false) {}
 
-Value& ValueIteratorBase::deref() const {
-  return current_->second;
-}
+Value& ValueIteratorBase::deref() const { return current_->second; }
 
-void ValueIteratorBase::increment() {
-  ++current_;
-}
+void ValueIteratorBase::increment() { ++current_; }
 
-void ValueIteratorBase::decrement() {
-  --current_;
-}
+void ValueIteratorBase::decrement() { --current_; }
 
 ValueIteratorBase::difference_type
 ValueIteratorBase::computeDistance(const SelfType& other) const {
@@ -92,12 +84,13 @@ UInt ValueIteratorBase::index() const {
   return Value::UInt(-1);
 }
 
-JSONCPP_STRING ValueIteratorBase::name() const {
+String ValueIteratorBase::name() const {
   char const* keey;
   char const* end;
   keey = memberName(&end);
-  if (!keey) return JSONCPP_STRING();
-  return JSONCPP_STRING(keey, end);
+  if (!keey)
+    return String();
+  return String(keey, end);
 }
 
 char const* ValueIteratorBase::memberName() const {
@@ -108,8 +101,8 @@ char const* ValueIteratorBase::memberName() const {
 char const* ValueIteratorBase::memberName(char const** end) const {
   const char* cname = (*current_).first.data();
   if (!cname) {
-    *end = NULL;
-    return NULL;
+    *end = nullptr;
+    return nullptr;
   }
   *end = cname + (*current_).first.length();
   return cname;
@@ -123,7 +116,7 @@ char const* ValueIteratorBase::memberName(char const** end) const {
 // //////////////////////////////////////////////////////////////////
 // //////////////////////////////////////////////////////////////////
 
-ValueConstIterator::ValueConstIterator() {}
+ValueConstIterator::ValueConstIterator() = default;
 
 ValueConstIterator::ValueConstIterator(
     const Value::ObjectValues::iterator& current)
@@ -146,7 +139,7 @@ operator=(const ValueIteratorBase& other) {
 // //////////////////////////////////////////////////////////////////
 // //////////////////////////////////////////////////////////////////
 
-ValueIterator::ValueIterator() {}
+ValueIterator::ValueIterator() = default;
 
 ValueIterator::ValueIterator(const Value::ObjectValues::iterator& current)
     : ValueIteratorBase(current) {}
@@ -156,8 +149,7 @@ ValueIterator::ValueIterator(const ValueConstIterator& other)
   throwRuntimeError("ConstIterator to Iterator should never be allowed.");
 }
 
-ValueIterator::ValueIterator(const ValueIterator& other)
-    : ValueIteratorBase(other) {}
+ValueIterator::ValueIterator(const ValueIterator& other) = default;
 
 ValueIterator& ValueIterator::operator=(const SelfType& other) {
   copy(other);
diff --git a/src/lib_json/json_writer.cpp b/src/lib_json/json_writer.cpp
index 5ffaa15..41dfd8c 100644
--- a/src/lib_json/json_writer.cpp
+++ b/src/lib_json/json_writer.cpp
@@ -4,71 +4,79 @@
 // See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE
 
 #if !defined(JSON_IS_AMALGAMATION)
-#include <json/writer.h>
 #include "json_tool.h"
+#include <json/writer.h>
 #endif // if !defined(JSON_IS_AMALGAMATION)
+#include <cassert>
+#include <cstring>
 #include <iomanip>
 #include <memory>
+#include <set>
 #include <sstream>
 #include <utility>
-#include <set>
-#include <cassert>
-#include <cstring>
+
+#if __cplusplus >= 201103L
+#include <cmath>
+#include <cstdio>
+
+#if !defined(isnan)
+#define isnan std::isnan
+#endif
+
+#if !defined(isfinite)
+#define isfinite std::isfinite
+#endif
+
+#else
+#include <cmath>
 #include <cstdio>
 
-#if defined(_MSC_VER) && _MSC_VER >= 1200 && _MSC_VER < 1800 // Between VC++ 6.0 and VC++ 11.0
+#if defined(_MSC_VER)
+#if !defined(isnan)
+#include <float.h>
+#define isnan _isnan
+#endif
+
+#if !defined(isfinite)
 #include <float.h>
 #define isfinite _finite
-#elif defined(__sun) && defined(__SVR4) //Solaris
+#endif
+
+#if !defined(_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES)
+#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 1
+#endif //_CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES
+
+#endif //_MSC_VER
+
+#if defined(__sun) && defined(__SVR4) // Solaris
 #if !defined(isfinite)
 #include <ieeefp.h>
 #define isfinite finite
 #endif
-#elif defined(_AIX)
-#if !defined(isfinite)
-#include <math.h>
-#define isfinite finite
 #endif
-#elif defined(__hpux)
+
+#if defined(__hpux)
 #if !defined(isfinite)
 #if defined(__ia64) && !defined(finite)
-#define isfinite(x) ((sizeof(x) == sizeof(float) ? \
-                     _Isfinitef(x) : _IsFinite(x)))
-#else
-#include <math.h>
-#define isfinite finite
+#define isfinite(x)                                                            \
+  ((sizeof(x) == sizeof(float) ? _Isfinitef(x) : _IsFinite(x)))
 #endif
 #endif
-#else
-#include <cmath>
-#if !(defined(__QNXNTO__)) // QNX already defines isfinite
-#define isfinite std::isfinite
 #endif
+
+#if !defined(isnan)
+// IEEE standard states that NaN values will not compare to themselves
+#define isnan(x) (x != x)
 #endif
 
-#if defined(_MSC_VER)
-#if !defined(WINCE) && defined(__STDC_SECURE_LIB__) && _MSC_VER >= 1500 // VC++ 9.0 and above
-#define snprintf sprintf_s
-#elif _MSC_VER >= 1900 // VC++ 14.0 and above
-#define snprintf std::snprintf
-#else
-#define snprintf _snprintf
+#if !defined(__APPLE__)
+#if !defined(isfinite)
+#define isfinite finite
 #endif
-#elif defined(__ANDROID__) || defined(__QNXNTO__)
-#define snprintf snprintf
-#elif __cplusplus >= 201103L
-#if !defined(__MINGW32__) && !defined(__CYGWIN__)
-#define snprintf std::snprintf
 #endif
 #endif
 
-#if defined(__BORLANDC__)  
-#include <float.h>
-#define isfinite _finite
-#define snprintf _snprintf
-#endif
-
-#if defined(_MSC_VER) && _MSC_VER >= 1400 // VC++ 8.0
+#if defined(_MSC_VER)
 // Disable warning about strdup being deprecated.
 #pragma warning(disable : 4996)
 #endif
@@ -78,10 +86,10 @@ namespace Json {
 #if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER >= 520)
 typedef std::unique_ptr<StreamWriter> StreamWriterPtr;
 #else
-typedef std::auto_ptr<StreamWriter>   StreamWriterPtr;
+typedef std::auto_ptr<StreamWriter> StreamWriterPtr;
 #endif
 
-JSONCPP_STRING valueToString(LargestInt value) {
+String valueToString(LargestInt value) {
   UIntToStringBuffer buffer;
   char* current = buffer + sizeof(buffer);
   if (value == Value::minLargestInt) {
@@ -97,7 +105,7 @@ JSONCPP_STRING valueToString(LargestInt value) {
   return current;
 }
 
-JSONCPP_STRING valueToString(LargestUInt value) {
+String valueToString(LargestUInt value) {
   UIntToStringBuffer buffer;
   char* current = buffer + sizeof(buffer);
   uintToString(value, current);
@@ -107,64 +115,74 @@ JSONCPP_STRING valueToString(LargestUInt value) {
 
 #if defined(JSON_HAS_INT64)
 
-JSONCPP_STRING valueToString(Int value) {
-  return valueToString(LargestInt(value));
-}
+String valueToString(Int value) { return valueToString(LargestInt(value)); }
 
-JSONCPP_STRING valueToString(UInt value) {
-  return valueToString(LargestUInt(value));
-}
+String valueToString(UInt value) { return valueToString(LargestUInt(value)); }
 
 #endif // # if defined(JSON_HAS_INT64)
 
 namespace {
-JSONCPP_STRING valueToString(double value, bool useSpecialFloats, unsigned int precision) {
-  // Allocate a buffer that is more than large enough to store the 16 digits of
-  // precision requested below.
-  char buffer[36];
-  int len = -1;
-
-  char formatString[15];
-  snprintf(formatString, sizeof(formatString), "%%.%ug", precision);
-
+String valueToString(double value,
+                     bool useSpecialFloats,
+                     unsigned int precision,
+                     PrecisionType precisionType) {
   // Print into the buffer. We need not request the alternative representation
   // that always has a decimal point because JSON doesn't distinguish the
   // concepts of reals and integers.
-  if (isfinite(value)) {
-    len = snprintf(buffer, sizeof(buffer), formatString, value);
-    fixNumericLocale(buffer, buffer + len);
+  if (!isfinite(value)) {
+    static const char* const reps[2][3] = {{"NaN", "-Infinity", "Infinity"},
+                                           {"null", "-1e+9999", "1e+9999"}};
+    return reps[useSpecialFloats ? 0 : 1]
+               [isnan(value) ? 0 : (value < 0) ? 1 : 2];
+  }
 
-    // try to ensure we preserve the fact that this was given to us as a double on input
-    if (!strchr(buffer, '.') && !strchr(buffer, 'e')) {
-      strcat(buffer, ".0");
+  String buffer(size_t(36), '\0');
+  while (true) {
+    int len = jsoncpp_snprintf(
+        &*buffer.begin(), buffer.size(),
+        (precisionType == PrecisionType::significantDigits) ? "%.*g" : "%.*f",
+        precision, value);
+    assert(len >= 0);
+    auto wouldPrint = static_cast<size_t>(len);
+    if (wouldPrint >= buffer.size()) {
+      buffer.resize(wouldPrint + 1);
+      continue;
     }
+    buffer.resize(wouldPrint);
+    break;
+  }
 
-  } else {
-    // IEEE standard states that NaN values will not compare to themselves
-    if (value != value) {
-      len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "NaN" : "null");
-    } else if (value < 0) {
-      len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "-Infinity" : "-1e+9999");
-    } else {
-      len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "Infinity" : "1e+9999");
-    }
+  buffer.erase(fixNumericLocale(buffer.begin(), buffer.end()), buffer.end());
+
+  // strip the zero padding from the right
+  if (precisionType == PrecisionType::decimalPlaces) {
+    buffer.erase(fixZerosInTheEnd(buffer.begin(), buffer.end()), buffer.end());
+  }
+
+  // try to ensure we preserve the fact that this was given to us as a double on
+  // input
+  if (buffer.find('.') == buffer.npos && buffer.find('e') == buffer.npos) {
+    buffer += ".0";
   }
-  assert(len >= 0);
   return buffer;
 }
-}
+} // namespace
 
-JSONCPP_STRING valueToString(double value) { return valueToString(value, false, 17); }
+String valueToString(double value,
+                     unsigned int precision,
+                     PrecisionType precisionType) {
+  return valueToString(value, false, precision, precisionType);
+}
 
-JSONCPP_STRING valueToString(bool value) { return value ? "true" : "false"; }
+String valueToString(bool value) { return value ? "true" : "false"; }
 
 static bool isAnyCharRequiredQuoting(char const* s, size_t n) {
   assert(s || !n);
 
   char const* const end = s + n;
   for (char const* cur = s; cur < end; ++cur) {
-    if (*cur == '\\' || *cur == '\"' || *cur < ' '
-      || static_cast<unsigned char>(*cur) < 0x80)
+    if (*cur == '\\' || *cur == '\"' || *cur < ' ' ||
+        static_cast<unsigned char>(*cur) < 0x80)
       return true;
   }
   return false;
@@ -182,8 +200,8 @@ static unsigned int utf8ToCodepoint(const char*& s, const char* e) {
     if (e - s < 2)
       return REPLACEMENT_CHARACTER;
 
-    unsigned int calculated = ((firstByte & 0x1F) << 6)
-      | (static_cast<unsigned int>(s[1]) & 0x3F);
+    unsigned int calculated =
+        ((firstByte & 0x1F) << 6) | (static_cast<unsigned int>(s[1]) & 0x3F);
     s += 1;
     // oversized encoded characters are invalid
     return calculated < 0x80 ? REPLACEMENT_CHARACTER : calculated;
@@ -193,9 +211,9 @@ static unsigned int utf8ToCodepoint(const char*& s, const char* e) {
     if (e - s < 3)
       return REPLACEMENT_CHARACTER;
 
-    unsigned int calculated = ((firstByte & 0x0F) << 12)
-      | ((static_cast<unsigned int>(s[1]) & 0x3F) << 6)
-      |  (static_cast<unsigned int>(s[2]) & 0x3F);
+    unsigned int calculated = ((firstByte & 0x0F) << 12) |
+                              ((static_cast<unsigned int>(s[1]) & 0x3F) << 6) |
+                              (static_cast<unsigned int>(s[2]) & 0x3F);
     s += 2;
     // surrogates aren't valid codepoints itself
     // shouldn't be UTF-8 encoded
@@ -209,10 +227,10 @@ static unsigned int utf8ToCodepoint(const char*& s, const char* e) {
     if (e - s < 4)
       return REPLACEMENT_CHARACTER;
 
-    unsigned int calculated = ((firstByte & 0x07) << 24)
-      | ((static_cast<unsigned int>(s[1]) & 0x3F) << 12)
-      | ((static_cast<unsigned int>(s[2]) & 0x3F) << 6)
-      |  (static_cast<unsigned int>(s[3]) & 0x3F);
+    unsigned int calculated = ((firstByte & 0x07) << 18) |
+                              ((static_cast<unsigned int>(s[1]) & 0x3F) << 12) |
+                              ((static_cast<unsigned int>(s[2]) & 0x3F) << 6) |
+                              (static_cast<unsigned int>(s[3]) & 0x3F);
     s += 3;
     // oversized encoded characters are invalid
     return calculated < 0x10000 ? REPLACEMENT_CHARACTER : calculated;
@@ -221,28 +239,27 @@ static unsigned int utf8ToCodepoint(const char*& s, const char* e) {
   return REPLACEMENT_CHARACTER;
 }
 
-static const char hex2[] =
-  "000102030405060708090a0b0c0d0e0f"
-  "101112131415161718191a1b1c1d1e1f"
-  "202122232425262728292a2b2c2d2e2f"
-  "303132333435363738393a3b3c3d3e3f"
-  "404142434445464748494a4b4c4d4e4f"
-  "505152535455565758595a5b5c5d5e5f"
-  "606162636465666768696a6b6c6d6e6f"
-  "707172737475767778797a7b7c7d7e7f"
-  "808182838485868788898a8b8c8d8e8f"
-  "909192939495969798999a9b9c9d9e9f"
-  "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
-  "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
-  "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
-  "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
-  "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
-  "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
-
-static JSONCPP_STRING toHex16Bit(unsigned int x) {
+static const char hex2[] = "000102030405060708090a0b0c0d0e0f"
+                           "101112131415161718191a1b1c1d1e1f"
+                           "202122232425262728292a2b2c2d2e2f"
+                           "303132333435363738393a3b3c3d3e3f"
+                           "404142434445464748494a4b4c4d4e4f"
+                           "505152535455565758595a5b5c5d5e5f"
+                           "606162636465666768696a6b6c6d6e6f"
+                           "707172737475767778797a7b7c7d7e7f"
+                           "808182838485868788898a8b8c8d8e8f"
+                           "909192939495969798999a9b9c9d9e9f"
+                           "a0a1a2a3a4a5a6a7a8a9aaabacadaeaf"
+                           "b0b1b2b3b4b5b6b7b8b9babbbcbdbebf"
+                           "c0c1c2c3c4c5c6c7c8c9cacbcccdcecf"
+                           "d0d1d2d3d4d5d6d7d8d9dadbdcdddedf"
+                           "e0e1e2e3e4e5e6e7e8e9eaebecedeeef"
+                           "f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff";
+
+static String toHex16Bit(unsigned int x) {
   const unsigned int hi = (x >> 8) & 0xff;
   const unsigned int lo = x & 0xff;
-  JSONCPP_STRING result(4, ' ');
+  String result(4, ' ');
   result[0] = hex2[2 * hi];
   result[1] = hex2[2 * hi + 1];
   result[2] = hex2[2 * lo];
@@ -250,18 +267,17 @@ static JSONCPP_STRING toHex16Bit(unsigned int x) {
   return result;
 }
 
-static JSONCPP_STRING valueToQuotedStringN(const char* value, unsigned length) {
-  if (value == NULL)
+static String valueToQuotedStringN(const char* value, unsigned length) {
+  if (value == nullptr)
     return "";
 
   if (!isAnyCharRequiredQuoting(value, length))
-    return JSONCPP_STRING("\"") + value + "\"";
+    return String("\"") + value + "\"";
   // We have to walk value and escape any special characters.
-  // Appending to JSONCPP_STRING is not efficient, but this should be rare.
+  // Appending to String is not efficient, but this should be rare.
   // (Note: forward slashes are *not* rare, but I am not escaping them.)
-  JSONCPP_STRING::size_type maxsize =
-      length * 2 + 3; // allescaped+quotes+NULL
-  JSONCPP_STRING result;
+  String::size_type maxsize = length * 2 + 3; // allescaped+quotes+NULL
+  String result;
   result.reserve(maxsize); // to avoid lots of mallocs
   result += "\"";
   char const* end = value + length;
@@ -297,45 +313,43 @@ static JSONCPP_STRING valueToQuotedStringN(const char* value, unsigned length) {
     // Should add a flag to allow this compatibility mode and prevent this
     // sequence from occurring.
     default: {
-        unsigned int cp = utf8ToCodepoint(c, end);
-        // don't escape non-control characters
-        // (short escape sequence are applied above)
-        if (cp < 0x80 && cp >= 0x20)
-          result += static_cast<char>(cp);
-        else if (cp < 0x10000) { // codepoint is in Basic Multilingual Plane
-          result += "\\u";
-          result += toHex16Bit(cp);
-        }
-        else { // codepoint is not in Basic Multilingual Plane
+      unsigned int cp = utf8ToCodepoint(c, end);
+      // don't escape non-control characters
+      // (short escape sequence are applied above)
+      if (cp < 0x80 && cp >= 0x20)
+        result += static_cast<char>(cp);
+      else if (cp < 0x10000) { // codepoint is in Basic Multilingual Plane
+        result += "\\u";
+        result += toHex16Bit(cp);
+      } else { // codepoint is not in Basic Multilingual Plane
                // convert to surrogate pair first
-          cp -= 0x10000;
-          result += "\\u";
-          result += toHex16Bit((cp >> 10) + 0xD800);
-          result += "\\u";
-          result += toHex16Bit((cp & 0x3FF) + 0xDC00);
-        }
+        cp -= 0x10000;
+        result += "\\u";
+        result += toHex16Bit((cp >> 10) + 0xD800);
+        result += "\\u";
+        result += toHex16Bit((cp & 0x3FF) + 0xDC00);
       }
-      break;
+    } break;
     }
   }
   result += "\"";
   return result;
 }
 
-JSONCPP_STRING valueToQuotedString(const char* value) {
+String valueToQuotedString(const char* value) {
   return valueToQuotedStringN(value, static_cast<unsigned int>(strlen(value)));
 }
 
 // Class Writer
 // //////////////////////////////////////////////////////////////////
-Writer::~Writer() {}
+Writer::~Writer() = default;
 
 // Class FastWriter
 // //////////////////////////////////////////////////////////////////
 
 FastWriter::FastWriter()
-    : yamlCompatibilityEnabled_(false), dropNullPlaceholders_(false),
-      omitEndingLineFeed_(false) {}
+
+    = default;
 
 void FastWriter::enableYAMLCompatibility() { yamlCompatibilityEnabled_ = true; }
 
@@ -343,11 +357,11 @@ void FastWriter::dropNullPlaceholders() { dropNullPlaceholders_ = true; }
 
 void FastWriter::omitEndingLineFeed() { omitEndingLineFeed_ = true; }
 
-JSONCPP_STRING FastWriter::write(const Value& root) {
+String FastWriter::write(const Value& root) {
   document_.clear();
   writeValue(root);
   if (!omitEndingLineFeed_)
-    document_ += "\n";
+    document_ += '\n';
   return document_;
 }
 
@@ -366,13 +380,13 @@ void FastWriter::writeValue(const Value& value) {
   case realValue:
     document_ += valueToString(value.asDouble());
     break;
-  case stringValue:
-  {
+  case stringValue: {
     // Is NULL possible for value.string_? No.
     char const* str;
     char const* end;
     bool ok = value.getString(&str, &end);
-    if (ok) document_ += valueToQuotedStringN(str, static_cast<unsigned>(end-str));
+    if (ok)
+      document_ += valueToQuotedStringN(str, static_cast<unsigned>(end - str));
     break;
   }
   case booleanValue:
@@ -391,12 +405,12 @@ void FastWriter::writeValue(const Value& value) {
   case objectValue: {
     Value::Members members(value.getMemberNames());
     document_ += '{';
-    for (Value::Members::iterator it = members.begin(); it != members.end();
-         ++it) {
-      const JSONCPP_STRING& name = *it;
+    for (auto it = members.begin(); it != members.end(); ++it) {
+      const String& name = *it;
       if (it != members.begin())
         document_ += ',';
-      document_ += valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length()));
+      document_ += valueToQuotedStringN(name.data(),
+                                        static_cast<unsigned>(name.length()));
       document_ += yamlCompatibilityEnabled_ ? ": " : ":";
       writeValue(value[name]);
     }
@@ -408,17 +422,16 @@ void FastWriter::writeValue(const Value& value) {
 // Class StyledWriter
 // //////////////////////////////////////////////////////////////////
 
-StyledWriter::StyledWriter()
-    : rightMargin_(74), indentSize_(3), addChildValues_() {}
+StyledWriter::StyledWriter() = default;
 
-JSONCPP_STRING StyledWriter::write(const Value& root) {
+String StyledWriter::write(const Value& root) {
   document_.clear();
   addChildValues_ = false;
   indentString_.clear();
   writeCommentBeforeValue(root);
   writeValue(root);
   writeCommentAfterValueOnSameLine(root);
-  document_ += "\n";
+  document_ += '\n';
   return document_;
 }
 
@@ -436,14 +449,15 @@ void StyledWriter::writeValue(const Value& value) {
   case realValue:
     pushValue(valueToString(value.asDouble()));
     break;
-  case stringValue:
-  {
+  case stringValue: {
     // Is NULL possible for value.string_? No.
     char const* str;
     char const* end;
     bool ok = value.getString(&str, &end);
-    if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));
-    else pushValue("");
+    if (ok)
+      pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str)));
+    else
+      pushValue("");
     break;
   }
   case booleanValue:
@@ -459,9 +473,9 @@ void StyledWriter::writeValue(const Value& value) {
     else {
       writeWithIndent("{");
       indent();
-      Value::Members::iterator it = members.begin();
+      auto it = members.begin();
       for (;;) {
-        const JSONCPP_STRING& name = *it;
+        const String& name = *it;
         const Value& childValue = value[name];
         writeCommentBeforeValue(childValue);
         writeWithIndent(valueToQuotedString(name.c_str()));
@@ -531,7 +545,7 @@ bool StyledWriter::isMultilineArray(const Value& value) {
   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
     const Value& childValue = value[index];
     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
-                        childValue.size() > 0);
+                   !childValue.empty());
   }
   if (!isMultiLine) // check if line length > max line length
   {
@@ -551,7 +565,7 @@ bool StyledWriter::isMultilineArray(const Value& value) {
   return isMultiLine;
 }
 
-void StyledWriter::pushValue(const JSONCPP_STRING& value) {
+void StyledWriter::pushValue(const String& value) {
   if (addChildValues_)
     childValues_.push_back(value);
   else
@@ -569,12 +583,12 @@ void StyledWriter::writeIndent() {
   document_ += indentString_;
 }
 
-void StyledWriter::writeWithIndent(const JSONCPP_STRING& value) {
+void StyledWriter::writeWithIndent(const String& value) {
   writeIndent();
   document_ += value;
 }
 
-void StyledWriter::indent() { indentString_ += JSONCPP_STRING(indentSize_, ' '); }
+void StyledWriter::indent() { indentString_ += String(indentSize_, ' '); }
 
 void StyledWriter::unindent() {
   assert(indentString_.size() >= indentSize_);
@@ -585,20 +599,19 @@ void StyledWriter::writeCommentBeforeValue(const Value& root) {
   if (!root.hasComment(commentBefore))
     return;
 
-  document_ += "\n";
+  document_ += '\n';
   writeIndent();
-  const JSONCPP_STRING& comment = root.getComment(commentBefore);
-  JSONCPP_STRING::const_iterator iter = comment.begin();
+  const String& comment = root.getComment(commentBefore);
+  String::const_iterator iter = comment.begin();
   while (iter != comment.end()) {
     document_ += *iter;
-    if (*iter == '\n' &&
-       ((iter+1) != comment.end() && *(iter + 1) == '/'))
+    if (*iter == '\n' && ((iter + 1) != comment.end() && *(iter + 1) == '/'))
       writeIndent();
     ++iter;
   }
 
   // Comments are stripped of trailing newlines, so add one here
-  document_ += "\n";
+  document_ += '\n';
 }
 
 void StyledWriter::writeCommentAfterValueOnSameLine(const Value& root) {
@@ -606,9 +619,9 @@ void StyledWriter::writeCommentAfterValueOnSameLine(const Value& root) {
     document_ += " " + root.getComment(commentAfterOnSameLine);
 
   if (root.hasComment(commentAfter)) {
-    document_ += "\n";
+    document_ += '\n';
     document_ += root.getComment(commentAfter);
-    document_ += "\n";
+    document_ += '\n';
   }
 }
 
@@ -621,22 +634,23 @@ bool StyledWriter::hasCommentForValue(const Value& value) {
 // Class StyledStreamWriter
 // //////////////////////////////////////////////////////////////////
 
-StyledStreamWriter::StyledStreamWriter(JSONCPP_STRING indentation)
-    : document_(NULL), rightMargin_(74), indentation_(indentation),
-      addChildValues_() {}
+StyledStreamWriter::StyledStreamWriter(String indentation)
+    : document_(nullptr), indentation_(std::move(indentation)),
+      addChildValues_(), indented_(false) {}
 
-void StyledStreamWriter::write(JSONCPP_OSTREAM& out, const Value& root) {
+void StyledStreamWriter::write(OStream& out, const Value& root) {
   document_ = &out;
   addChildValues_ = false;
   indentString_.clear();
   indented_ = true;
   writeCommentBeforeValue(root);
-  if (!indented_) writeIndent();
+  if (!indented_)
+    writeIndent();
   indented_ = true;
   writeValue(root);
   writeCommentAfterValueOnSameLine(root);
   *document_ << "\n";
-  document_ = NULL; // Forget the stream, for safety.
+  document_ = nullptr; // Forget the stream, for safety.
 }
 
 void StyledStreamWriter::writeValue(const Value& value) {
@@ -653,14 +667,15 @@ void StyledStreamWriter::writeValue(const Value& value) {
   case realValue:
     pushValue(valueToString(value.asDouble()));
     break;
-  case stringValue:
-  {
+  case stringValue: {
     // Is NULL possible for value.string_? No.
     char const* str;
     char const* end;
     bool ok = value.getString(&str, &end);
-    if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));
-    else pushValue("");
+    if (ok)
+      pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str)));
+    else
+      pushValue("");
     break;
   }
   case booleanValue:
@@ -676,9 +691,9 @@ void StyledStreamWriter::writeValue(const Value& value) {
     else {
       writeWithIndent("{");
       indent();
-      Value::Members::iterator it = members.begin();
+      auto it = members.begin();
       for (;;) {
-        const JSONCPP_STRING& name = *it;
+        const String& name = *it;
         const Value& childValue = value[name];
         writeCommentBeforeValue(childValue);
         writeWithIndent(valueToQuotedString(name.c_str()));
@@ -715,7 +730,8 @@ void StyledStreamWriter::writeArrayValue(const Value& value) {
         if (hasChildValue)
           writeWithIndent(childValues_[index]);
         else {
-          if (!indented_) writeIndent();
+          if (!indented_)
+            writeIndent();
           indented_ = true;
           writeValue(childValue);
           indented_ = false;
@@ -750,7 +766,7 @@ bool StyledStreamWriter::isMultilineArray(const Value& value) {
   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
     const Value& childValue = value[index];
     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
-                        childValue.size() > 0);
+                   !childValue.empty());
   }
   if (!isMultiLine) // check if line length > max line length
   {
@@ -770,7 +786,7 @@ bool StyledStreamWriter::isMultilineArray(const Value& value) {
   return isMultiLine;
 }
 
-void StyledStreamWriter::pushValue(const JSONCPP_STRING& value) {
+void StyledStreamWriter::pushValue(const String& value) {
   if (addChildValues_)
     childValues_.push_back(value);
   else
@@ -785,8 +801,9 @@ void StyledStreamWriter::writeIndent() {
   *document_ << '\n' << indentString_;
 }
 
-void StyledStreamWriter::writeWithIndent(const JSONCPP_STRING& value) {
-  if (!indented_) writeIndent();
+void StyledStreamWriter::writeWithIndent(const String& value) {
+  if (!indented_)
+    writeIndent();
   *document_ << value;
   indented_ = false;
 }
@@ -802,13 +819,13 @@ void StyledStreamWriter::writeCommentBeforeValue(const Value& root) {
   if (!root.hasComment(commentBefore))
     return;
 
-  if (!indented_) writeIndent();
-  const JSONCPP_STRING& comment = root.getComment(commentBefore);
-  JSONCPP_STRING::const_iterator iter = comment.begin();
+  if (!indented_)
+    writeIndent();
+  const String& comment = root.getComment(commentBefore);
+  String::const_iterator iter = comment.begin();
   while (iter != comment.end()) {
     *document_ << *iter;
-    if (*iter == '\n' &&
-       ((iter+1) != comment.end() && *(iter + 1) == '/'))
+    if (*iter == '\n' && ((iter + 1) != comment.end() && *(iter + 1) == '/'))
       // writeIndent();  // would include newline
       *document_ << indentString_;
     ++iter;
@@ -840,84 +857,79 @@ bool StyledStreamWriter::hasCommentForValue(const Value& value) {
 struct CommentStyle {
   /// Decide whether to write comments.
   enum Enum {
-    None,  ///< Drop all comments.
-    Most,  ///< Recover odd behavior of previous versions (not implemented yet).
-    All  ///< Keep all comments.
+    None, ///< Drop all comments.
+    Most, ///< Recover odd behavior of previous versions (not implemented yet).
+    All   ///< Keep all comments.
   };
 };
 
-struct BuiltStyledStreamWriter : public StreamWriter
-{
-  BuiltStyledStreamWriter(
-      JSONCPP_STRING const& indentation,
-      CommentStyle::Enum cs,
-      JSONCPP_STRING const& colonSymbol,
-      JSONCPP_STRING const& nullSymbol,
-      JSONCPP_STRING const& endingLineFeedSymbol,
-      bool useSpecialFloats,
-      unsigned int precision);
-  int write(Value const& root, JSONCPP_OSTREAM* sout) JSONCPP_OVERRIDE;
+struct BuiltStyledStreamWriter : public StreamWriter {
+  BuiltStyledStreamWriter(String indentation,
+                          CommentStyle::Enum cs,
+                          String colonSymbol,
+                          String nullSymbol,
+                          String endingLineFeedSymbol,
+                          bool useSpecialFloats,
+                          unsigned int precision,
+                          PrecisionType precisionType);
+  int write(Value const& root, OStream* sout) override;
+
 private:
   void writeValue(Value const& value);
   void writeArrayValue(Value const& value);
   bool isMultilineArray(Value const& value);
-  void pushValue(JSONCPP_STRING const& value);
+  void pushValue(String const& value);
   void writeIndent();
-  void writeWithIndent(JSONCPP_STRING const& value);
+  void writeWithIndent(String const& value);
   void indent();
   void unindent();
   void writeCommentBeforeValue(Value const& root);
   void writeCommentAfterValueOnSameLine(Value const& root);
   static bool hasCommentForValue(const Value& value);
 
-  typedef std::vector<JSONCPP_STRING> ChildValues;
+  typedef std::vector<String> ChildValues;
 
   ChildValues childValues_;
-  JSONCPP_STRING indentString_;
+  String indentString_;
   unsigned int rightMargin_;
-  JSONCPP_STRING indentation_;
+  String indentation_;
   CommentStyle::Enum cs_;
-  JSONCPP_STRING colonSymbol_;
-  JSONCPP_STRING nullSymbol_;
-  JSONCPP_STRING endingLineFeedSymbol_;
+  String colonSymbol_;
+  String nullSymbol_;
+  String endingLineFeedSymbol_;
   bool addChildValues_ : 1;
   bool indented_ : 1;
   bool useSpecialFloats_ : 1;
   unsigned int precision_;
+  PrecisionType precisionType_;
 };
-BuiltStyledStreamWriter::BuiltStyledStreamWriter(
-      JSONCPP_STRING const& indentation,
-      CommentStyle::Enum cs,
-      JSONCPP_STRING const& colonSymbol,
-      JSONCPP_STRING const& nullSymbol,
-      JSONCPP_STRING const& endingLineFeedSymbol,
-      bool useSpecialFloats,
-      unsigned int precision)
-  : rightMargin_(74)
-  , indentation_(indentation)
-  , cs_(cs)
-  , colonSymbol_(colonSymbol)
-  , nullSymbol_(nullSymbol)
-  , endingLineFeedSymbol_(endingLineFeedSymbol)
-  , addChildValues_(false)
-  , indented_(false)
-  , useSpecialFloats_(useSpecialFloats)
-  , precision_(precision)
-{
-}
-int BuiltStyledStreamWriter::write(Value const& root, JSONCPP_OSTREAM* sout)
-{
+BuiltStyledStreamWriter::BuiltStyledStreamWriter(String indentation,
+                                                 CommentStyle::Enum cs,
+                                                 String colonSymbol,
+                                                 String nullSymbol,
+                                                 String endingLineFeedSymbol,
+                                                 bool useSpecialFloats,
+                                                 unsigned int precision,
+                                                 PrecisionType precisionType)
+    : rightMargin_(74), indentation_(std::move(indentation)), cs_(cs),
+      colonSymbol_(std::move(colonSymbol)), nullSymbol_(std::move(nullSymbol)),
+      endingLineFeedSymbol_(std::move(endingLineFeedSymbol)),
+      addChildValues_(false), indented_(false),
+      useSpecialFloats_(useSpecialFloats), precision_(precision),
+      precisionType_(precisionType) {}
+int BuiltStyledStreamWriter::write(Value const& root, OStream* sout) {
   sout_ = sout;
   addChildValues_ = false;
   indented_ = true;
   indentString_.clear();
   writeCommentBeforeValue(root);
-  if (!indented_) writeIndent();
+  if (!indented_)
+    writeIndent();
   indented_ = true;
   writeValue(root);
   writeCommentAfterValueOnSameLine(root);
   *sout_ << endingLineFeedSymbol_;
-  sout_ = NULL;
+  sout_ = nullptr;
   return 0;
 }
 void BuiltStyledStreamWriter::writeValue(Value const& value) {
@@ -932,16 +944,18 @@ void BuiltStyledStreamWriter::writeValue(Value const& value) {
     pushValue(valueToString(value.asLargestUInt()));
     break;
   case realValue:
-    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_));
+    pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_,
+                            precisionType_));
     break;
-  case stringValue:
-  {
+  case stringValue: {
     // Is NULL is possible for value.string_? No.
     char const* str;
     char const* end;
     bool ok = value.getString(&str, &end);
-    if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end-str)));
-    else pushValue("");
+    if (ok)
+      pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str)));
+    else
+      pushValue("");
     break;
   }
   case booleanValue:
@@ -957,12 +971,13 @@ void BuiltStyledStreamWriter::writeValue(Value const& value) {
     else {
       writeWithIndent("{");
       indent();
-      Value::Members::iterator it = members.begin();
+      auto it = members.begin();
       for (;;) {
-        JSONCPP_STRING const& name = *it;
+        String const& name = *it;
         Value const& childValue = value[name];
         writeCommentBeforeValue(childValue);
-        writeWithIndent(valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length())));
+        writeWithIndent(valueToQuotedStringN(
+            name.data(), static_cast<unsigned>(name.length())));
         *sout_ << colonSymbol_;
         writeValue(childValue);
         if (++it == members.end()) {
@@ -996,7 +1011,8 @@ void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
         if (hasChildValue)
           writeWithIndent(childValues_[index]);
         else {
-          if (!indented_) writeIndent();
+          if (!indented_)
+            writeIndent();
           indented_ = true;
           writeValue(childValue);
           indented_ = false;
@@ -1014,13 +1030,15 @@ void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
     {
       assert(childValues_.size() == size);
       *sout_ << "[";
-      if (!indentation_.empty()) *sout_ << " ";
+      if (!indentation_.empty())
+        *sout_ << " ";
       for (unsigned index = 0; index < size; ++index) {
         if (index > 0)
           *sout_ << ((!indentation_.empty()) ? ", " : ",");
         *sout_ << childValues_[index];
       }
-      if (!indentation_.empty()) *sout_ << " ";
+      if (!indentation_.empty())
+        *sout_ << " ";
       *sout_ << "]";
     }
   }
@@ -1033,7 +1051,7 @@ bool BuiltStyledStreamWriter::isMultilineArray(Value const& value) {
   for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
     Value const& childValue = value[index];
     isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
-                        childValue.size() > 0);
+                   !childValue.empty());
   }
   if (!isMultiLine) // check if line length > max line length
   {
@@ -1053,7 +1071,7 @@ bool BuiltStyledStreamWriter::isMultilineArray(Value const& value) {
   return isMultiLine;
 }
 
-void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
+void BuiltStyledStreamWriter::pushValue(String const& value) {
   if (addChildValues_)
     childValues_.push_back(value);
   else
@@ -1072,8 +1090,9 @@ void BuiltStyledStreamWriter::writeIndent() {
   }
 }
 
-void BuiltStyledStreamWriter::writeWithIndent(JSONCPP_STRING const& value) {
-  if (!indented_) writeIndent();
+void BuiltStyledStreamWriter::writeWithIndent(String const& value) {
+  if (!indented_)
+    writeIndent();
   *sout_ << value;
   indented_ = false;
 }
@@ -1086,17 +1105,18 @@ void BuiltStyledStreamWriter::unindent() {
 }
 
 void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const& root) {
-  if (cs_ == CommentStyle::None) return;
+  if (cs_ == CommentStyle::None)
+    return;
   if (!root.hasComment(commentBefore))
     return;
 
-  if (!indented_) writeIndent();
-  const JSONCPP_STRING& comment = root.getComment(commentBefore);
-  JSONCPP_STRING::const_iterator iter = comment.begin();
+  if (!indented_)
+    writeIndent();
+  const String& comment = root.getComment(commentBefore);
+  String::const_iterator iter = comment.begin();
   while (iter != comment.end()) {
     *sout_ << *iter;
-    if (*iter == '\n' &&
-       ((iter+1) != comment.end() && *(iter + 1) == '/'))
+    if (*iter == '\n' && ((iter + 1) != comment.end() && *(iter + 1) == '/'))
       // writeIndent();  // would write extra newline
       *sout_ << indentString_;
     ++iter;
@@ -1104,8 +1124,10 @@ void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const& root) {
   indented_ = false;
 }
 
-void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(Value const& root) {
-  if (cs_ == CommentStyle::None) return;
+void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(
+    Value const& root) {
+  if (cs_ == CommentStyle::None)
+    return;
   if (root.hasComment(commentAfterOnSameLine))
     *sout_ << " " + root.getComment(commentAfterOnSameLine);
 
@@ -1125,28 +1147,18 @@ bool BuiltStyledStreamWriter::hasCommentForValue(const Value& value) {
 ///////////////
 // StreamWriter
 
-StreamWriter::StreamWriter()
-    : sout_(NULL)
-{
-}
-StreamWriter::~StreamWriter()
-{
-}
-StreamWriter::Factory::~Factory()
-{}
-StreamWriterBuilder::StreamWriterBuilder()
-{
-  setDefaults(&settings_);
-}
-StreamWriterBuilder::~StreamWriterBuilder()
-{}
-StreamWriter* StreamWriterBuilder::newStreamWriter() const
-{
-  JSONCPP_STRING indentation = settings_["indentation"].asString();
-  JSONCPP_STRING cs_str = settings_["commentStyle"].asString();
+StreamWriter::StreamWriter() : sout_(nullptr) {}
+StreamWriter::~StreamWriter() = default;
+StreamWriter::Factory::~Factory() = default;
+StreamWriterBuilder::StreamWriterBuilder() { setDefaults(&settings_); }
+StreamWriterBuilder::~StreamWriterBuilder() = default;
+StreamWriter* StreamWriterBuilder::newStreamWriter() const {
+  String indentation = settings_["indentation"].asString();
+  String cs_str = settings_["commentStyle"].asString();
+  String pt_str = settings_["precisionType"].asString();
   bool eyc = settings_["enableYAMLCompatibility"].asBool();
   bool dnp = settings_["dropNullPlaceholders"].asBool();
-  bool usf = settings_["useSpecialFloats"].asBool(); 
+  bool usf = settings_["useSpecialFloats"].asBool();
   unsigned int pre = settings_["precision"].asUInt();
   CommentStyle::Enum cs = CommentStyle::All;
   if (cs_str == "All") {
@@ -1156,24 +1168,32 @@ StreamWriter* StreamWriterBuilder::newStreamWriter() const
   } else {
     throwRuntimeError("commentStyle must be 'All' or 'None'");
   }
-  JSONCPP_STRING colonSymbol = " : ";
+  PrecisionType precisionType(significantDigits);
+  if (pt_str == "significant") {
+    precisionType = PrecisionType::significantDigits;
+  } else if (pt_str == "decimal") {
+    precisionType = PrecisionType::decimalPlaces;
+  } else {
+    throwRuntimeError("precisionType must be 'significant' or 'decimal'");
+  }
+  String colonSymbol = " : ";
   if (eyc) {
     colonSymbol = ": ";
   } else if (indentation.empty()) {
     colonSymbol = ":";
   }
-  JSONCPP_STRING nullSymbol = "null";
+  String nullSymbol = "null";
   if (dnp) {
     nullSymbol.clear();
   }
-  if (pre > 17) pre = 17;
-  JSONCPP_STRING endingLineFeedSymbol;
-  return new BuiltStyledStreamWriter(
-      indentation, cs,
-      colonSymbol, nullSymbol, endingLineFeedSymbol, usf, pre);
+  if (pre > 17)
+    pre = 17;
+  String endingLineFeedSymbol;
+  return new BuiltStyledStreamWriter(indentation, cs, colonSymbol, nullSymbol,
+                                     endingLineFeedSymbol, usf, pre,
+                                     precisionType);
 }
-static void getValidWriterKeys(std::set<JSONCPP_STRING>* valid_keys)
-{
+static void getValidWriterKeys(std::set<String>* valid_keys) {
   valid_keys->clear();
   valid_keys->insert("indentation");
   valid_keys->insert("commentStyle");
@@ -1181,31 +1201,30 @@ static void getValidWriterKeys(std::set<JSONCPP_STRING>* valid_keys)
   valid_keys->insert("dropNullPlaceholders");
   valid_keys->insert("useSpecialFloats");
   valid_keys->insert("precision");
+  valid_keys->insert("precisionType");
 }
-bool StreamWriterBuilder::validate(Json::Value* invalid) const
-{
+bool StreamWriterBuilder::validate(Json::Value* invalid) const {
   Json::Value my_invalid;
-  if (!invalid) invalid = &my_invalid;  // so we do not need to test for NULL
+  if (!invalid)
+    invalid = &my_invalid; // so we do not need to test for NULL
   Json::Value& inv = *invalid;
-  std::set<JSONCPP_STRING> valid_keys;
+  std::set<String> valid_keys;
   getValidWriterKeys(&valid_keys);
   Value::Members keys = settings_.getMemberNames();
   size_t n = keys.size();
   for (size_t i = 0; i < n; ++i) {
-    JSONCPP_STRING const& key = keys[i];
+    String const& key = keys[i];
     if (valid_keys.find(key) == valid_keys.end()) {
       inv[key] = settings_[key];
     }
   }
-  return 0u == inv.size();
+  return inv.empty();
 }
-Value& StreamWriterBuilder::operator[](JSONCPP_STRING key)
-{
+Value& StreamWriterBuilder::operator[](const String& key) {
   return settings_[key];
 }
 // static
-void StreamWriterBuilder::setDefaults(Json::Value* settings)
-{
+void StreamWriterBuilder::setDefaults(Json::Value* settings) {
   //! [StreamWriterBuilderDefaults]
   (*settings)["commentStyle"] = "All";
   (*settings)["indentation"] = "\t";
@@ -1213,17 +1232,18 @@ void StreamWriterBuilder::setDefaults(Json::Value* settings)
   (*settings)["dropNullPlaceholders"] = false;
   (*settings)["useSpecialFloats"] = false;
   (*settings)["precision"] = 17;
+  (*settings)["precisionType"] = "significant";
   //! [StreamWriterBuilderDefaults]
 }
 
-JSONCPP_STRING writeString(StreamWriter::Factory const& builder, Value const& root) {
-  JSONCPP_OSTRINGSTREAM sout;
-  StreamWriterPtr const writer(builder.newStreamWriter());
+String writeString(StreamWriter::Factory const& factory, Value const& root) {
+  OStringStream sout;
+  StreamWriterPtr const writer(factory.newStreamWriter());
   writer->write(root, &sout);
   return sout.str();
 }
 
-JSONCPP_OSTREAM& operator<<(JSONCPP_OSTREAM& sout, Value const& root) {
+OStream& operator<<(OStream& sout, Value const& root) {
   StreamWriterBuilder builder;
   StreamWriterPtr const writer(builder.newStreamWriter());
   writer->write(root, &sout);
diff --git a/src/test_lib_json/CMakeLists.txt b/src/test_lib_json/CMakeLists.txt
index 7000264..8a3970f 100644
--- a/src/test_lib_json/CMakeLists.txt
+++ b/src/test_lib_json/CMakeLists.txt
@@ -1,38 +1,40 @@
 # vim: et ts=4 sts=4 sw=4 tw=0
 
-ADD_EXECUTABLE( jsoncpp_test 
+add_executable( jsoncpp_test
                 jsontest.cpp
                 jsontest.h
                 main.cpp
                 )
 
 
-IF(BUILD_SHARED_LIBS)
-    ADD_DEFINITIONS( -DJSON_DLL )
-    TARGET_LINK_LIBRARIES(jsoncpp_test jsoncpp_lib)
-ELSE(BUILD_SHARED_LIBS)
-    TARGET_LINK_LIBRARIES(jsoncpp_test jsoncpp_lib_static)
-ENDIF()
+if(BUILD_SHARED_LIBS)
+    add_definitions( -DJSON_DLL )
+endif()
+target_link_libraries(jsoncpp_test jsoncpp_lib)
 
 # another way to solve issue #90
 #set_target_properties(jsoncpp_test PROPERTIES COMPILE_FLAGS -ffloat-store)
 
 # Run unit tests in post-build
 # (default cmake workflow hides away the test result into a file, resulting in poor dev workflow?!?)
-IF(JSONCPP_WITH_POST_BUILD_UNITTEST)
-    IF(BUILD_SHARED_LIBS)
+if(JSONCPP_WITH_POST_BUILD_UNITTEST)
+    if(BUILD_SHARED_LIBS)
         # First, copy the shared lib, for Microsoft.
         # Then, run the test executable.
-        ADD_CUSTOM_COMMAND( TARGET jsoncpp_test
+        add_custom_command( TARGET jsoncpp_test
                             POST_BUILD
                             COMMAND ${CMAKE_COMMAND} -E copy_if_different $<TARGET_FILE:jsoncpp_lib> $<TARGET_FILE_DIR:jsoncpp_test>
-                            COMMAND $<TARGET_FILE:jsoncpp_test>)
-    ELSE(BUILD_SHARED_LIBS)
+                            COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR} $<TARGET_FILE:jsoncpp_test>)
+    else(BUILD_SHARED_LIBS)
         # Just run the test executable.
-        ADD_CUSTOM_COMMAND( TARGET jsoncpp_test
+        add_custom_command( TARGET jsoncpp_test
                             POST_BUILD
-                            COMMAND $<TARGET_FILE:jsoncpp_test>)
-    ENDIF()
-ENDIF()
+                            COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR} $<TARGET_FILE:jsoncpp_test>)
+    endif()
+    ## Create tests for dashboard submission, allows easy review of CI results https://my.cdash.org/index.php?project=jsoncpp
+    add_test(NAME jsoncpp_test
+       COMMAND ${CMAKE_CROSSCOMPILING_EMULATOR}  $<TARGET_FILE:jsoncpp_test>
+    )
+endif()
 
-SET_TARGET_PROPERTIES(jsoncpp_test PROPERTIES OUTPUT_NAME jsoncpp_test) 
+set_target_properties(jsoncpp_test PROPERTIES OUTPUT_NAME jsoncpp_test)
diff --git a/src/test_lib_json/jsontest.cpp b/src/test_lib_json/jsontest.cpp
index 94a0672..c0b5296 100644
--- a/src/test_lib_json/jsontest.cpp
+++ b/src/test_lib_json/jsontest.cpp
@@ -5,7 +5,7 @@
 
 #define _CRT_SECURE_NO_WARNINGS 1 // Prevents deprecation warning with MSVC
 #include "jsontest.h"
-#include <stdio.h>
+#include <cstdio>
 #include <string>
 
 #if defined(_MSC_VER)
@@ -73,15 +73,14 @@ namespace JsonTest {
 // class TestResult
 // //////////////////////////////////////////////////////////////////
 
-TestResult::TestResult()
-    : predicateId_(1), lastUsedPredicateId_(0), messageTarget_(0) {
+TestResult::TestResult() {
   // The root predicate has id 0
   rootPredicateNode_.id_ = 0;
-  rootPredicateNode_.next_ = 0;
+  rootPredicateNode_.next_ = nullptr;
   predicateStackTail_ = &rootPredicateNode_;
 }
 
-void TestResult::setTestName(const JSONCPP_STRING& name) { name_ = name; }
+void TestResult::setTestName(const Json::String& name) { name_ = name; }
 
 TestResult&
 TestResult::addFailure(const char* file, unsigned int line, const char* expr) {
@@ -89,12 +88,12 @@ TestResult::addFailure(const char* file, unsigned int line, const char* expr) {
   /// added.
   unsigned int nestingLevel = 0;
   PredicateContext* lastNode = rootPredicateNode_.next_;
-  for (; lastNode != 0; lastNode = lastNode->next_) {
+  for (; lastNode != nullptr; lastNode = lastNode->next_) {
     if (lastNode->id_ > lastUsedPredicateId_) // new PredicateContext
     {
       lastUsedPredicateId_ = lastNode->id_;
-      addFailureInfo(
-          lastNode->file_, lastNode->line_, lastNode->expr_, nestingLevel);
+      addFailureInfo(lastNode->file_, lastNode->line_, lastNode->expr_,
+                     nestingLevel);
       // Link the PredicateContext to the failure for message target when
       // popping the PredicateContext.
       lastNode->failure_ = &(failures_.back());
@@ -124,32 +123,22 @@ void TestResult::addFailureInfo(const char* file,
 
 TestResult& TestResult::popPredicateContext() {
   PredicateContext* lastNode = &rootPredicateNode_;
-  while (lastNode->next_ != 0 && lastNode->next_->next_ != 0) {
+  while (lastNode->next_ != nullptr && lastNode->next_->next_ != nullptr) {
     lastNode = lastNode->next_;
   }
   // Set message target to popped failure
   PredicateContext* tail = lastNode->next_;
-  if (tail != 0 && tail->failure_ != 0) {
+  if (tail != nullptr && tail->failure_ != nullptr) {
     messageTarget_ = tail->failure_;
   }
   // Remove tail from list
   predicateStackTail_ = lastNode;
-  lastNode->next_ = 0;
+  lastNode->next_ = nullptr;
   return *this;
 }
 
 bool TestResult::failed() const { return !failures_.empty(); }
 
-unsigned int TestResult::getAssertionNestingLevel() const {
-  unsigned int level = 0;
-  const PredicateContext* lastNode = &rootPredicateNode_;
-  while (lastNode->next_ != 0) {
-    lastNode = lastNode->next_;
-    ++level;
-  }
-  return level;
-}
-
 void TestResult::printFailure(bool printTestName) const {
   if (failures_.empty()) {
     return;
@@ -160,12 +149,10 @@ void TestResult::printFailure(bool printTestName) const {
   }
 
   // Print in reverse to display the callstack in the right order
-  Failures::const_iterator itEnd = failures_.end();
-  for (Failures::const_iterator it = failures_.begin(); it != itEnd; ++it) {
-    const Failure& failure = *it;
-    JSONCPP_STRING indent(failure.nestingLevel_ * 2, ' ');
+  for (const auto& failure : failures_) {
+    Json::String indent(failure.nestingLevel_ * 2, ' ');
     if (failure.file_) {
-      printf("%s%s(%d): ", indent.c_str(), failure.file_, failure.line_);
+      printf("%s%s(%u): ", indent.c_str(), failure.file_, failure.line_);
     }
     if (!failure.expr_.empty()) {
       printf("%s\n", failure.expr_.c_str());
@@ -173,19 +160,19 @@ void TestResult::printFailure(bool printTestName) const {
       printf("\n");
     }
     if (!failure.message_.empty()) {
-      JSONCPP_STRING reindented = indentText(failure.message_, indent + "  ");
+      Json::String reindented = indentText(failure.message_, indent + "  ");
       printf("%s\n", reindented.c_str());
     }
   }
 }
 
-JSONCPP_STRING TestResult::indentText(const JSONCPP_STRING& text,
-                                   const JSONCPP_STRING& indent) {
-  JSONCPP_STRING reindented;
-  JSONCPP_STRING::size_type lastIndex = 0;
+Json::String TestResult::indentText(const Json::String& text,
+                                    const Json::String& indent) {
+  Json::String reindented;
+  Json::String::size_type lastIndex = 0;
   while (lastIndex < text.size()) {
-    JSONCPP_STRING::size_type nextIndex = text.find('\n', lastIndex);
-    if (nextIndex == JSONCPP_STRING::npos) {
+    Json::String::size_type nextIndex = text.find('\n', lastIndex);
+    if (nextIndex == Json::String::npos) {
       nextIndex = text.size() - 1;
     }
     reindented += indent;
@@ -195,8 +182,8 @@ JSONCPP_STRING TestResult::indentText(const JSONCPP_STRING& text,
   return reindented;
 }
 
-TestResult& TestResult::addToLastFailure(const JSONCPP_STRING& message) {
-  if (messageTarget_ != 0) {
+TestResult& TestResult::addToLastFailure(const Json::String& message) {
+  if (messageTarget_ != nullptr) {
     messageTarget_->message_ += message;
   }
   return *this;
@@ -217,9 +204,9 @@ TestResult& TestResult::operator<<(bool value) {
 // class TestCase
 // //////////////////////////////////////////////////////////////////
 
-TestCase::TestCase() : result_(0) {}
+TestCase::TestCase() = default;
 
-TestCase::~TestCase() {}
+TestCase::~TestCase() = default;
 
 void TestCase::run(TestResult& result) {
   result_ = &result;
@@ -229,25 +216,23 @@ void TestCase::run(TestResult& result) {
 // class Runner
 // //////////////////////////////////////////////////////////////////
 
-Runner::Runner() {}
+Runner::Runner() = default;
 
 Runner& Runner::add(TestCaseFactory factory) {
   tests_.push_back(factory);
   return *this;
 }
 
-unsigned int Runner::testCount() const {
-  return static_cast<unsigned int>(tests_.size());
-}
+size_t Runner::testCount() const { return tests_.size(); }
 
-JSONCPP_STRING Runner::testNameAt(unsigned int index) const {
+Json::String Runner::testNameAt(size_t index) const {
   TestCase* test = tests_[index]();
-  JSONCPP_STRING name = test->testName();
+  Json::String name = test->testName();
   delete test;
   return name;
 }
 
-void Runner::runTestAt(unsigned int index, TestResult& result) const {
+void Runner::runTestAt(size_t index, TestResult& result) const {
   TestCase* test = tests_[index]();
   result.setTestName(test->testName());
   printf("Testing %s: ", test->testName());
@@ -257,8 +242,7 @@ void Runner::runTestAt(unsigned int index, TestResult& result) const {
 #endif // if JSON_USE_EXCEPTION
     test->run(result);
 #if JSON_USE_EXCEPTION
-  }
-  catch (const std::exception& e) {
+  } catch (const std::exception& e) {
     result.addFailure(__FILE__, __LINE__, "Unexpected exception caught:")
         << e.what();
   }
@@ -270,9 +254,9 @@ void Runner::runTestAt(unsigned int index, TestResult& result) const {
 }
 
 bool Runner::runAllTest(bool printSummary) const {
-  unsigned int count = testCount();
+  size_t const count = testCount();
   std::deque<TestResult> failures;
-  for (unsigned int index = 0; index < count; ++index) {
+  for (size_t index = 0; index < count; ++index) {
     TestResult result;
     runTestAt(index, result);
     if (result.failed()) {
@@ -282,31 +266,27 @@ bool Runner::runAllTest(bool printSummary) const {
 
   if (failures.empty()) {
     if (printSummary) {
-      printf("All %d tests passed\n", count);
+      printf("All %zu tests passed\n", count);
     }
     return true;
   } else {
-    for (unsigned int index = 0; index < failures.size(); ++index) {
-      TestResult& result = failures[index];
+    for (auto& result : failures) {
       result.printFailure(count > 1);
     }
 
     if (printSummary) {
-      unsigned int failedCount = static_cast<unsigned int>(failures.size());
-      unsigned int passedCount = count - failedCount;
-      printf("%d/%d tests passed (%d failure(s))\n",
-             passedCount,
-             count,
+      size_t const failedCount = failures.size();
+      size_t const passedCount = count - failedCount;
+      printf("%zu/%zu tests passed (%zu failure(s))\n", passedCount, count,
              failedCount);
     }
     return false;
   }
 }
 
-bool Runner::testIndex(const JSONCPP_STRING& testName,
-                       unsigned int& indexOut) const {
-  unsigned int count = testCount();
-  for (unsigned int index = 0; index < count; ++index) {
+bool Runner::testIndex(const Json::String& testName, size_t& indexOut) const {
+  const size_t count = testCount();
+  for (size_t index = 0; index < count; ++index) {
     if (testNameAt(index) == testName) {
       indexOut = index;
       return true;
@@ -316,17 +296,17 @@ bool Runner::testIndex(const JSONCPP_STRING& testName,
 }
 
 void Runner::listTests() const {
-  unsigned int count = testCount();
-  for (unsigned int index = 0; index < count; ++index) {
+  const size_t count = testCount();
+  for (size_t index = 0; index < count; ++index) {
     printf("%s\n", testNameAt(index).c_str());
   }
 }
 
 int Runner::runCommandLine(int argc, const char* argv[]) const {
-  // typedef std::deque<JSONCPP_STRING> TestNames;
+  // typedef std::deque<String> TestNames;
   Runner subrunner;
   for (int index = 1; index < argc; ++index) {
-    JSONCPP_STRING opt = argv[index];
+    Json::String opt = argv[index];
     if (opt == "--list-tests") {
       listTests();
       return 0;
@@ -335,7 +315,7 @@ int Runner::runCommandLine(int argc, const char* argv[]) const {
     } else if (opt == "--test") {
       ++index;
       if (index < argc) {
-        unsigned int testNameIndex;
+        size_t testNameIndex;
         if (testIndex(argv[index], testNameIndex)) {
           subrunner.add(tests_[testNameIndex]);
         } else {
@@ -398,8 +378,8 @@ void Runner::preventDialogOnCrash() {
   _CrtSetReportHook(&msvcrtSilentReportHook);
 #endif // if defined(_MSC_VER)
 
-// @todo investigate this handler (for buffer overflow)
-// _set_security_error_handler
+  // @todo investigate this handler (for buffer overflow)
+  // _set_security_error_handler
 
 #if defined(_WIN32)
   // Prevents the system from popping a dialog for debugging if the
@@ -426,23 +406,21 @@ void Runner::printUsage(const char* appName) {
 // Assertion functions
 // //////////////////////////////////////////////////////////////////
 
-JSONCPP_STRING ToJsonString(const char* toConvert) {
-  return JSONCPP_STRING(toConvert);
+Json::String ToJsonString(const char* toConvert) {
+  return Json::String(toConvert);
 }
 
-JSONCPP_STRING ToJsonString(JSONCPP_STRING in) {
-  return in;
-}
+Json::String ToJsonString(Json::String in) { return in; }
 
 #if JSONCPP_USING_SECURE_MEMORY
-JSONCPP_STRING ToJsonString(std::string in) {
-  return JSONCPP_STRING(in.data(), in.data() + in.length());
+Json::String ToJsonString(std::string in) {
+  return Json::String(in.data(), in.data() + in.length());
 }
 #endif
 
 TestResult& checkStringEqual(TestResult& result,
-                             const JSONCPP_STRING& expected,
-                             const JSONCPP_STRING& actual,
+                             const Json::String& expected,
+                             const Json::String& actual,
                              const char* file,
                              unsigned int line,
                              const char* expr) {
diff --git a/src/test_lib_json/jsontest.h b/src/test_lib_json/jsontest.h
index 955317d..e9c11a4 100644
--- a/src/test_lib_json/jsontest.h
+++ b/src/test_lib_json/jsontest.h
@@ -6,11 +6,11 @@
 #ifndef JSONTEST_H_INCLUDED
 #define JSONTEST_H_INCLUDED
 
+#include <cstdio>
+#include <deque>
 #include <json/config.h>
 #include <json/value.h>
 #include <json/writer.h>
-#include <stdio.h>
-#include <deque>
 #include <sstream>
 #include <string>
 
@@ -32,8 +32,8 @@ class Failure {
 public:
   const char* file_;
   unsigned int line_;
-  JSONCPP_STRING expr_;
-  JSONCPP_STRING message_;
+  Json::String expr_;
+  Json::String message_;
   unsigned int nestingLevel_;
 };
 
@@ -60,16 +60,16 @@ public:
   /// Not encapsulated to prevent step into when debugging failed assertions
   /// Incremented by one on assertion predicate entry, decreased by one
   /// by addPredicateContext().
-  PredicateContext::Id predicateId_;
+  PredicateContext::Id predicateId_{1};
 
   /// \internal Implementation detail for predicate macros
   PredicateContext* predicateStackTail_;
 
-  void setTestName(const JSONCPP_STRING& name);
+  void setTestName(const Json::String& name);
 
   /// Adds an assertion failure.
   TestResult&
-  addFailure(const char* file, unsigned int line, const char* expr = 0);
+  addFailure(const char* file, unsigned int line, const char* expr = nullptr);
 
   /// Removes the last PredicateContext added to the predicate stack
   /// chained list.
@@ -82,7 +82,7 @@ public:
 
   // Generic operator that will work with anything ostream can deal with.
   template <typename T> TestResult& operator<<(const T& value) {
-    JSONCPP_OSTRINGSTREAM oss;
+    Json::OStringStream oss;
     oss.precision(16);
     oss.setf(std::ios_base::floatfield);
     oss << value;
@@ -96,23 +96,22 @@ public:
   TestResult& operator<<(Json::UInt64 value);
 
 private:
-  TestResult& addToLastFailure(const JSONCPP_STRING& message);
-  unsigned int getAssertionNestingLevel() const;
+  TestResult& addToLastFailure(const Json::String& message);
   /// Adds a failure or a predicate context
   void addFailureInfo(const char* file,
                       unsigned int line,
                       const char* expr,
                       unsigned int nestingLevel);
-  static JSONCPP_STRING indentText(const JSONCPP_STRING& text,
-                                const JSONCPP_STRING& indent);
+  static Json::String indentText(const Json::String& text,
+                                 const Json::String& indent);
 
   typedef std::deque<Failure> Failures;
   Failures failures_;
-  JSONCPP_STRING name_;
+  Json::String name_;
   PredicateContext rootPredicateNode_;
-  PredicateContext::Id lastUsedPredicateId_;
+  PredicateContext::Id lastUsedPredicateId_{0};
   /// Failure which is the target of the messages added using operator <<
-  Failure* messageTarget_;
+  Failure* messageTarget_{nullptr};
 };
 
 class TestCase {
@@ -126,7 +125,7 @@ public:
   virtual const char* testName() const = 0;
 
 protected:
-  TestResult* result_;
+  TestResult* result_{nullptr};
 
 private:
   virtual void runTestCase() = 0;
@@ -152,23 +151,23 @@ public:
   bool runAllTest(bool printSummary) const;
 
   /// Returns the number of test case in the suite
-  unsigned int testCount() const;
+  size_t testCount() const;
 
   /// Returns the name of the test case at the specified index
-  JSONCPP_STRING testNameAt(unsigned int index) const;
+  Json::String testNameAt(size_t index) const;
 
   /// Runs the test case at the specified index using the specified TestResult
-  void runTestAt(unsigned int index, TestResult& result) const;
+  void runTestAt(size_t index, TestResult& result) const;
 
   static void printUsage(const char* appName);
 
 private: // prevents copy construction and assignment
-  Runner(const Runner& other);
-  Runner& operator=(const Runner& other);
+  Runner(const Runner& other) = delete;
+  Runner& operator=(const Runner& other) = delete;
 
 private:
   void listTests() const;
-  bool testIndex(const JSONCPP_STRING& testName, unsigned int& index) const;
+  bool testIndex(const Json::String& testName, size_t& indexOut) const;
   static void preventDialogOnCrash();
 
 private:
@@ -191,15 +190,15 @@ TestResult& checkEqual(TestResult& result,
   return result;
 }
 
-JSONCPP_STRING ToJsonString(const char* toConvert);
-JSONCPP_STRING ToJsonString(JSONCPP_STRING in);
+Json::String ToJsonString(const char* toConvert);
+Json::String ToJsonString(Json::String in);
 #if JSONCPP_USING_SECURE_MEMORY
-JSONCPP_STRING ToJsonString(std::string in);
+Json::String ToJsonString(std::string in);
 #endif
 
 TestResult& checkStringEqual(TestResult& result,
-                             const JSONCPP_STRING& expected,
-                             const JSONCPP_STRING& actual,
+                             const Json::String& expected,
+                             const Json::String& actual,
                              const char* file,
                              unsigned int line,
                              const char* expr);
@@ -212,7 +211,7 @@ TestResult& checkStringEqual(TestResult& result,
 #define JSONTEST_ASSERT(expr)                                                  \
   if (expr) {                                                                  \
   } else                                                                       \
-  result_->addFailure(__FILE__, __LINE__, #expr)
+    result_->addFailure(__FILE__, __LINE__, #expr)
 
 /// \brief Asserts that the given predicate is true.
 /// The predicate may do other assertions and be a member function of the
@@ -220,8 +219,7 @@ TestResult& checkStringEqual(TestResult& result,
 #define JSONTEST_ASSERT_PRED(expr)                                             \
   {                                                                            \
     JsonTest::PredicateContext _minitest_Context = {                           \
-      result_->predicateId_, __FILE__, __LINE__, #expr, NULL, NULL             \
-    };                                                                         \
+        result_->predicateId_, __FILE__, __LINE__, #expr, NULL, NULL};         \
     result_->predicateStackTail_->next_ = &_minitest_Context;                  \
     result_->predicateId_ += 1;                                                \
     result_->predicateStackTail_ = &_minitest_Context;                         \
@@ -231,21 +229,14 @@ TestResult& checkStringEqual(TestResult& result,
 
 /// \brief Asserts that two values are equals.
 #define JSONTEST_ASSERT_EQUAL(expected, actual)                                \
-  JsonTest::checkEqual(*result_,                                               \
-                       expected,                                               \
-                       actual,                                                 \
-                       __FILE__,                                               \
-                       __LINE__,                                               \
+  JsonTest::checkEqual(*result_, expected, actual, __FILE__, __LINE__,         \
                        #expected " == " #actual)
 
 /// \brief Asserts that two values are equals.
 #define JSONTEST_ASSERT_STRING_EQUAL(expected, actual)                         \
-  JsonTest::checkStringEqual(*result_,                                         \
-		                 JsonTest::ToJsonString(expected),                 \
-		                     JsonTest::ToJsonString(actual),                   \
-                             __FILE__,                                         \
-                             __LINE__,                                         \
-                             #expected " == " #actual)
+  JsonTest::checkStringEqual(*result_, JsonTest::ToJsonString(expected),       \
+                             JsonTest::ToJsonString(actual), __FILE__,         \
+                             __LINE__, #expected " == " #actual)
 
 /// \brief Asserts that a given expression throws an exception
 #define JSONTEST_ASSERT_THROWS(expr)                                           \
@@ -253,13 +244,12 @@ TestResult& checkStringEqual(TestResult& result,
     bool _threw = false;                                                       \
     try {                                                                      \
       expr;                                                                    \
-    }                                                                          \
-    catch (...) {                                                              \
+    } catch (...) {                                                            \
       _threw = true;                                                           \
     }                                                                          \
     if (!_threw)                                                               \
-      result_->addFailure(                                                     \
-          __FILE__, __LINE__, "expected exception thrown: " #expr);            \
+      result_->addFailure(__FILE__, __LINE__,                                  \
+                          "expected exception thrown: " #expr);                \
   }
 
 /// \brief Begin a fixture test case.
@@ -270,9 +260,9 @@ TestResult& checkStringEqual(TestResult& result,
       return new Test##FixtureType##name();                                    \
     }                                                                          \
                                                                                \
-  public: /* overidden from TestCase */                                        \
-    const char* testName() const JSONCPP_OVERRIDE { return #FixtureType "/" #name; }    \
-    void runTestCase() JSONCPP_OVERRIDE;                                                \
+  public: /* overridden from TestCase */                                       \
+    const char* testName() const override { return #FixtureType "/" #name; }   \
+    void runTestCase() override;                                               \
   };                                                                           \
                                                                                \
   void Test##FixtureType##name::runTestCase()
diff --git a/src/test_lib_json/main.cpp b/src/test_lib_json/main.cpp
index d00e107..280f7ea 100644
--- a/src/test_lib_json/main.cpp
+++ b/src/test_lib_json/main.cpp
@@ -11,13 +11,14 @@
 #endif
 
 #include "jsontest.h"
+#include <cmath>
+#include <cstring>
+#include <iomanip>
 #include <json/config.h>
 #include <json/json.h>
-#include <cstring>
 #include <limits>
 #include <sstream>
 #include <string>
-#include <iomanip>
 
 // Make numeric limits more convenient to talk about.
 // Assumes int type in 32 bits.
@@ -28,8 +29,8 @@
 #define kint64min Json::Value::minInt64
 #define kuint64max Json::Value::maxUInt64
 
-//static const double kdint64max = double(kint64max);
-//static const float kfint64max = float(kint64max);
+// static const double kdint64max = double(kint64max);
+// static const float kfint64max = float(kint64max);
 static const float kfint32max = float(kint32max);
 static const float kfuint32max = float(kuint32max);
 
@@ -81,19 +82,19 @@ struct ValueTest : JsonTest::TestCase {
     /// Initialize all checks to \c false by default.
     IsCheck();
 
-    bool isObject_;
-    bool isArray_;
-    bool isBool_;
-    bool isString_;
-    bool isNull_;
-
-    bool isInt_;
-    bool isInt64_;
-    bool isUInt_;
-    bool isUInt64_;
-    bool isIntegral_;
-    bool isDouble_;
-    bool isNumeric_;
+    bool isObject_{false};
+    bool isArray_{false};
+    bool isBool_{false};
+    bool isString_{false};
+    bool isNull_{false};
+
+    bool isInt_{false};
+    bool isInt64_{false};
+    bool isUInt_{false};
+    bool isUInt64_{false};
+    bool isIntegral_{false};
+    bool isDouble_{false};
+    bool isNumeric_{false};
   };
 
   void checkConstMemberCount(const Json::Value& value,
@@ -109,21 +110,21 @@ struct ValueTest : JsonTest::TestCase {
 
   /// Normalize the representation of floating-point number by stripped leading
   /// 0 in exponent.
-  static JSONCPP_STRING normalizeFloatingPointStr(const JSONCPP_STRING& s);
+  static Json::String normalizeFloatingPointStr(const Json::String& s);
 };
 
-JSONCPP_STRING ValueTest::normalizeFloatingPointStr(const JSONCPP_STRING& s) {
-  JSONCPP_STRING::size_type index = s.find_last_of("eE");
-  if (index != JSONCPP_STRING::npos) {
-    JSONCPP_STRING::size_type hasSign =
+Json::String ValueTest::normalizeFloatingPointStr(const Json::String& s) {
+  Json::String::size_type index = s.find_last_of("eE");
+  if (index != Json::String::npos) {
+    Json::String::size_type hasSign =
         (s[index + 1] == '+' || s[index + 1] == '-') ? 1 : 0;
-    JSONCPP_STRING::size_type exponentStartIndex = index + 1 + hasSign;
-    JSONCPP_STRING normalized = s.substr(0, exponentStartIndex);
-    JSONCPP_STRING::size_type indexDigit =
+    Json::String::size_type exponentStartIndex = index + 1 + hasSign;
+    Json::String normalized = s.substr(0, exponentStartIndex);
+    Json::String::size_type indexDigit =
         s.find_first_not_of('0', exponentStartIndex);
-    JSONCPP_STRING exponent = "0";
-    if (indexDigit !=
-        JSONCPP_STRING::npos) // There is an exponent different from 0
+    Json::String exponent = "0";
+    if (indexDigit != Json::String::npos) // There is an exponent different
+                                          // from 0
     {
       exponent = s.substr(indexDigit);
     }
@@ -203,6 +204,26 @@ JSONTEST_FIXTURE(ValueTest, objects) {
   JSONTEST_ASSERT_EQUAL(Json::Value(1234), constObject["id"]);
   JSONTEST_ASSERT_EQUAL(Json::Value(), constObject["unknown id"]);
 
+  // Access through find()
+  const char idKey[] = "id";
+  const Json::Value* foundId = object1_.find(idKey, idKey + strlen(idKey));
+  JSONTEST_ASSERT(foundId != nullptr);
+  JSONTEST_ASSERT_EQUAL(Json::Value(1234), *foundId);
+
+  const char unknownIdKey[] = "unknown id";
+  const Json::Value* foundUnknownId = object1_.find(unknownIdKey, unknownIdKey + strlen(unknownIdKey));
+  JSONTEST_ASSERT_EQUAL(nullptr, foundUnknownId);
+
+  // Access through demand()
+  const char yetAnotherIdKey[] = "yet another id";
+  const Json::Value* foundYetAnotherId = object1_.find(yetAnotherIdKey, yetAnotherIdKey + strlen(yetAnotherIdKey));
+  JSONTEST_ASSERT_EQUAL(nullptr, foundYetAnotherId);
+  Json::Value* demandedYetAnotherId = object1_.demand(yetAnotherIdKey, yetAnotherIdKey + strlen(yetAnotherIdKey));
+  JSONTEST_ASSERT(demandedYetAnotherId != nullptr);
+  *demandedYetAnotherId = "baz";
+
+  JSONTEST_ASSERT_EQUAL(Json::Value("baz"), object1_["yet another id"]);
+
   // Access through non-const reference
   JSONTEST_ASSERT_EQUAL(Json::Value(1234), object1_["id"]);
   JSONTEST_ASSERT_EQUAL(Json::Value(), object1_["unknown id"]);
@@ -221,6 +242,12 @@ JSONTEST_FIXTURE(ValueTest, objects) {
   did = object1_.removeMember("some other id", &got);
   JSONTEST_ASSERT_EQUAL(Json::Value("bar"), got);
   JSONTEST_ASSERT_EQUAL(false, did);
+
+  object1_["some other id"] = "foo";
+  Json::Value* gotPtr = nullptr;
+  did = object1_.removeMember("some other id", gotPtr);
+  JSONTEST_ASSERT_EQUAL(nullptr, gotPtr);
+  JSONTEST_ASSERT_EQUAL(true, did);
 }
 
 JSONTEST_FIXTURE(ValueTest, arrays) {
@@ -268,19 +295,17 @@ JSONTEST_FIXTURE(ValueTest, arrays) {
   JSONTEST_ASSERT_EQUAL(Json::Value(17), got);
   JSONTEST_ASSERT_EQUAL(false, array1_.removeIndex(2, &got)); // gone now
 }
-JSONTEST_FIXTURE(ValueTest, arrayIssue252)
-{
+JSONTEST_FIXTURE(ValueTest, arrayIssue252) {
   int count = 5;
   Json::Value root;
   Json::Value item;
   root["array"] = Json::Value::nullRef;
-  for (int i = 0; i < count; i++)
-  {
+  for (int i = 0; i < count; i++) {
     item["a"] = i;
     item["b"] = i;
     root["array"][i] = item;
   }
-  //JSONTEST_ASSERT_EQUAL(5, root["array"].size());
+  // JSONTEST_ASSERT_EQUAL(5, root["array"].size());
 }
 
 JSONTEST_FIXTURE(ValueTest, null) {
@@ -310,10 +335,10 @@ JSONTEST_FIXTURE(ValueTest, null) {
   JSONTEST_ASSERT_EQUAL(Json::Value::null, null_);
 
   // Test using a Value in a boolean context (false iff null)
-  JSONTEST_ASSERT_EQUAL(null_,false);
-  JSONTEST_ASSERT_EQUAL(object1_,true);
-  JSONTEST_ASSERT_EQUAL(!null_,true);
-  JSONTEST_ASSERT_EQUAL(!object1_,false);
+  JSONTEST_ASSERT_EQUAL(null_, false);
+  JSONTEST_ASSERT_EQUAL(object1_, true);
+  JSONTEST_ASSERT_EQUAL(!null_, true);
+  JSONTEST_ASSERT_EQUAL(!object1_, false);
 }
 
 JSONTEST_FIXTURE(ValueTest, strings) {
@@ -659,8 +684,9 @@ JSONTEST_FIXTURE(ValueTest, integers) {
   JSONTEST_ASSERT_EQUAL((1 << 20), val.asDouble());
   JSONTEST_ASSERT_EQUAL((1 << 20), val.asFloat());
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_STRING_EQUAL("1048576.0",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "1048576.0",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // -2^20
   val = Json::Value(-(1 << 20));
@@ -900,8 +926,9 @@ JSONTEST_FIXTURE(ValueTest, integers) {
   JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asDouble());
   JSONTEST_ASSERT_EQUAL((Json::Int64(1) << 40), val.asFloat());
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_STRING_EQUAL("1099511627776.0",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "1099511627776.0",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // -2^40
   val = Json::Value(-(Json::Int64(1) << 40));
@@ -972,11 +999,12 @@ JSONTEST_FIXTURE(ValueTest, integers) {
   JSONTEST_ASSERT_EQUAL(Json::UInt64(1) << 63, val.asUInt64());
   JSONTEST_ASSERT_EQUAL(Json::UInt64(1) << 63, val.asLargestUInt());
   JSONTEST_ASSERT_EQUAL(uint64ToDouble(Json::UInt64(1) << 63), val.asDouble());
-  JSONTEST_ASSERT_EQUAL(float(uint64ToDouble(Json::UInt64(1) << 63)),
-                        val.asFloat());
+  JSONTEST_ASSERT_EQUAL(float(Json::UInt64(1) << 63), val.asFloat());
+
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_STRING_EQUAL("9.2233720368547758e+18",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "9.2233720368547758e+18",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // int64 min
   val = Json::Value(Json::Int64(kint64min));
@@ -1023,11 +1051,12 @@ JSONTEST_FIXTURE(ValueTest, integers) {
   JSONTEST_ASSERT_EQUAL(-9223372036854775808.0, val.asDouble());
   JSONTEST_ASSERT_EQUAL(-9223372036854775808.0, val.asFloat());
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_STRING_EQUAL("-9.2233720368547758e+18",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "-9.2233720368547758e+18",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // 10^19
-  const Json::UInt64 ten_to_19 = static_cast<Json::UInt64>(1e19);
+  const auto ten_to_19 = static_cast<Json::UInt64>(1e19);
   val = Json::Value(Json::UInt64(ten_to_19));
 
   JSONTEST_ASSERT_EQUAL(Json::uintValue, val.type());
@@ -1070,8 +1099,9 @@ JSONTEST_FIXTURE(ValueTest, integers) {
   JSONTEST_ASSERT_EQUAL(1e19, val.asDouble());
   JSONTEST_ASSERT_EQUAL(1e19, val.asFloat());
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_STRING_EQUAL("1e+19",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "1e+19",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // uint64 max
   val = Json::Value(Json::UInt64(kuint64max));
@@ -1114,8 +1144,9 @@ JSONTEST_FIXTURE(ValueTest, integers) {
   JSONTEST_ASSERT_EQUAL(18446744073709551616.0, val.asDouble());
   JSONTEST_ASSERT_EQUAL(18446744073709551616.0, val.asFloat());
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_STRING_EQUAL("1.8446744073709552e+19",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "1.8446744073709552e+19",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 #endif
 }
 
@@ -1204,8 +1235,9 @@ JSONTEST_FIXTURE(ValueTest, nonIntegers) {
   JSONTEST_ASSERT_EQUAL(2147483647U, val.asLargestUInt());
 #endif
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_EQUAL("2147483647.5",
-                        normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_EQUAL(
+      "2147483647.5",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // A bit under int32 min
   val = Json::Value(kint32min - 0.5);
@@ -1232,8 +1264,9 @@ JSONTEST_FIXTURE(ValueTest, nonIntegers) {
   JSONTEST_ASSERT_EQUAL(-(Json::Int64(1) << 31), val.asLargestInt());
 #endif
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_EQUAL("-2147483648.5",
-                        normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_EQUAL(
+      "-2147483648.5",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // A bit over uint32 max
   val = Json::Value(kuint32max + 0.5);
@@ -1262,30 +1295,35 @@ JSONTEST_FIXTURE(ValueTest, nonIntegers) {
                         val.asLargestUInt());
 #endif
   JSONTEST_ASSERT_EQUAL(true, val.asBool());
-  JSONTEST_ASSERT_EQUAL("4294967295.5",
-                        normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_EQUAL(
+      "4294967295.5",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   val = Json::Value(1.2345678901234);
-  JSONTEST_ASSERT_STRING_EQUAL("1.2345678901234001",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "1.2345678901234001",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // A 16-digit floating point number.
   val = Json::Value(2199023255552000.0f);
   JSONTEST_ASSERT_EQUAL(float(2199023255552000.0f), val.asFloat());
-  JSONTEST_ASSERT_STRING_EQUAL("2199023255552000.0",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "2199023255552000.0",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // A very large floating point number.
   val = Json::Value(3.402823466385289e38);
   JSONTEST_ASSERT_EQUAL(float(3.402823466385289e38), val.asFloat());
-  JSONTEST_ASSERT_STRING_EQUAL("3.402823466385289e+38",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "3.402823466385289e+38",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 
   // An even larger floating point number.
   val = Json::Value(1.2345678e300);
   JSONTEST_ASSERT_EQUAL(double(1.2345678e300), val.asDouble());
-  JSONTEST_ASSERT_STRING_EQUAL("1.2345678e+300",
-                               normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
+  JSONTEST_ASSERT_STRING_EQUAL(
+      "1.2345678e+300",
+      normalizeFloatingPointStr(JsonTest::ToJsonString(val.asString())));
 }
 
 void ValueTest::checkConstMemberCount(const Json::Value& value,
@@ -1313,10 +1351,8 @@ void ValueTest::checkMemberCount(Json::Value& value,
 }
 
 ValueTest::IsCheck::IsCheck()
-    : isObject_(false), isArray_(false), isBool_(false), isString_(false),
-      isNull_(false), isInt_(false), isInt64_(false), isUInt_(false),
-      isUInt64_(false), isIntegral_(false), isDouble_(false),
-      isNumeric_(false) {}
+
+    = default;
 
 void ValueTest::checkIs(const Json::Value& value, const IsCheck& check) {
   JSONTEST_ASSERT_EQUAL(check.isObject_, value.isObject());
@@ -1433,6 +1469,40 @@ JSONTEST_FIXTURE(ValueTest, compareType) {
                                    Json::Value(Json::objectValue)));
 }
 
+JSONTEST_FIXTURE(ValueTest, CopyObject) {
+  Json::Value arrayVal;
+  arrayVal.append("val1");
+  arrayVal.append("val2");
+  arrayVal.append("val3");
+  Json::Value stringVal("string value");
+  Json::Value copy1, copy2;
+  {
+    Json::Value arrayCopy, stringCopy;
+    arrayCopy.copy(arrayVal);
+    stringCopy.copy(stringVal);
+    JSONTEST_ASSERT_PRED(checkIsEqual(arrayCopy, arrayVal));
+    JSONTEST_ASSERT_PRED(checkIsEqual(stringCopy, stringVal));
+    arrayCopy.append("val4");
+    JSONTEST_ASSERT(arrayCopy.size() == 4);
+    arrayVal.append("new4");
+    arrayVal.append("new5");
+    JSONTEST_ASSERT(arrayVal.size() == 5);
+    JSONTEST_ASSERT(!(arrayCopy == arrayVal));
+    stringCopy = "another string";
+    JSONTEST_ASSERT(!(stringCopy == stringVal));
+    copy1.copy(arrayCopy);
+    copy2.copy(stringCopy);
+  }
+  JSONTEST_ASSERT(arrayVal.size() == 5);
+  JSONTEST_ASSERT(stringVal == "string value");
+  JSONTEST_ASSERT(copy1.size() == 4);
+  JSONTEST_ASSERT(copy2 == "another string");
+  copy1.copy(stringVal);
+  JSONTEST_ASSERT(copy1 == "string value");
+  copy2.copy(arrayVal);
+  JSONTEST_ASSERT(copy2.size() == 5);
+}
+
 void ValueTest::checkIsLess(const Json::Value& x, const Json::Value& y) {
   JSONTEST_ASSERT(x < y);
   JSONTEST_ASSERT(y > x);
@@ -1551,7 +1621,7 @@ JSONTEST_FIXTURE(ValueTest, offsetAccessors) {
 JSONTEST_FIXTURE(ValueTest, StaticString) {
   char mutant[] = "hello";
   Json::StaticString ss(mutant);
-  JSONCPP_STRING regular(mutant);
+  Json::String regular(mutant);
   mutant[1] = 'a';
   JSONTEST_ASSERT_STRING_EQUAL("hallo", ss.c_str());
   JSONTEST_ASSERT_STRING_EQUAL("hello", regular.c_str());
@@ -1573,15 +1643,16 @@ JSONTEST_FIXTURE(ValueTest, StaticString) {
 
 JSONTEST_FIXTURE(ValueTest, CommentBefore) {
   Json::Value val; // fill val
-  val.setComment(JSONCPP_STRING("// this comment should appear before"), Json::commentBefore);
+  val.setComment(Json::String("// this comment should appear before"),
+                 Json::commentBefore);
   Json::StreamWriterBuilder wbuilder;
   wbuilder.settings_["commentStyle"] = "All";
   {
     char const expected[] = "// this comment should appear before\nnull";
-    JSONCPP_STRING result = Json::writeString(wbuilder, val);
+    Json::String result = Json::writeString(wbuilder, val);
     JSONTEST_ASSERT_STRING_EQUAL(expected, result);
-    JSONCPP_STRING res2 = val.toStyledString();
-    JSONCPP_STRING exp2 = "\n";
+    Json::String res2 = val.toStyledString();
+    Json::String exp2 = "\n";
     exp2 += expected;
     exp2 += "\n";
     JSONTEST_ASSERT_STRING_EQUAL(exp2, res2);
@@ -1590,24 +1661,24 @@ JSONTEST_FIXTURE(ValueTest, CommentBefore) {
   val.swapPayload(other);
   {
     char const expected[] = "// this comment should appear before\n\"hello\"";
-    JSONCPP_STRING result = Json::writeString(wbuilder, val);
+    Json::String result = Json::writeString(wbuilder, val);
     JSONTEST_ASSERT_STRING_EQUAL(expected, result);
-    JSONCPP_STRING res2 = val.toStyledString();
-    JSONCPP_STRING exp2 = "\n";
+    Json::String res2 = val.toStyledString();
+    Json::String exp2 = "\n";
     exp2 += expected;
     exp2 += "\n";
     JSONTEST_ASSERT_STRING_EQUAL(exp2, res2);
     JSONTEST_ASSERT_STRING_EQUAL("null\n", other.toStyledString());
   }
   val = "hello";
-  // val.setComment("// this comment should appear before", Json::CommentPlacement::commentBefore);
-  // Assignment over-writes comments.
+  // val.setComment("// this comment should appear before",
+  // Json::CommentPlacement::commentBefore); Assignment over-writes comments.
   {
     char const expected[] = "\"hello\"";
-    JSONCPP_STRING result = Json::writeString(wbuilder, val);
+    Json::String result = Json::writeString(wbuilder, val);
     JSONTEST_ASSERT_STRING_EQUAL(expected, result);
-    JSONCPP_STRING res2 = val.toStyledString();
-    JSONCPP_STRING exp2 = "";
+    Json::String res2 = val.toStyledString();
+    Json::String exp2 = "";
     exp2 += expected;
     exp2 += "\n";
     JSONTEST_ASSERT_STRING_EQUAL(exp2, res2);
@@ -1616,7 +1687,7 @@ JSONTEST_FIXTURE(ValueTest, CommentBefore) {
 
 JSONTEST_FIXTURE(ValueTest, zeroes) {
   char const cstr[] = "h\0i";
-  JSONCPP_STRING binary(cstr, sizeof(cstr));  // include trailing 0
+  Json::String binary(cstr, sizeof(cstr)); // include trailing 0
   JSONTEST_ASSERT_EQUAL(4U, binary.length());
   Json::StreamWriterBuilder b;
   {
@@ -1631,12 +1702,10 @@ JSONTEST_FIXTURE(ValueTest, zeroes) {
     JSONTEST_ASSERT_STRING_EQUAL(binary, root[top].asString());
     Json::Value removed;
     bool did;
-    did = root.removeMember(top, top + sizeof(top) - 1U,
-        &removed);
+    did = root.removeMember(top, top + sizeof(top) - 1U, &removed);
     JSONTEST_ASSERT(did);
     JSONTEST_ASSERT_STRING_EQUAL(binary, removed.asString());
-    did = root.removeMember(top, top + sizeof(top) - 1U,
-        &removed);
+    did = root.removeMember(top, top + sizeof(top) - 1U, &removed);
     JSONTEST_ASSERT(!did);
     JSONTEST_ASSERT_STRING_EQUAL(binary, removed.asString()); // still
   }
@@ -1644,7 +1713,7 @@ JSONTEST_FIXTURE(ValueTest, zeroes) {
 
 JSONTEST_FIXTURE(ValueTest, zeroesInKeys) {
   char const cstr[] = "h\0i";
-  JSONCPP_STRING binary(cstr, sizeof(cstr));  // include trailing 0
+  Json::String binary(cstr, sizeof(cstr)); // include trailing 0
   JSONTEST_ASSERT_EQUAL(4U, binary.length());
   {
     Json::Value root;
@@ -1652,19 +1721,21 @@ JSONTEST_FIXTURE(ValueTest, zeroesInKeys) {
     JSONTEST_ASSERT_STRING_EQUAL("there", root[binary].asString());
     JSONTEST_ASSERT(!root.isMember("h"));
     JSONTEST_ASSERT(root.isMember(binary));
-    JSONTEST_ASSERT_STRING_EQUAL("there", root.get(binary, Json::Value::nullRef).asString());
+    JSONTEST_ASSERT_STRING_EQUAL(
+        "there", root.get(binary, Json::Value::nullRef).asString());
     Json::Value removed;
     bool did;
     did = root.removeMember(binary.data(), binary.data() + binary.length(),
-        &removed);
+                            &removed);
     JSONTEST_ASSERT(did);
     JSONTEST_ASSERT_STRING_EQUAL("there", removed.asString());
     did = root.removeMember(binary.data(), binary.data() + binary.length(),
-        &removed);
+                            &removed);
     JSONTEST_ASSERT(!did);
     JSONTEST_ASSERT_STRING_EQUAL("there", removed.asString()); // still
     JSONTEST_ASSERT(!root.isMember(binary));
-    JSONTEST_ASSERT_STRING_EQUAL("", root.get(binary, Json::Value::nullRef).asString());
+    JSONTEST_ASSERT_STRING_EQUAL(
+        "", root.get(binary, Json::Value::nullRef).asString());
   }
 }
 
@@ -1673,8 +1744,8 @@ JSONTEST_FIXTURE(ValueTest, specialFloats) {
   b.settings_["useSpecialFloats"] = true;
 
   Json::Value v = std::numeric_limits<double>::quiet_NaN();
-  JSONCPP_STRING expected = "NaN";
-  JSONCPP_STRING result = Json::writeString(b, v);
+  Json::String expected = "NaN";
+  Json::String result = Json::writeString(b, v);
   JSONTEST_ASSERT_STRING_EQUAL(expected, result);
 
   v = std::numeric_limits<double>::infinity();
@@ -1689,40 +1760,61 @@ JSONTEST_FIXTURE(ValueTest, specialFloats) {
 }
 
 JSONTEST_FIXTURE(ValueTest, precision) {
-    Json::StreamWriterBuilder b;
-    b.settings_["precision"] = 5;
+  Json::StreamWriterBuilder b;
+  b.settings_["precision"] = 5;
 
-    Json::Value v = 100.0/3;
-    JSONCPP_STRING expected = "33.333";
-    JSONCPP_STRING result = Json::writeString(b, v);
-    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
-    
-    v = 0.25000000;
-    expected = "0.25";
-    result = Json::writeString(b, v);
-    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+  Json::Value v = 100.0 / 3;
+  Json::String expected = "33.333";
+  Json::String result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
 
-    v = 0.2563456;
-    expected = "0.25635";
-    result = Json::writeString(b, v);
-    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+  v = 0.25000000;
+  expected = "0.25";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
 
-    b.settings_["precision"] = 1;
-    expected = "0.3";
-    result = Json::writeString(b, v);
-    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+  v = 0.2563456;
+  expected = "0.25635";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
 
-    b.settings_["precision"] = 17;
-    v = 1234857476305.256345694873740545068;
-    expected = "1234857476305.2563";
-    result = Json::writeString(b, v);
-    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+  b.settings_["precision"] = 1;
+  expected = "0.3";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
 
-    b.settings_["precision"] = 24;
-    v = 0.256345694873740545068;
-    expected = "0.25634569487374054";
-    result = Json::writeString(b, v);
-    JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+  b.settings_["precision"] = 17;
+  v = 1234857476305.256345694873740545068;
+  expected = "1234857476305.2563";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+  b.settings_["precision"] = 24;
+  v = 0.256345694873740545068;
+  expected = "0.25634569487374054";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+  b.settings_["precision"] = 5;
+  b.settings_["precisionType"] = "decimal";
+  v = 0.256345694873740545068;
+  expected = "0.25635";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+  b.settings_["precision"] = 1;
+  b.settings_["precisionType"] = "decimal";
+  v = 0.256345694873740545068;
+  expected = "0.3";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
+
+  b.settings_["precision"] = 10;
+  b.settings_["precisionType"] = "decimal";
+  v = 0.23300000;
+  expected = "0.233";
+  result = Json::writeString(b, v);
+  JSONTEST_ASSERT_STRING_EQUAL(expected, result);
 }
 
 struct WriterTest : JsonTest::TestCase {};
@@ -1744,19 +1836,19 @@ JSONTEST_FIXTURE(StreamWriterTest, dropNullPlaceholders) {
   b.settings_["dropNullPlaceholders"] = false;
   JSONTEST_ASSERT(Json::writeString(b, nullValue) == "null");
   b.settings_["dropNullPlaceholders"] = true;
-  JSONTEST_ASSERT(Json::writeString(b, nullValue) == "");
+  JSONTEST_ASSERT(Json::writeString(b, nullValue).empty());
 }
 
 JSONTEST_FIXTURE(StreamWriterTest, writeZeroes) {
-  JSONCPP_STRING binary("hi", 3);  // include trailing 0
+  Json::String binary("hi", 3); // include trailing 0
   JSONTEST_ASSERT_EQUAL(3, binary.length());
-  JSONCPP_STRING expected("\"hi\\u0000\"");  // unicoded zero
+  Json::String expected("\"hi\\u0000\""); // unicoded zero
   Json::StreamWriterBuilder b;
   {
     Json::Value root;
     root = binary;
     JSONTEST_ASSERT_STRING_EQUAL(binary, root.asString());
-    JSONCPP_STRING out = Json::writeString(b, root);
+    Json::String out = Json::writeString(b, root);
     JSONTEST_ASSERT_EQUAL(expected.size(), out.size());
     JSONTEST_ASSERT_STRING_EQUAL(expected, out);
   }
@@ -1764,7 +1856,7 @@ JSONTEST_FIXTURE(StreamWriterTest, writeZeroes) {
     Json::Value root;
     root["top"] = binary;
     JSONTEST_ASSERT_STRING_EQUAL(binary, root["top"].asString());
-    JSONCPP_STRING out = Json::writeString(b, root["top"]);
+    Json::String out = Json::writeString(b, root["top"]);
     JSONTEST_ASSERT_STRING_EQUAL(expected, out);
   }
 }
@@ -1776,8 +1868,8 @@ JSONTEST_FIXTURE(ReaderTest, parseWithNoErrors) {
   Json::Value root;
   bool ok = reader.parse("{ \"property\" : \"value\" }", root);
   JSONTEST_ASSERT(ok);
-  JSONTEST_ASSERT(reader.getFormattedErrorMessages().size() == 0);
-  JSONTEST_ASSERT(reader.getStructuredErrors().size() == 0);
+  JSONTEST_ASSERT(reader.getFormattedErrorMessages().empty());
+  JSONTEST_ASSERT(reader.getStructuredErrors().empty());
 }
 
 JSONTEST_FIXTURE(ReaderTest, parseWithNoErrorsTestingOffsets) {
@@ -1788,8 +1880,8 @@ JSONTEST_FIXTURE(ReaderTest, parseWithNoErrorsTestingOffsets) {
                          "null, \"false\" : false }",
                          root);
   JSONTEST_ASSERT(ok);
-  JSONTEST_ASSERT(reader.getFormattedErrorMessages().size() == 0);
-  JSONTEST_ASSERT(reader.getStructuredErrors().size() == 0);
+  JSONTEST_ASSERT(reader.getFormattedErrorMessages().empty());
+  JSONTEST_ASSERT(reader.getStructuredErrors().empty());
   JSONTEST_ASSERT(root["property"].getOffsetStart() == 15);
   JSONTEST_ASSERT(root["property"].getOffsetLimit() == 34);
   JSONTEST_ASSERT(root["property"][0].getOffsetStart() == 16);
@@ -1865,44 +1957,36 @@ struct CharReaderTest : JsonTest::TestCase {};
 JSONTEST_FIXTURE(CharReaderTest, parseWithNoErrors) {
   Json::CharReaderBuilder b;
   Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::Value root;
   char const doc[] = "{ \"property\" : \"value\" }";
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
+  bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
   JSONTEST_ASSERT(ok);
-  JSONTEST_ASSERT(errs.size() == 0);
+  JSONTEST_ASSERT(errs.empty());
   delete reader;
 }
 
 JSONTEST_FIXTURE(CharReaderTest, parseWithNoErrorsTestingOffsets) {
   Json::CharReaderBuilder b;
   Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::Value root;
-  char const doc[] =
-                         "{ \"property\" : [\"value\", \"value2\"], \"obj\" : "
-                         "{ \"nested\" : 123, \"bool\" : true}, \"null\" : "
-                         "null, \"false\" : false }";
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
+  char const doc[] = "{ \"property\" : [\"value\", \"value2\"], \"obj\" : "
+                     "{ \"nested\" : 123, \"bool\" : true}, \"null\" : "
+                     "null, \"false\" : false }";
+  bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
   JSONTEST_ASSERT(ok);
-  JSONTEST_ASSERT(errs.size() == 0);
+  JSONTEST_ASSERT(errs.empty());
   delete reader;
 }
 
 JSONTEST_FIXTURE(CharReaderTest, parseWithOneError) {
   Json::CharReaderBuilder b;
   Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::Value root;
-  char const doc[] =
-      "{ \"property\" :: \"value\" }";
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
+  char const doc[] = "{ \"property\" :: \"value\" }";
+  bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
   JSONTEST_ASSERT(!ok);
   JSONTEST_ASSERT(errs ==
                   "* Line 1, Column 15\n  Syntax error: value, object or array "
@@ -1913,13 +1997,10 @@ JSONTEST_FIXTURE(CharReaderTest, parseWithOneError) {
 JSONTEST_FIXTURE(CharReaderTest, parseChineseWithOneError) {
   Json::CharReaderBuilder b;
   Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::Value root;
-  char const doc[] =
-      "{ \"pr佐藤erty\" :: \"value\" }";
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
+  char const doc[] = "{ \"pr佐藤erty\" :: \"value\" }";
+  bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
   JSONTEST_ASSERT(!ok);
   JSONTEST_ASSERT(errs ==
                   "* Line 1, Column 19\n  Syntax error: value, object or array "
@@ -1930,13 +2011,10 @@ JSONTEST_FIXTURE(CharReaderTest, parseChineseWithOneError) {
 JSONTEST_FIXTURE(CharReaderTest, parseWithDetailError) {
   Json::CharReaderBuilder b;
   Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::Value root;
-  char const doc[] =
-      "{ \"property\" : \"v\\alue\" }";
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
+  char const doc[] = "{ \"property\" : \"v\\alue\" }";
+  bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
   JSONTEST_ASSERT(!ok);
   JSONTEST_ASSERT(errs ==
                   "* Line 1, Column 16\n  Bad escape sequence in string\nSee "
@@ -1947,28 +2025,24 @@ JSONTEST_FIXTURE(CharReaderTest, parseWithDetailError) {
 JSONTEST_FIXTURE(CharReaderTest, parseWithStackLimit) {
   Json::CharReaderBuilder b;
   Json::Value root;
-  char const doc[] =
-      "{ \"property\" : \"value\" }";
+  char const doc[] = "{ \"property\" : \"value\" }";
   {
-  b.settings_["stackLimit"] = 2;
-  Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
-  JSONTEST_ASSERT(ok);
-  JSONTEST_ASSERT(errs == "");
-  JSONTEST_ASSERT_EQUAL("value", root["property"]);
-  delete reader;
+    b.settings_["stackLimit"] = 2;
+    Json::CharReader* reader(b.newCharReader());
+    Json::String errs;
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT(errs.empty());
+    JSONTEST_ASSERT_EQUAL("value", root["property"]);
+    delete reader;
   }
   {
-  b.settings_["stackLimit"] = 1;
-  Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  JSONTEST_ASSERT_THROWS(reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs));
-  delete reader;
+    b.settings_["stackLimit"] = 1;
+    Json::CharReader* reader(b.newCharReader());
+    Json::String errs;
+    JSONTEST_ASSERT_THROWS(
+        reader->parse(doc, doc + std::strlen(doc), &root, &errs));
+    delete reader;
   }
 }
 
@@ -1982,15 +2056,12 @@ JSONTEST_FIXTURE(CharReaderStrictModeTest, dupKeys) {
   {
     b.strictMode(&b.settings_);
     Json::CharReader* reader(b.newCharReader());
-    JSONCPP_STRING errs;
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    Json::String errs;
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(!ok);
-    JSONTEST_ASSERT_STRING_EQUAL(
-        "* Line 1, Column 41\n"
-        "  Duplicate key: 'key'\n",
-        errs);
+    JSONTEST_ASSERT_STRING_EQUAL("* Line 1, Column 41\n"
+                                 "  Duplicate key: 'key'\n",
+                                 errs);
     JSONTEST_ASSERT_EQUAL("val1", root["key"]); // so far
     delete reader;
   }
@@ -2001,67 +2072,56 @@ JSONTEST_FIXTURE(CharReaderFailIfExtraTest, issue164) {
   // This is interpreted as a string value followed by a colon.
   Json::CharReaderBuilder b;
   Json::Value root;
-  char const doc[] =
-      " \"property\" : \"value\" }";
+  char const doc[] = " \"property\" : \"value\" }";
   {
-  b.settings_["failIfExtra"] = false;
-  Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
-  JSONTEST_ASSERT(ok);
-  JSONTEST_ASSERT(errs == "");
-  JSONTEST_ASSERT_EQUAL("property", root);
-  delete reader;
+    b.settings_["failIfExtra"] = false;
+    Json::CharReader* reader(b.newCharReader());
+    Json::String errs;
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT(errs.empty());
+    JSONTEST_ASSERT_EQUAL("property", root);
+    delete reader;
   }
   {
-  b.settings_["failIfExtra"] = true;
-  Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
-  JSONTEST_ASSERT(!ok);
-  JSONTEST_ASSERT_STRING_EQUAL(errs,
-      "* Line 1, Column 13\n"
-      "  Extra non-whitespace after JSON value.\n");
-  JSONTEST_ASSERT_EQUAL("property", root);
-  delete reader;
+    b.settings_["failIfExtra"] = true;
+    Json::CharReader* reader(b.newCharReader());
+    Json::String errs;
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
+    JSONTEST_ASSERT(!ok);
+    JSONTEST_ASSERT_STRING_EQUAL(errs,
+                                 "* Line 1, Column 13\n"
+                                 "  Extra non-whitespace after JSON value.\n");
+    JSONTEST_ASSERT_EQUAL("property", root);
+    delete reader;
   }
   {
-  b.settings_["failIfExtra"] = false;
-  b.strictMode(&b.settings_);
-  Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
-  JSONTEST_ASSERT(!ok);
-  JSONTEST_ASSERT_STRING_EQUAL(errs,
-      "* Line 1, Column 13\n"
-      "  Extra non-whitespace after JSON value.\n");
-  JSONTEST_ASSERT_EQUAL("property", root);
-  delete reader;
+    b.settings_["failIfExtra"] = false;
+    b.strictMode(&b.settings_);
+    Json::CharReader* reader(b.newCharReader());
+    Json::String errs;
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
+    JSONTEST_ASSERT(!ok);
+    JSONTEST_ASSERT_STRING_EQUAL(errs,
+                                 "* Line 1, Column 13\n"
+                                 "  Extra non-whitespace after JSON value.\n");
+    JSONTEST_ASSERT_EQUAL("property", root);
+    delete reader;
   }
 }
 JSONTEST_FIXTURE(CharReaderFailIfExtraTest, issue107) {
   // This is interpreted as an int value followed by a colon.
   Json::CharReaderBuilder b;
   Json::Value root;
-  char const doc[] =
-      "1:2:3";
+  char const doc[] = "1:2:3";
   b.settings_["failIfExtra"] = true;
   Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
+  Json::String errs;
+  bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
   JSONTEST_ASSERT(!ok);
-  JSONTEST_ASSERT_STRING_EQUAL(
-      "* Line 1, Column 2\n"
-      "  Extra non-whitespace after JSON value.\n",
-      errs);
+  JSONTEST_ASSERT_STRING_EQUAL("* Line 1, Column 2\n"
+                               "  Extra non-whitespace after JSON value.\n",
+                               errs);
   JSONTEST_ASSERT_EQUAL(1, root.asInt());
   delete reader;
 }
@@ -2069,31 +2129,25 @@ JSONTEST_FIXTURE(CharReaderFailIfExtraTest, commentAfterObject) {
   Json::CharReaderBuilder b;
   Json::Value root;
   {
-  char const doc[] =
-      "{ \"property\" : \"value\" } //trailing\n//comment\n";
-  b.settings_["failIfExtra"] = true;
-  Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
-  JSONTEST_ASSERT(ok);
-  JSONTEST_ASSERT_STRING_EQUAL("", errs);
-  JSONTEST_ASSERT_EQUAL("value", root["property"]);
-  delete reader;
+    char const doc[] = "{ \"property\" : \"value\" } //trailing\n//comment\n";
+    b.settings_["failIfExtra"] = true;
+    Json::CharReader* reader(b.newCharReader());
+    Json::String errs;
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
+    JSONTEST_ASSERT(ok);
+    JSONTEST_ASSERT_STRING_EQUAL("", errs);
+    JSONTEST_ASSERT_EQUAL("value", root["property"]);
+    delete reader;
   }
 }
 JSONTEST_FIXTURE(CharReaderFailIfExtraTest, commentAfterArray) {
   Json::CharReaderBuilder b;
   Json::Value root;
-  char const doc[] =
-      "[ \"property\" , \"value\" ] //trailing\n//comment\n";
+  char const doc[] = "[ \"property\" , \"value\" ] //trailing\n//comment\n";
   b.settings_["failIfExtra"] = true;
   Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
+  Json::String errs;
+  bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
   JSONTEST_ASSERT(ok);
   JSONTEST_ASSERT_STRING_EQUAL("", errs);
   JSONTEST_ASSERT_EQUAL("value", root[1u]);
@@ -2102,14 +2156,11 @@ JSONTEST_FIXTURE(CharReaderFailIfExtraTest, commentAfterArray) {
 JSONTEST_FIXTURE(CharReaderFailIfExtraTest, commentAfterBool) {
   Json::CharReaderBuilder b;
   Json::Value root;
-  char const doc[] =
-      " true /*trailing\ncomment*/";
+  char const doc[] = " true /*trailing\ncomment*/";
   b.settings_["failIfExtra"] = true;
   Json::CharReader* reader(b.newCharReader());
-  JSONCPP_STRING errs;
-  bool ok = reader->parse(
-      doc, doc + std::strlen(doc),
-      &root, &errs);
+  Json::String errs;
+  bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
   JSONTEST_ASSERT(ok);
   JSONTEST_ASSERT_STRING_EQUAL("", errs);
   JSONTEST_ASSERT_EQUAL(true, root.asBool());
@@ -2121,13 +2172,11 @@ JSONTEST_FIXTURE(CharReaderAllowDropNullTest, issue178) {
   Json::CharReaderBuilder b;
   b.settings_["allowDroppedNullPlaceholders"] = true;
   Json::Value root;
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::CharReader* reader(b.newCharReader());
   {
     char const doc[] = "{\"a\":,\"b\":true}";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(2u, root.size());
@@ -2135,9 +2184,7 @@ JSONTEST_FIXTURE(CharReaderAllowDropNullTest, issue178) {
   }
   {
     char const doc[] = "{\"a\":}";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(1u, root.size());
@@ -2145,100 +2192,78 @@ JSONTEST_FIXTURE(CharReaderAllowDropNullTest, issue178) {
   }
   {
     char const doc[] = "[]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
-    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT(errs.empty());
     JSONTEST_ASSERT_EQUAL(0u, root.size());
     JSONTEST_ASSERT_EQUAL(Json::arrayValue, root);
   }
   {
     char const doc[] = "[null]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
-    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT(errs.empty());
     JSONTEST_ASSERT_EQUAL(1u, root.size());
   }
   {
     char const doc[] = "[,]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(2u, root.size());
   }
   {
     char const doc[] = "[,,,]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(4u, root.size());
   }
   {
     char const doc[] = "[null,]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(2u, root.size());
   }
   {
     char const doc[] = "[,null]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
-    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT(errs.empty());
     JSONTEST_ASSERT_EQUAL(2u, root.size());
   }
   {
     char const doc[] = "[,,]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(3u, root.size());
   }
   {
     char const doc[] = "[null,,]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(3u, root.size());
   }
   {
     char const doc[] = "[,null,]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(3u, root.size());
   }
   {
     char const doc[] = "[,,null]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
-    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT(errs.empty());
     JSONTEST_ASSERT_EQUAL(3u, root.size());
   }
   {
     char const doc[] = "[[],,,]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(4u, root.size());
@@ -2246,9 +2271,7 @@ JSONTEST_FIXTURE(CharReaderAllowDropNullTest, issue178) {
   }
   {
     char const doc[] = "[,[],,]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(4u, root.size());
@@ -2256,11 +2279,9 @@ JSONTEST_FIXTURE(CharReaderAllowDropNullTest, issue178) {
   }
   {
     char const doc[] = "[,,,[]]";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
-    JSONTEST_ASSERT(errs == "");
+    JSONTEST_ASSERT(errs.empty());
     JSONTEST_ASSERT_EQUAL(4u, root.size());
     JSONTEST_ASSERT_EQUAL(Json::arrayValue, root[3u]);
   }
@@ -2273,13 +2294,11 @@ JSONTEST_FIXTURE(CharReaderAllowSingleQuotesTest, issue182) {
   Json::CharReaderBuilder b;
   b.settings_["allowSingleQuotes"] = true;
   Json::Value root;
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::CharReader* reader(b.newCharReader());
   {
     char const doc[] = "{'a':true,\"b\":true}";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(2u, root.size());
@@ -2288,9 +2307,7 @@ JSONTEST_FIXTURE(CharReaderAllowSingleQuotesTest, issue182) {
   }
   {
     char const doc[] = "{'a': 'x', \"b\":'y'}";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(2u, root.size());
@@ -2306,13 +2323,11 @@ JSONTEST_FIXTURE(CharReaderAllowZeroesTest, issue176) {
   Json::CharReaderBuilder b;
   b.settings_["allowSingleQuotes"] = true;
   Json::Value root;
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::CharReader* reader(b.newCharReader());
   {
     char const doc[] = "{'a':true,\"b\":true}";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(2u, root.size());
@@ -2321,9 +2336,7 @@ JSONTEST_FIXTURE(CharReaderAllowZeroesTest, issue176) {
   }
   {
     char const doc[] = "{'a': 'x', \"b\":'y'}";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(2u, root.size());
@@ -2339,71 +2352,66 @@ JSONTEST_FIXTURE(CharReaderAllowSpecialFloatsTest, issue209) {
   Json::CharReaderBuilder b;
   b.settings_["allowSpecialFloats"] = true;
   Json::Value root;
-  JSONCPP_STRING errs;
+  Json::String errs;
   Json::CharReader* reader(b.newCharReader());
   {
     char const doc[] = "{\"a\":NaN,\"b\":Infinity,\"c\":-Infinity}";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(3u, root.size());
     double n = root["a"].asDouble();
-    JSONTEST_ASSERT(n != n);
-    JSONTEST_ASSERT_EQUAL(std::numeric_limits<double>::infinity(), root.get("b", 0.0));
-    JSONTEST_ASSERT_EQUAL(-std::numeric_limits<double>::infinity(), root.get("c", 0.0));
+    JSONTEST_ASSERT(std::isnan(n));
+    JSONTEST_ASSERT_EQUAL(std::numeric_limits<double>::infinity(),
+                          root.get("b", 0.0));
+    JSONTEST_ASSERT_EQUAL(-std::numeric_limits<double>::infinity(),
+                          root.get("c", 0.0));
   }
 
   struct TestData {
     int line;
     bool ok;
-    JSONCPP_STRING in;
+    Json::String in;
   };
   const TestData test_data[] = {
-    {__LINE__, 1, "{\"a\":9}"},
-    {__LINE__, 0, "{\"a\":0Infinity}"},
-    {__LINE__, 0, "{\"a\":1Infinity}"},
-    {__LINE__, 0, "{\"a\":9Infinity}"},
-    {__LINE__, 0, "{\"a\":0nfinity}"},
-    {__LINE__, 0, "{\"a\":1nfinity}"},
-    {__LINE__, 0, "{\"a\":9nfinity}"},
-    {__LINE__, 0, "{\"a\":nfinity}"},
-    {__LINE__, 0, "{\"a\":.nfinity}"},
-    {__LINE__, 0, "{\"a\":9nfinity}"},
-    {__LINE__, 0, "{\"a\":-nfinity}"},
-    {__LINE__, 1, "{\"a\":Infinity}"},
-    {__LINE__, 0, "{\"a\":.Infinity}"},
-    {__LINE__, 0, "{\"a\":_Infinity}"},
-    {__LINE__, 0, "{\"a\":_nfinity}"},
-    {__LINE__, 1, "{\"a\":-Infinity}"}
+      {__LINE__, true, "{\"a\":9}"},          //
+      {__LINE__, false, "{\"a\":0Infinity}"}, //
+      {__LINE__, false, "{\"a\":1Infinity}"}, //
+      {__LINE__, false, "{\"a\":9Infinity}"}, //
+      {__LINE__, false, "{\"a\":0nfinity}"},  //
+      {__LINE__, false, "{\"a\":1nfinity}"},  //
+      {__LINE__, false, "{\"a\":9nfinity}"},  //
+      {__LINE__, false, "{\"a\":nfinity}"},   //
+      {__LINE__, false, "{\"a\":.nfinity}"},  //
+      {__LINE__, false, "{\"a\":9nfinity}"},  //
+      {__LINE__, false, "{\"a\":-nfinity}"},  //
+      {__LINE__, true, "{\"a\":Infinity}"},   //
+      {__LINE__, false, "{\"a\":.Infinity}"}, //
+      {__LINE__, false, "{\"a\":_Infinity}"}, //
+      {__LINE__, false, "{\"a\":_nfinity}"},  //
+      {__LINE__, true, "{\"a\":-Infinity}"}   //
   };
-  for (size_t tdi = 0; tdi < sizeof(test_data) / sizeof(*test_data); ++tdi) {
-    const TestData& td = test_data[tdi];
-    bool ok = reader->parse(&*td.in.begin(),
-                            &*td.in.begin() + td.in.size(),
+  for (const auto& td : test_data) {
+    bool ok = reader->parse(&*td.in.begin(), &*td.in.begin() + td.in.size(),
                             &root, &errs);
-    JSONTEST_ASSERT(td.ok == ok)
-        << "line:" << td.line << "\n"
-        << "  expected: {"
-        << "ok:" << td.ok
-        << ", in:\'" << td.in << "\'"
-        << "}\n"
-        << "  actual: {"
-        << "ok:" << ok
-        << "}\n";
+    JSONTEST_ASSERT(td.ok == ok) << "line:" << td.line << "\n"
+                                 << "  expected: {"
+                                 << "ok:" << td.ok << ", in:\'" << td.in << "\'"
+                                 << "}\n"
+                                 << "  actual: {"
+                                 << "ok:" << ok << "}\n";
   }
 
   {
     char const doc[] = "{\"posInf\": Infinity, \"NegInf\": -Infinity}";
-    bool ok = reader->parse(
-        doc, doc + std::strlen(doc),
-        &root, &errs);
+    bool ok = reader->parse(doc, doc + std::strlen(doc), &root, &errs);
     JSONTEST_ASSERT(ok);
     JSONTEST_ASSERT_STRING_EQUAL("", errs);
     JSONTEST_ASSERT_EQUAL(2u, root.size());
-    JSONTEST_ASSERT_EQUAL(std::numeric_limits<double>::infinity(), root["posInf"].asDouble());
-    JSONTEST_ASSERT_EQUAL(-std::numeric_limits<double>::infinity(), root["NegInf"].asDouble());
+    JSONTEST_ASSERT_EQUAL(std::numeric_limits<double>::infinity(),
+                          root["posInf"].asDouble());
+    JSONTEST_ASSERT_EQUAL(-std::numeric_limits<double>::infinity(),
+                          root["NegInf"].asDouble());
   }
   delete reader;
 }
@@ -2438,7 +2446,7 @@ JSONTEST_FIXTURE(IteratorTest, distance) {
   json["k1"] = "a";
   json["k2"] = "b";
   int dist = 0;
-  JSONCPP_STRING str;
+  Json::String str;
   for (Json::ValueIterator it = json.begin(); it != json.end(); ++it) {
     dist = it - json.begin();
     str = it->asString().c_str();
@@ -2486,41 +2494,38 @@ JSONTEST_FIXTURE(IteratorTest, indexes) {
 JSONTEST_FIXTURE(IteratorTest, const) {
   Json::Value const v;
   JSONTEST_ASSERT_THROWS(
-    Json::Value::iterator it(v.begin()) // Compile, but throw.
+      Json::Value::iterator it(v.begin()) // Compile, but throw.
   );
 
   Json::Value value;
 
-  for(int i = 9; i < 12; ++i)
-  {
-    JSONCPP_OSTRINGSTREAM out;
+  for (int i = 9; i < 12; ++i) {
+    Json::OStringStream out;
     out << std::setw(2) << i;
-    JSONCPP_STRING str = out.str();
+    Json::String str = out.str();
     value[str] = str;
   }
 
-  JSONCPP_OSTRINGSTREAM out;
-  //in old code, this will get a compile error
+  Json::OStringStream out;
+  // in old code, this will get a compile error
   Json::Value::const_iterator iter = value.begin();
-  for(; iter != value.end(); ++iter)
-  {
+  for (; iter != value.end(); ++iter) {
     out << *iter << ',';
   }
-  JSONCPP_STRING expected = "\" 9\",\"10\",\"11\",";
+  Json::String expected = "\" 9\",\"10\",\"11\",";
   JSONTEST_ASSERT_STRING_EQUAL(expected, out.str());
 }
 
 struct RValueTest : JsonTest::TestCase {};
 
 JSONTEST_FIXTURE(RValueTest, moveConstruction) {
-#if JSON_HAS_RVALUE_REFERENCES
   Json::Value json;
   json["key"] = "value";
   Json::Value moved = std::move(json);
-  JSONTEST_ASSERT(moved != json); // Possibly not nullValue; definitely not equal.
+  JSONTEST_ASSERT(moved != json); // Possibly not nullValue; definitely not
+                                  // equal.
   JSONTEST_ASSERT_EQUAL(Json::objectValue, moved.type());
   JSONTEST_ASSERT_EQUAL(Json::stringValue, moved["key"].type());
-#endif
 }
 
 int main(int argc, const char* argv[]) {
@@ -2544,11 +2549,12 @@ int main(int argc, const char* argv[]) {
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareArray);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareObject);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, compareType);
+  JSONTEST_REGISTER_FIXTURE(runner, ValueTest, CopyObject);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, offsetAccessors);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, typeChecksThrowExceptions);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, StaticString);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, CommentBefore);
-  //JSONTEST_REGISTER_FIXTURE(runner, ValueTest, nulls);
+  // JSONTEST_REGISTER_FIXTURE(runner, ValueTest, nulls);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, zeroes);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, zeroesInKeys);
   JSONTEST_REGISTER_FIXTURE(runner, ValueTest, specialFloats);
@@ -2559,15 +2565,15 @@ int main(int argc, const char* argv[]) {
   JSONTEST_REGISTER_FIXTURE(runner, StreamWriterTest, writeZeroes);
 
   JSONTEST_REGISTER_FIXTURE(runner, ReaderTest, parseWithNoErrors);
-  JSONTEST_REGISTER_FIXTURE(
-      runner, ReaderTest, parseWithNoErrorsTestingOffsets);
+  JSONTEST_REGISTER_FIXTURE(runner, ReaderTest,
+                            parseWithNoErrorsTestingOffsets);
   JSONTEST_REGISTER_FIXTURE(runner, ReaderTest, parseWithOneError);
   JSONTEST_REGISTER_FIXTURE(runner, ReaderTest, parseChineseWithOneError);
   JSONTEST_REGISTER_FIXTURE(runner, ReaderTest, parseWithDetailError);
 
   JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseWithNoErrors);
-  JSONTEST_REGISTER_FIXTURE(
-      runner, CharReaderTest, parseWithNoErrorsTestingOffsets);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest,
+                            parseWithNoErrorsTestingOffsets);
   JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseWithOneError);
   JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseChineseWithOneError);
   JSONTEST_REGISTER_FIXTURE(runner, CharReaderTest, parseWithDetailError);
@@ -2577,9 +2583,12 @@ int main(int argc, const char* argv[]) {
 
   JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, issue164);
   JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, issue107);
-  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, commentAfterObject);
-  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, commentAfterArray);
-  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest, commentAfterBool);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest,
+                            commentAfterObject);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest,
+                            commentAfterArray);
+  JSONTEST_REGISTER_FIXTURE(runner, CharReaderFailIfExtraTest,
+                            commentAfterBool);
 
   JSONTEST_REGISTER_FIXTURE(runner, CharReaderAllowDropNullTest, issue178);
 
diff --git a/test/runjsontests.py b/test/runjsontests.py
index 48cfe82..dfdeca3 100644
--- a/test/runjsontests.py
+++ b/test/runjsontests.py
@@ -55,7 +55,7 @@ def compareOutputs(expected, actual, message):
 """ % (message, diff_line,
        safeGetLine(expected,diff_line),
        safeGetLine(actual,diff_line))
-        
+
 def safeReadFile(path):
     try:
         return open(path, 'rt', encoding = 'utf-8').read()
@@ -69,7 +69,43 @@ def runAllTests(jsontest_executable_path, input_dir = None,
         input_dir = os.path.join(os.getcwd(), 'data')
     tests = glob(os.path.join(input_dir, '*.json'))
     if with_json_checker:
-        test_jsonchecker = glob(os.path.join(input_dir, '../jsonchecker', '*.json'))
+        all_test_jsonchecker = glob(os.path.join(input_dir, '../jsonchecker', '*.json'))
+        # These tests fail with strict json support, but pass with jsoncpp extra lieniency
+        """
+        Failure details:
+        * Test ../jsonchecker/fail25.json
+        Parsing should have failed:
+        ["	tab	character	in	string	"]
+
+        * Test ../jsonchecker/fail13.json
+        Parsing should have failed:
+        {"Numbers cannot have leading zeroes": 013}
+
+        * Test ../jsonchecker/fail18.json
+        Parsing should have failed:
+        [[[[[[[[[[[[[[[[[[[["Too deep"]]]]]]]]]]]]]]]]]]]]
+
+        * Test ../jsonchecker/fail8.json
+        Parsing should have failed:
+        ["Extra close"]]
+
+        * Test ../jsonchecker/fail7.json
+        Parsing should have failed:
+        ["Comma after the close"],
+
+        * Test ../jsonchecker/fail10.json
+        Parsing should have failed:
+        {"Extra value after close": true} "misplaced quoted value"
+
+        * Test ../jsonchecker/fail27.json
+        Parsing should have failed:
+        ["line
+        break"]
+        """
+        known_differences_withjsonchecker = [ "fail25.json", "fail13.json", "fail18.json", "fail8.json",
+                                              "fail7.json", "fail10.json", "fail27.json" ]
+        test_jsonchecker = [ test for test in all_test_jsonchecker if os.path.basename(test) not in known_differences_withjsonchecker ]
+
     else:
         test_jsonchecker = []
     failed_tests = []
diff --git a/travis.sh b/travis.sh
deleted file mode 100755
index f80424b..0000000
--- a/travis.sh
+++ /dev/null
@@ -1,23 +0,0 @@
-#!/usr/bin/env sh
-# This is called by `.travis.yml` via Travis CI.
-# Travis supplies $TRAVIS_OS_NAME.
-#  http://docs.travis-ci.com/user/multi-os/
-# Our .travis.yml also defines:
-#   - SHARED_LIB=ON/OFF
-#   - STATIC_LIB=ON/OFF
-#   - CMAKE_PKG=ON/OFF
-#   - BUILD_TYPE=release/debug
-#   - VERBOSE_MAKE=false/true
-#   - VERBOSE (set or not)
-
-# -e: fail on error
-# -v: show commands
-# -x: show expanded commands
-set -vex
-
-env | sort
-
-meson --buildtype ${BUILD_TYPE} --default-library ${LIB_TYPE} . build-${LIB_TYPE}
-ninja -v -C build-${LIB_TYPE}
-ninja -v -C build-${LIB_TYPE} test
-rm -r build-${LIB_TYPE}
diff --git a/version b/version.txt
similarity index 100%
rename from version
rename to version.txt

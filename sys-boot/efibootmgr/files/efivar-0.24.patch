diff --git a/.gitignore b/.gitignore
index 44c700a..1036f2e 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,3 +7,4 @@ efibootmgr-*.tar.*
 core.*
 efibootmgr*.zip
 efibootmgr.spec
+.*.d
diff --git a/INSTALL b/INSTALL
index 876a535..3c70ad8 100644
--- a/INSTALL
+++ b/INSTALL
@@ -1,8 +1,12 @@
-Running 'make' builds the file src/efibootmgr/efibootmgr.
+Running 'make' builds the file src/efibootmgr.
 efibootmgr should be placed into /usr/sbin/.
 
 efibootmgr currently requires efivar version 0.19, as well as the pkg-config
-utility, to be built.
+utility, to be built. If you receive a message like the following:
+
+  src/include/efi.h:32:20: fatal error: efivar.h: No such file or directory
+
+then you have not installed these dependencies, which can be found at:
 
 efivar: https://github.com/rhinstaller/efivar
 pkg-config: http://pkgconfig.freedesktop.org
diff --git a/Make.defaults b/Make.defaults
new file mode 100644
index 0000000..efb3908
--- /dev/null
+++ b/Make.defaults
@@ -0,0 +1,44 @@
+prefix	?= /usr
+libdir	?= $(prefix)/lib64
+datadir	?= $(prefix)/share
+mandir	?= $(datadir)/man
+includedir ?= $(prefix)/include
+bindir	?= $(prefix)/bin
+sbindir	?= $(prefix)/sbin
+localedir ?= $(datadir)/locale/
+PCDIR	?= $(libdir)/pkgconfig
+DESTDIR	?=
+
+INSTALL ?= install
+CROSS_COMPILE	?=
+PKG_CONFIG = $(CROSS_COMPILE)pkg-config
+CC	:= $(if $(filter default,$(origin CC)),$(CROSS_COMPILE)gcc,$(CC))
+CCLD	:= $(if $(filter undefined,$(origin CCLD)),$(CC),$(CCLD))
+CFLAGS	?= -O2 -g
+AR	:= $(CROSS_COMPILE)gcc-ar
+NM	:= $(CROSS_COMPILE)gcc-nm
+RANLIB	:= $(CROSS_COMPILE)gcc-ranlib
+
+PKGS	=
+
+SUBDIR_CFLAGS ?=
+clang_cflags =
+gcc_cflags =
+cflags	= $(CFLAGS) $(SUBDIR_CFLAGS) \
+	-Werror -Wall -Wextra -Wsign-compare -Wstrict-aliasing \
+	-std=gnu11 -fshort-wchar -fPIC -flto \
+	-D_FILE_OFFSET_BITS=64 -D_GNU_SOURCE -DLOCALEDIR=\"$(localedir)\" \
+	$(if $(filter $(CC),clang),$(clang_cflags),) \
+	$(if $(filter $(CC),gcc),$(gcc_cflags),) \
+	$(call pkg-config-cflags)
+clang_ccldflags =
+gcc_ccldflags = -fno-merge-constants \
+	-Wl,--fatal-warnings,--no-allow-shlib-undefined,--default-symver \
+	-Wl,-O2 -Wl,--no-undefined-version
+ccldflags = $(cflags) $(CCLDFLAGS) $(LDFLAGS) \
+	$(if $(filter $(CCLD),clang),$(clang_ccldflags),) \
+	$(if $(filter $(CCLD),gcc),$(gcc_ccldflags),) \
+	$(call pkg-config-ccldflags)
+CPPFLAGS?=
+SOFLAGS=-shared
+LDLIBS=$(foreach lib,$(LIBS),-l$(lib)) $(call pkg-config-ldlibs)
diff --git a/Make.deps b/Make.deps
new file mode 100644
index 0000000..5a43fef
--- /dev/null
+++ b/Make.deps
@@ -0,0 +1,15 @@
+SRCDIR = $(realpath .)
+TOPDIR = $(realpath ..)
+
+include $(TOPDIR)/Make.version
+include $(TOPDIR)/Make.rules
+include $(TOPDIR)/Make.defaults
+
+.%.d : %.c
+	$(CC) $(cflags) $(CPPFLAGS) -MM -MG -MF $@ $^
+
+.%.d : %.S
+	$(CC) $(cflags) $(CPPFLAGS) -MM -MG -MF $@ $^
+
+SOURCES ?=
+deps : $(call deps-of,$(filter-out %.h,$(SOURCES)))
diff --git a/Make.rules b/Make.rules
new file mode 100644
index 0000000..e882a33
--- /dev/null
+++ b/Make.rules
@@ -0,0 +1,71 @@
+default : all
+
+.PHONY: default all deps clean install
+
+include $(TOPDIR)/Make.version
+
+all : deps
+
+deps :
+
+clean :
+
+install :
+
+%.a : %.so
+	$(AR) -cvqs $@ $^
+
+% : %.c
+
+% : | %.c
+	$(CCLD) $(ccldflags) $(CPPFLAGS) -o $@ $^ $(LDLIBS)
+
+%-static : %.c
+	$(CCLD) $(ccldflags) $(CPPFLAGS) -o $@ $^ $(LDLIBS)
+
+%.so :
+	$(CCLD) $(ccldflags) $(CPPFLAGS) $(SOFLAGS) \
+	  -Wl,-soname,$@.$(MAJOR_VERSION) \
+	  -o $@ $^ $(LDLIBS)
+
+%.o : %.c
+	$(CC) $(cflags) $(CPPFLAGS) -c -o $@ $(filter %.c %.o %.S,$^)
+
+%.S: %.c
+	$(CC) $(cflags) $(CPPFLAGS) -S $< -o $@
+
+%.E: %.c
+	$(CC) $(cflags) $(CPPFLAGS) -E $< -o $@
+
+%.c : %.h
+
+.%.d :
+
+define substitute-version =
+	sed						\
+		-e "s,@@VERSION@@,$(VERSION),g"		\
+		-e "s,@@LIBDIR@@,$(libdir),g"		\
+		-e "s,@@LIBEXECDIR@@,$(libexecdir),g"	\
+		$(1) > $(2)
+endef
+
+%.pc : %.pc.in
+	@$(call substitute-version,$<,$@)
+
+%.spec : %.spec.in
+	@$(call substitute-version,$<,$@)
+
+pkg-config-cflags = \
+	$(shell if [ -n "$(PKGS)" ]; then $(PKG_CONFIG) --cflags $(PKGS); fi)
+pkg-config-ldflags = \
+	$(shell if [ -n "$(PKGS)" ]; then $(PKG_CONFIG) --libs-only-L --libs-only-other $(PKGS) ; fi)
+pkg-config-ldlibs = \
+	$(shell if [ -n "$(PKGS)" ]; then $(PKG_CONFIG) --libs-only-l $(PKGS) ; fi)
+
+objects-of = \
+	$(patsubst %.c,%.o,$(1))
+
+define deps-of =
+	$(foreach src,$(filter %.c,$(1)),$(patsubst %.c,.%.d,$(src))) \
+	$(foreach src,$(filter %.S,$(1)),$(patsubst %.S,.%.d,$(src)))
+endef
diff --git a/Make.version b/Make.version
new file mode 100644
index 0000000..7def371
--- /dev/null
+++ b/Make.version
@@ -0,0 +1,3 @@
+MAJOR_VERSION = 0
+MINOR_VERSION = 12
+VERSION = $(MAJOR_VERSION).$(MINOR_VERSION)
diff --git a/Makefile b/Makefile
index 0f2f62c..35b7611 100644
--- a/Makefile
+++ b/Makefile
@@ -1,100 +1,55 @@
-  default: all
+TOPDIR = $(shell echo $$PWD)
 
-  SIGNING_KEY := pjones
-  RELEASE_MAJOR := 0
-  RELEASE_MINOR := 12
-  RELEASE_NAME := efibootmgr
-  VERSION := $(RELEASE_MAJOR).$(RELEASE_MINOR)
-  RELEASE_STRING := $(RELEASE_NAME)-$(RELEASE_MAJOR).$(RELEASE_MINOR)
+include $(TOPDIR)/Make.version
+include $(TOPDIR)/Make.rules
+include $(TOPDIR)/Make.defaults
 
-  CFLAGS = $(EXTRA_CFLAGS) -DEFIBOOTMGR_VERSION=\"$(RELEASE_MAJOR).$(RELEASE_MINOR)\" \
-	    -Wsign-compare -Wall -Werror -g -D_FILE_OFFSET_BITS=64 \
-	    -I/usr/include/efivar
+SUBDIRS := src
 
-  MODULES := src
+all clean install deps : | Make.version
+	@set -e ; for x in $(SUBDIRS) ; do \
+		$(MAKE) -C $$x $@ ; \
+	done
 
-  BINDIR := /usr/sbin
+all : efibootmgr.spec
 
-#--------------------------------------------
-# Generic Makefile stuff is below. You
-#  should not have to modify any of the stuff
-#  below.
-#--------------------------------------------
+efibootmgr efibootmgr-static :
+	$(MAKE) -C src $@
 
-#Included makefiles will add their deps for each stage in these vars:
-  INSTALLDEPS :=
-  CLEANDEPS :=
-  ALLDEPS := efibootmgr.spec
-  CLEANLIST := efibootmgr.spec
+$(SUBDIRS) :
+	$(MAKE) -C $@
 
-#Define the top-level build directory
-  BUILDDIR := $(shell pwd)
+.PHONY: $(SUBDIRS) 
 
-#Include make rules from each submodule (subdirectory)
-  include $(patsubst %,%/module.mk,$(MODULES))
+efibootmgr.spec : | Makefile Make.version
 
-  .PHONY: all clean install_list install install_link post_install tarball echotree default tag archive test-archive
+distclean :
+	$(MAKE) clean
+	@rm -vf efibootmgr.spec
 
-  all:  $(ALLDEPS)
-  clean: clean_list $(CLEANDEPS) 
-
-  clean_list:
-	rm -f $(CLEANLIST)
-
-  install_list: echotree $(INSTALLDEPS) 
-
-  install: all 
-	@make install_list | tools/install.pl copy
-
-  install_link: all
-	@make install_list | tools/install.pl link
-
-  post_install: 
-
-GITTAG = $(RELEASE_STRING)
-
-efibootmgr.spec : efibootmgr.spec.in Makefile
-	@sed -e "s,@@VERSION@@,$(VERSION),g" $< > $@
+GITTAG = $(VERSION)
 
 test-archive: efibootmgr.spec
-	@rm -rf /tmp/$(RELEASE_STRING) /tmp/$(RELEASE_STRING)-tmp
-	@mkdir -p /tmp/$(RELEASE_STRING)-tmp
-	@git archive --format=tar $(shell git branch | awk '/^*/ { print $$2 }') | ( cd /tmp/$(RELEASE_STRING)-tmp/ ; tar x )
-	@git diff | ( cd /tmp/$(RELEASE_STRING)-tmp/ ; patch -s -p1 -b -z .gitdiff )
-	@mv /tmp/$(RELEASE_STRING)-tmp/ /tmp/$(RELEASE_STRING)/
-	@cp efibootmgr.spec /tmp/$(RELEASE_STRING)/
-	@dir=$$PWD; cd /tmp; tar -c --bzip2 -f $$dir/$(RELEASE_STRING).tar.bz2 $(RELEASE_STRING)
-	@rm -rf /tmp/$(RELEASE_STRING)
-	@echo "The archive is in $(RELEASE_STRING).tar.bz2"
+	@rm -rf /tmp/efibootmgr-$(VERSION) /tmp/efibootmgr-$(VERSION)-tmp
+	@mkdir -p /tmp/efibootmgr-$(VERSION)-tmp
+	@git archive --format=tar $(shell git branch | awk '/^*/ { print $$2 }') | ( cd /tmp/efibootmgr-$(VERSION)-tmp/ ; tar x )
+	@git diff | ( cd /tmp/efibootmgr-$(VERSION)-tmp/ ; patch -s -p1 -b -z .gitdiff )
+	@mv /tmp/efibootmgr-$(VERSION)-tmp/ /tmp/efibootmgr-$(VERSION)/
+	@cp efibootmgr.spec /tmp/efibootmgr-$(VERSION)/
+	@dir=$$PWD; cd /tmp; tar -c --bzip2 -f $$dir/efibootmgr-$(VERSION).tar.bz2 efibootmgr-$(VERSION)
+	@rm -rf /tmp/efibootmgr-$(VERSION)
+	@echo "The archive is in efibootmgr-$(VERSION).tar.bz2"
 
 tag:
 	git tag -s $(GITTAG) refs/heads/master
 
 archive: tag efibootmgr.spec
-	@rm -rf /tmp/$(RELEASE_STRING) /tmp/$(RELEASE_STRING)-tmp
-	@mkdir -p /tmp/$(RELEASE_STRING)-tmp
-	@git archive --format=tar $(GITTAG) | ( cd /tmp/$(RELEASE_STRING)-tmp/ ; tar x )
-	@mv /tmp/$(RELEASE_STRING)-tmp/ /tmp/$(RELEASE_STRING)/
-	@cp efibootmgr.spec /tmp/$(RELEASE_STRING)/
-	@dir=$$PWD; cd /tmp; tar -c --bzip2 -f $$dir/$(RELEASE_STRING).tar.bz2 $(RELEASE_STRING)
-	@rm -rf /tmp/$(RELEASE_STRING)
-	@echo "The archive is in $(RELEASE_STRING).tar.bz2"
-
-tarball: archive
-
-#The rest of the docs...
-  doc_TARGETS += COPYING README INSTALL
-
-echotree:
-	@# making directory tree 
-	@#RPM FORMAT:
-	@# %defattr(-, user, group) 
-	@# %attr(4755,user,group)  filename
-	@# filename
+	@rm -rf /tmp/efibootmgr-$(VERSION) /tmp/efibootmgr-$(VERSION)-tmp
+	@mkdir -p /tmp/efibootmgr-$(VERSION)-tmp
+	@git archive --format=tar $(GITTAG) | ( cd /tmp/efibootmgr-$(VERSION)-tmp/ ; tar x )
+	@mv /tmp/efibootmgr-$(VERSION)-tmp/ /tmp/efibootmgr-$(VERSION)/
+	@cp efibootmgr.spec /tmp/efibootmgr-$(VERSION)/
+	@dir=$$PWD; cd /tmp; tar -c --bzip2 -f $$dir/efibootmgr-$(VERSION).tar.bz2 efibootmgr-$(VERSION)
+	@rm -rf /tmp/efibootmgr-$(VERSION)
+	@echo "The archive is in efibootmgr-$(VERSION).tar.bz2"
 
-# Here is a list of variables that are assumed Local to each Makefile. You can
-#   safely stomp on these values without affecting the build.
-# 	MODULES
-#	FILES
-#	TARGETS
-#	SOURCES
diff --git a/README b/README
index edbce4b..280a8c9 100644
--- a/README
+++ b/README
@@ -93,21 +93,8 @@ Typical usage:
    from BootOrder.
 
 6) A system administrator wants to create a boot option to network
-   boot (PXE).  Unfortunately, this requires knowing a little more
-   information about your system than can be easily found by
-   efibootmgr, so you've got to pass additional information - the ACPI
-   HID and UID values.  These can generally be found by using the EFI
-   Boot Manager (in the EFI environment) to create a network boot
-   entry, then using efibootmgr to print it verbosely.  Here's one example:
-
-     Boot003* Acpi(PNP0A03,0)/PCI(5|0)/Mac(00D0B7F9F510) \
-	ACPI(a0341d0,0)PCI(0,5)MAC(00d0b7f9f510,0)
-
-   In this case, the ACPI HID is "0A0341d0" and the UID is "0".
-   For the zx2000 gigE, the HID is "222F" and the UID is "500".
-   For the rx2000 gigE, the HID is "0002" and the UID is "100".
-   You create the boot entry with:
-   'efibootmgr -c -i eth0 -H 222F -U 500 -L netboot'
+   boot (PXE).  You create the boot entry with:
+   'efibootmgr -c -i eth0 -L netboot'
 
 Many other uses may be found.
 
diff --git a/doc/TODO b/TODO
similarity index 100%
rename from doc/TODO
rename to TODO
diff --git a/doc/ChangeLog b/doc/ChangeLog
deleted file mode 100644
index 7673cbe..0000000
--- a/doc/ChangeLog
+++ /dev/null
@@ -1,757 +0,0 @@
-commit de0ca446e7e5439306f7f54806d1a15310588426
-Author: Jordan Hargrave <Jordan_Hargrave@dell.com>
-Date:   Thu Nov 29 10:11:43 2012 -0600
-
-    Add patches from fedora release
-    * Wed Nov 28 2012 Matthew Garrett <mjg59@srcf.ucam.org> - 0.5.4-14
-    - efibootmgr-0.5.4-Work-around-broken-Apple-firmware.patch
-      Resolves: #873629
-    - efibootmgr-0.5.4-Remove-device-path-padding-on-non-Itanium.patch - improve
-      spec conformance
-
-commit 9392250bd8668ef7544530d17800dc0271cd8bf3
-Author: Jordan Hargrave <Jordan_Hargrave@dell.com>
-Date:   Tue Apr 24 12:58:57 2012 -0500
-
-    From: Lane Winner<lane.winner@oracle.com>
-    
-    make_boot_var does not check for failed status with create_variable.
-    This can result in a memory leak.
-    Additionally the user should be notified of the problem.
-    
-    We encounter this issue on one system after filling up the UEFI boot list
-    with dummy devices.
-    
-    The patch fix the problem. It was verified on a Mensa system using RHEL 6.0
-    
-    Signed-off-by: Yinghai Lu<yinghai@kernel.org>
-
-commit 8602b3c41701572669b1f8b9c45409d98405eca2
-Author: Peter Jones <pjones@redhat.com>
-Date:   Wed Jul 14 11:26:49 2010 -0700
-
-    Handle sector_size != 512.
-    
-    Disks can have 4kB sectors now, so don't just bail out when that's the
-    case.
-
-commit fb3d9a8d9bfd580d23b14b384a393510e0a749ac
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jul 23 14:20:19 2009 -0500
-
-    fix disk minor number discovery
-    
-    Raymund Will noted disk_info_from_fd() incorrectly used logical &&
-    instead of bitwise & when obtaining the minor number.
-    
-    Reported in https://bugzilla.novell.com/show_bug.cgi?id=524529#c1
-
-commit acac7412e8e0819fc66cdadc06ad4ca535f29b35
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jul 23 14:18:11 2009 -0500
-
-    fix minor memory leak
-    
-    David Binderman noted new_data was being allocated but not freed.  Not
-    a big deal as the program exits soon thereafter (and is thus freed),
-    but worth fixing anyhow.
-    
-    Fixes https://bugzilla.novell.com/show_bug.cgi?id=524529#c1
-
-commit c8d6ceaa7b33f952bcf32bc017ce8b5d7d659267
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Jan 11 15:09:12 2008 -0600
-
-    update ChangeLog
-
-commit 6e6bf6fc7665851798a6c2c92893ebb629e42aff
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Jan 11 15:08:12 2008 -0600
-
-    replacing elilo < 3.6-6, not -5
-    
-    per conversation with clumens.
-
-commit 4c1fd35da4d0478074e08c10225eb590576acf91
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jan 3 12:19:28 2008 -0600
-
-    RPM spec rewrite for Fedora inclusion
-    
-    efibootmgr is being split out of the elilo SRPM in Fedora, into its
-    own SRPM.
-
-commit 833cf4c1266ef72357948299008a22bfb80aa3f3
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jan 3 12:18:31 2008 -0600
-
-    Makefile cleanups
-    
-    bump version
-    
-    take an EXTRA_CFLAGS argument so rpmbuild can give us it's CFLAGS
-    without overriding ours.
-    
-    exclude .git and *~ files from the tarball.
-
-commit f0a8b91ba45ff4cf251805cc29aed4f8672c1801
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jan 3 12:16:35 2008 -0600
-
-    src/lib/efi.c: include linux/types.h
-    
-    patch from Fedora.
-
-commit f387d5c5bde5d7129e41638e92faa2d38b7ad5a1
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jan 3 12:15:18 2008 -0600
-
-    make sure GPT_HEADER_SIGNATURE is a 64-bit value
-    
-    patch from Debian / Ubuntu 0.5.3-3ubuntu1.
-
-commit 7b53efa45112f28e97451bdc16e6c6a68740bd79
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Nov 12 13:31:32 2007 -0600
-
-    avoid more unaligned access warnings
-
-commit 048197821f9ae2ef9e0c2bd4065649e72332e2dc
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Nov 12 12:25:42 2007 -0600
-
-    cleanup a few unaligned access warnings
-
-commit fa3942b34f1533659af8fe3f6fffb3b4acf4ee10
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Nov 12 12:12:37 2007 -0600
-
-    cleanup exit values a little
-
-commit c7e236783a79b6977df0ba03db0f92fabffc4b31
-Author: Doug Chapman <doug.chapman@hp.com>
-Date:   Mon Nov 12 11:32:12 2007 -0500
-
-    patch to make efibootmgr have non-zero exit code on errors
-    
-    We have some automated tools that use efibootmgr which are having a hard
-    time detecting when efibootmgr fails since it exits with 0 on many
-    failures.  This patch catches (most) errors and exits with non-zero.  I
-    also added several error messages for to make it more obvious what was
-    wrong with the command line arguments.
-    
-    Signed-off-by: Matt Domsch <Matt_Domsch@dell.com>
-
-commit ecd3c24cb6bee5072ff6d1292456ee3b2cc91019
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Jul 9 16:47:50 2007 +0000
-
-    add -lz to libs, needed when libpci happens to need it
-
-commit e192a055e0803263b71f89db732de73d5cf4de9b
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Jul 9 16:23:34 2007 +0000
-
-    apply patch from Dave Jiang <djiang@mvista.com> to enable cross-building
-
-commit 0ee8ecc10109b91d0a77098d5596f56780c862d8
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Aug 11 17:37:04 2005 +0000
-
-    v0.5.2.2
-
-commit 8097e44fbc1d022241837f318f57131b1df80adf
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Aug 11 17:36:29 2005 +0000
-
-    document -@ option
-
-commit c87e07e8e479220e696438dbeaf18ce73dafe2c8
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Aug 11 16:55:20 2005 +0000
-
-    make efi_variable_t.DataSize be unsigned long, to match kernel implementation.  This isn't ideal, I'd prefer to be able to have a 32-bit efibootmgr on a 64-bit kernel, but with efi_status_t being a long also, we're already stuck with needing a native copy.
-
-commit 5816bbbf56b37c9eee02a3539e99bffa8aec28e1
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Aug 10 15:59:33 2005 +0000
-
-    clean up extra_opts_file handling
-
-commit 8b02b12e1153f5bbf5010c16a5614464b5534c88
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Aug 10 15:28:30 2005 +0000
-
-    new option -@ grabs extra variable args from a file
-
-commit b6185ed1b3c78a37594c2a25200536e7c4172070
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Aug 10 05:34:53 2005 +0000
-
-    add -g flag, move _FILE_OFFSET_BITS=64 to Makefile
-
-commit d9f0ef65ca0f02003fadb72e3e04d5120bed13a3
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Aug 10 05:30:14 2005 +0000
-
-    v0.5.2
-
-commit 3791b2f4bae1795c6f32b1db8cfa03a2cc80fc39
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Aug 10 05:28:23 2005 +0000
-
-    move _FILE_OFFSET_BITS definition into Makefile
-
-commit 71fc95596c8cb6d2dabcd2672dda053ed23eae7c
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue Jul 26 19:37:11 2005 +0000
-
-    parse PCI domain information in make_net_load_option() on 2.6 kernels
-
-commit 2efd000d314e0f339ba71a96cace4132f9f17072
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue Jul 26 19:32:24 2005 +0000
-
-    properly free allocated memory (caught by valgrind)
-
-commit 2108aa866558c48251fc7a89c24693be2d9e3563
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue Mar 8 22:54:53 2005 +0000
-
-    applied patch from Alex Williamson which causes BootXXXX values to be printed in uppercase hex rather than lowercase.  This also now allows the full 64K boot entries, rather than requiring they start with a zero.  Release 0.5.1
-
-commit 935544f4a999fbd1d88ab1d3d5d6b3edfcca0861
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Aug 26 21:02:14 2004 +0000
-
-    put linux.dell.com in spec file
-
-commit 418e9d92ed2cb186c0cc0f1bacd6140934ec8eef
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Aug 26 20:27:28 2004 +0000
-
-    version 0.5.0-test4 released as v0.5.0 with no code changes
-
-commit 833bfe2b8614169a952f554f460e112148bbb3bc
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jun 9 21:51:19 2004 +0000
-
-    Add PCI parent devices to device path for netboot and EDD30 entries
-
-commit f9381ba1a4c874d04a759b750e3769379067bd9e
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jun 9 21:50:22 2004 +0000
-
-    changelog for version 0.5.0-test4
-
-commit a276070603deafa2d2fc8cd7bf8506265583369e
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jun 9 21:49:58 2004 +0000
-
-    version 0.5.0-test4
-
-commit 8078fc242cbffa91efa3607b5d03b2948c93f459
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jun 9 21:49:33 2004 +0000
-
-    Don't let read_boot_order() return EFI_NOT_FOUND when it is about to create it.
-
-commit 1616ceb1acc0eae3223c8494f4ee829137654ada
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jun 9 21:48:33 2004 +0000
-
-    Add libpci to libraries linked in
-
-commit 05904ff36fd78cba530cb917dd102af6520fcf56
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jun 9 21:47:53 2004 +0000
-
-    Add Joshua Giles entry
-
-commit 51ecfcf601955f4a188de55d07b043a938670bf8
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Sat Apr 24 15:18:57 2004 +0000
-
-    fix reversed logic in create_or_edit_variable(), remove extraneous printks in sysfs_read/write()
-
-commit 1310d761d7bf0a23b60570afd6774dbc61ad68a8
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Feb 5 23:01:53 2004 +0000
-
-    Add ability to add/change/delete Timeout, reflect this everywhere.
-
-commit f5cae27869d02ee4c7b89e6dcf6b77fd78932a25
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Dec 19 22:09:01 2003 +0000
-
-    Remove extra sizeof() in definition of BLKGETSIZE64.  It's
-    unnecessary, and causes new gcc 3.3.x compilers to complain and fail.
-
-commit 7c47e6971a98c4edac379224cd5e7cdf51cbe5dc
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue Sep 9 19:49:27 2003 +0000
-
-    More procfs to sysfs cleanups
-    Release version 0.5.0-test1
-
-commit 39fbc273e3632484062506bbbeff2fe7c85c45fc
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Sep 4 19:36:18 2003 +0000
-
-    - Seperated access to variables through /proc into efivars_procfs.[ch]
-    - Added efivars_sysfs.h to access variables through sysfs.
-    - Moved around some functions, cleaned up some duplication.
-
-commit 59ac9c733c6685436ae3fc2f58f21f13b1b422b7
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Aug 11 20:28:05 2003 +0000
-
-    * Mon Aug 11 2003 Matt Domsch <Matt_Domsch@dell.com>
-    - fixed unaligned access errors
-    - removed extraneous printing of mac addr when creating netboot entries
-    - sync docbook to README
-    - whitespace cleanups
-
-commit 7a37ede2e8bf96bb45ac993d92e9ab5102c61278
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jul 31 18:50:33 2003 +0000
-
-    Adding filelist-rpm
-
-commit 9d62f9c5a4972acfa2b9e2385ac4ca30d5820dc7
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jul 31 18:46:46 2003 +0000
-
-    * Thu Jul 31 2003 Matt Domsch <Matt_Domsch@dell.com>
-    - Applied patch from Dann Frazier to enable creating netboot entries.
-    - update AUTHORS with Dann's netboot contribution.
-    - Until we can get the ACPI HID and UID programatically, make the user
-      pass them in when creating a netboot entry.
-    - Add O_DIRECT support for reading the disk.
-    - Fix unparse_hardware_path() for the PCI case - the device and function
-      values were printed in reverse order.
-    - Fix the README file to reflect all the options that can be passed, and
-      add a new item for netboot entries.
-    - whitespace cleanups
-
-commit 00098507288b5491976cb9761920e373f172d570
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Oct 25 15:22:44 2002 +0000
-
-    - Patch from Fabien Lebaillif - Delamare increases the length of the boot
-    option description from 40 to 64 bytes.
-
-commit 359277959b1faca0da15fdff0012b6493e4dbe52
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Oct 25 15:07:41 2002 +0000
-
-    Added efibootmgr.8 man page (generated from efibootmgr.8.docbook
-    with docbook2man)
-
-commit 458f91ca09a4a073aa7a95d58e70f1adcfe8a54f
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Oct 25 15:04:17 2002 +0000
-
-    * Tue Oct 22 2002 Matt Domsch <Matt_Domsch@dell.com>
-    - ran docbook2man on the man page Dann Frazier created
-    - Added man page to spec file
-    - Added patches from Dann Frazier
-      - Removes the requirement to be root to run efibootmgr.  This lets
-        mortal users run efibootmgr to check the version, and see the
-        --help output. It should also allow efibootmgr to work under
-        security systems without the strict root/non-root dichotomy.
-        - Checks to see if a boot option was specified when a boot option
-        deletion was requested.
-    - Released version 0.4.1
-    
-    * Sun Jul 21 2002 Matt Domsch <Matt_Domsch@dell.com>
-    - Added kernel_has_blkgetsize64() test, now uses BLKGETSIZE64 if on a
-      known-good kernel.  This is important when the Large Block Device (64-bit
-      block address) patch gets merged into the 2.5 kernel.
-
-commit f9875103b6fbc426a3c4b52580cafea674f13a7f
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Jul 22 01:39:19 2002 +0000
-
-    moved uname() call into kernel_has_blkgetsize64, renamed that function
-
-commit f479f52feee067ac047c81a3c53e63ae5836a2a6
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Sun Jul 21 04:06:55 2002 +0000
-
-    added uname test for calling BLKGETSIZE64 ioctl
-
-commit 028b8c693cc0668d1c36cc7f39575bb746025ace
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed May 1 18:20:25 2002 +0000
-
-    moved executable to /usr/sbin/
-
-commit 2a51b704adb0fe61e90c51749c397933321f56f1
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed May 1 16:06:27 2002 +0000
-
-    moved location of tarball on domsch.com
-
-commit cf0ca520e0bf2e4c28aa8b6226d54e34f6529801
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed May 1 15:57:22 2002 +0000
-
-    tagging as version 0.4.0
-
-commit a02d1ef54c3f831761e1a1a6fb1f52db602475a9
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed May 1 15:52:55 2002 +0000
-
-    *** empty log message ***
-
-commit b001c78107cbab59982b5a7513e6b1832d373b22
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed May 1 15:52:01 2002 +0000
-
-    use _FILE_OFFSET_BITS
-
-commit 7fb06655b7d6ee7358fe14683bd78463933e5d43
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue Apr 30 20:14:38 2002 +0000
-
-    added 0x's to some printfs
-
-commit f7f2433a5a88456555e85f0206410f10db7b943d
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Apr 8 18:30:10 2002 +0000
-
-    *** empty log message ***
-
-commit 983da33189d001578315b633fad1622e06e3f04d
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Apr 8 18:27:54 2002 +0000
-
-    make sure partition number arg is in the disk
-
-commit dd39faedb4ed5e018e4843936b98875747bb57e5
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Sat Apr 6 03:56:36 2002 +0000
-
-    *** empty log message ***
-
-commit 69811b3cd8286db79af9e4f517cf8e8e7a9c2019
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Sat Apr 6 03:55:13 2002 +0000
-
-    added syncs to tarball target - otherwise NFS isn't fast enough to catch the deletions of the CVS directories
-
-commit 62933f80aa22e07cb8e93e969fce6a88dc5799b3
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Sat Apr 6 03:42:25 2002 +0000
-
-    added __leXX_to_cpu in what currently are commented out lines
-
-commit 8f72b1e6d7a09d2908b3c222c42966502bd03084
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue Apr 2 23:51:37 2002 +0000
-
-    added docbook manpage author
-
-commit a6e83d4b26663ed1317217baa539a205efe1b065
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue Apr 2 23:49:09 2002 +0000
-
-    Makefile: - updated version and date
-    efibootmgr.spec - updated version
-    src/efibootmgr/efibootmgr.c - minor changes
-    src/include/efi.h - efi_guid_t endianness fixups
-    src/include/gpt.h - minor changes
-    src/include/list.h - list_for_each_safe addition
-    src/lib/efi.c - efi_guid_t endianness fixups
-    src/lib/gpt.c - GPT parsing and efi_guid_t endianness fixups
-
-commit d227f9f1b4e6468f36ec9a60eb9630cfc1818fef
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue Apr 2 23:44:52 2002 +0000
-
-    *** empty log message ***
-
-commit 41e1acbc40f645e06c21037e183c13bee01be969
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Sat Mar 30 23:06:09 2002 +0000
-
-    From: bdale@gag.com [mailto:bdale@gag.com]
-    Sent: Saturday, March 30, 2002 2:56 PM
-    To: matt_domsch@exchange.dell.com
-    Subject: man page for efibootmgr
-    
-    
-    Hi.  Dann Frazier just sent me sgml source for a man page for efibootmgr,
-    you can find it attached to Debian bug 140514, which you can retrieve from
-    
-    	http://bugs.debian.org/140514
-    
-    Feel free to incorporate this in a future release.  I've folded it into my
-    Debian package of efibootmgr for now.
-    
-    Bdale
-
-commit 69a8826d5048b03c992e43c89c3086bae30f6bf2
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Jan 18 16:48:54 2002 +0000
-
-    Don't use BLKGETSIZE64 ioctl yet, it's broken on kernels 2.4.15-2.4.18, 2.5.0-2.5.3 at least
-
-commit 40e24ea0d24fecbc0867494e011aee0b3497c72d
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jan 3 17:54:55 2002 +0000
-
-    added back in read last sector IOCTL hack, but only after read() fails
-
-commit d29c2b31fc95d45e8232d08d16644dd748a48e6c
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jan 3 17:24:23 2002 +0000
-
-    Cleaned up use of scandir namelists
-
-commit c380db3c9a897fc66d8fb9c2d7b4ced92df71094
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jan 3 17:11:04 2002 +0000
-
-    really fixed find_write_victim(), added error message when creating a load option on a disk with no partition table.
-
-commit cb5fa0f50058ed7078b001b16729b6fb77936c66
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jan 2 22:41:29 2002 +0000
-
-    Fixed find_write_victim().
-    CV: ----------------------------------------------------------------------
-
-commit 0787a1b3fca6de2923feea974668c01c802f5f86
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jan 2 20:54:41 2002 +0000
-
-    - Changed PROC_DIR_EFI to PROC_DIR_EFI_VARS
-    - write_variable() now searches /proc/efi/vars for a variable that's not
-      the one being written.  The EFI 1.1 sample implementation changed the
-      name of the "victim" being written to (was Efi-xxxxx, now EFI-xxxxx), so
-      previous versions of efibootmgr don't work with the new firmware.  This
-      should fix that up.
-
-commit b4b3ca70f000b6e4fa93a92393014d445920d7ab
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Dec 7 23:18:27 2001 +0000
-
-    *** empty log message ***
-
-commit 7ef8eb0d0d2c9fd7bfa6fb7b0f8b928ac69e9f3b
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Dec 7 23:08:02 2001 +0000
-
-    printf'ing on IA64, test for disk type (MBR or GPT) fix attempt
-
-commit 25a4b1d732ee0fd8fd2e50f4bdb5d809282d0cf9
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Dec 7 20:58:39 2001 +0000
-
-    * Fri Dec 7 2001 Matt Domsch <Matt_Domsch@dell.com>
-    - Removed read last sector ioctl hack, it's not needed anymore.  The
-      kernel takes care of it for us with a new patch.
-    - Added test for valid PMBR, similar to parted and the kernel.
-    - Added test for returning size of block device as a u64.
-    - Added test for returning sector size as int, and use that.
-    - Changed GPT struct and member names to be more Linux-like.
-    - added -g option to force disk with invalid PMBR to be treated as GPT anyhow.
-    - released v0.4.0
-
-commit 703415a153bbf4b2c2e8770f1bcc61f14c2047c8
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Aug 10 18:40:45 2001 +0000
-
-    fixed stat.st_rdev mask
-
-commit 04564ca2bff64fc1e7f05617b4335132115acebf
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Aug 10 02:49:39 2001 +0000
-
-    added uniqueness to MBR signature
-
-commit 510449c56f782b5eeabca6431dafe7de748279a3
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Aug 6 15:22:15 2001 +0000
-
-    Applied Richard Hirst patch to fix efichar_char_strcmp()
-
-commit 272db079c290964077737c5427bf2db97d2e78bb
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Aug 3 22:17:48 2001 +0000
-
-    warn on duplicate boot entry name; release 0.3.3
-
-commit 58b7e057f6945b28384a86cf3b9e45f50b7fc66a
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Jul 30 21:53:26 2001 +0000
-
-    really fixed optional data length
-
-commit d0ad3bd8d488b2bc965ea78f431e130ac8386b50
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Jul 30 20:57:53 2001 +0000
-
-    Added AUTHORS, fixed counting length of optional data
-
-commit 5f9f555f8bfc6157183e4c76eae344e43d932394
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Jul 30 15:07:14 2001 +0000
-
-    Use device number (i.e. 0800) for signature on MBR disks, as that will be system-unique.
-
-commit e089c04b4ce9be4489a44be866334a6034f2e1b3
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Mon Jul 30 13:15:40 2001 +0000
-
-    Added check for zero signature on MBR-style disks, and -w flag to write a random signature in that case.
-
-commit 23dc432bc1a34a23cffa232565dbc8083225f24e
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Jul 27 14:52:54 2001 +0000
-
-    tagging with 0.3.3-test3
-
-commit bddbd08efd75daa74575d697c8ebac2714a1ade8
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri Jul 27 12:57:23 2001 +0000
-
-    added test against running as non-root
-
-commit 44ec02672afea5a1c380f906622ff60ef54df956
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Thu Jul 26 15:28:46 2001 +0000
-
-    unparse optional args passed to bootloader too.
-
-commit c78d3ba9b5337356a1e14affc025a440a37ab3ef
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jul 25 21:13:58 2001 +0000
-
-    Bumped version.
-
-commit fbb56ba254c297816a278494f5d1e597fa626752
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jul 25 20:57:46 2001 +0000
-
-    Added -t option to allow writing to a file (for testing)
-
-commit 287d926464184583cb8b15e639e167b197b2cb4d
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Wed Jul 25 19:53:16 2001 +0000
-
-    added passing extra args to bootloader
-
-commit f8180a6628d18c6cd60ea763715eb15cb8e42940
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue May 22 19:04:23 2001 +0000
-
-    efi_status_t is now unsigned long, release v0.3.2
-
-commit 303f178a2b7ec830fd7bf6611c1949042b26107c
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue May 22 14:29:08 2001 +0000
-
-    *** empty log message ***
-
-commit 56cc281258c4b835407112af6768464f65ad49d4
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue May 22 12:49:01 2001 +0000
-
-    Applied patch from Andreas Schwab <Andreas.Schwab@suse.de>:
-    
-    Here is a patch to fix remove_from_boot_order:
-    
-    --- efibootmgr.c	2001/05/19 00:05:38	1.1
-    +++ efibootmgr.c	2001/05/22 13:30:31
-    @@ -319,7 +319,7 @@
-     	uint16_t *new_data, *old_data;
-     	int old_i,new_i;
-    
-    -	read_boot_order(&boot_order);
-    +	status = read_boot_order(&boot_order);
-     	if (status != EFI_SUCCESS) return status;
-    
-     	/* If it's empty, yea! */
-
-commit 51ab0fa632a9e9a07f3c5d53b3ad53708e690b31
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri May 18 22:58:56 2001 +0000
-
-    usage() shouldn't make you think you can pass args to the OS loader
-
-commit 2d66962dfb107d2d7fe1d931667e29d2a89f4509
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri May 18 21:34:45 2001 +0000
-
-    Initial commit, should anyone want to make it a separate RPM package.
-
-commit 6402c3f02eb8f6b76798fa81da42163ba1f94cea
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri May 18 21:33:55 2001 +0000
-
-    Initial commit
-
-commit 064110db2f4ba2a6a5e5cfade5445f8ea6cdecb6
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Fri May 18 21:14:10 2001 +0000
-
-    * Fri May 18 2001 Matt Domsch <Matt_Domsch@dell.com>
-    - Padded HARDDRIVE_DEVICE_PATH out to please EFI Boot Manager.
-    - Incorporated patches from Andreas Schwab
-      - replace __u{8,16,32,64} with uint{8,16,32,64}_t
-      - use _FILE_OFFSET_BITS
-      - fix a segfault
-    - release v0.3.0
-
-commit 8bd81a6f41bc91f008c2131c4ff4fcfd3f4baf63
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue May 15 22:16:23 2001 +0000
-
-    Removed extraneous copyright lines, as this is all written by Matt now.
-
-commit 8847549ff1f6ba3d08a2b5a037f8a8c856e850b9
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue May 15 21:29:03 2001 +0000
-
-    Changed version string to read 0.2.0
-
-commit 80e2fb2dda2365280b85018fca525768e8f454f8
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue May 15 21:16:19 2001 +0000
-
-    Removed most warnings when compiled with -Wall
-
-commit 47a1b011cc497cb6052cc3279865fa567cfcde16
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue May 15 20:47:18 2001 +0000
-
-    * Ran all files through dos2unix to fix linefeed issues
-    * changed --write to --create in efibootmgr.[ch]
-    * Added #include <stdlib.h> to efichar.c to remove a warning
-
-commit 4576ed6c68cf37913600261c4754a734bc65f3ae
-Author: mebrown <mebrown>
-Date:   Tue May 15 20:20:54 2001 +0000
-
-    add convenience Makefiles
-
-commit c138b6297915c2c571932ac029f7b0892926074a
-Author: mebrown <mebrown>
-Date:   Tue May 15 19:52:36 2001 +0000
-
-    readability tweaks to makefiles
-
-commit 1bbd86b2e79b2b31166359686a555feee4c4fd7d
-Author: mebrown <mebrown>
-Date:   Tue May 15 19:43:12 2001 +0000
-
-    mostly-working makefile system
-
-commit cf4b5b088132c274bd5ef69f7c3b7f9b8af64817
-Author: Matt Domsch <Matt_Domsch@dell.com>
-Date:   Tue May 15 18:56:53 2001 +0000
-
-    Initial revision
diff --git a/efibootmgr.spec.in b/efibootmgr.spec.in
index c794588..e9168da 100644
--- a/efibootmgr.spec.in
+++ b/efibootmgr.spec.in
@@ -5,11 +5,11 @@ Release: 1%{?dist}
 Group: System Environment/Base
 License: GPLv2+
 URL: http://github.com/rhinstaller/%{name}/
-BuildRequires: git
+BuildRequires: git, popt-devel
 BuildRequires: efivar-libs >= 0.19 , efivar-devel >= 0.19
 BuildRoot: %(mktemp -ud %{_tmppath}/%{name}-%{version}-%{release}-XXXXXXXX)
 # EFI/UEFI don't exist on PPC
-ExclusiveArch: %{ix86} x86_64 aarch64
+ExclusiveArch: %{ix86} x86_64 aarch64 arm
 
 # for RHEL / Fedora when efibootmgr was part of the elilo package
 Conflicts: elilo <= 3.6-6
@@ -39,20 +39,18 @@ make %{?_smp_mflags} EXTRA_CFLAGS='%{optflags}'
 
 %install
 rm -rf %{buildroot}
-mkdir -p %{buildroot}%{_sbindir} %{buildroot}%{_mandir}/man8
-install -p --mode 755 src/%{name}/%{name} %{buildroot}%{_sbindir}
-gzip -9 -c src/man/man8/%{name}.8 > src/man/man8/%{name}.8.gz
-touch -r src/man/man8/%{name}.8 src/man/man8/%{name}.8.gz
-install -p --mode 644 src/man/man8/%{name}.8.gz %{buildroot}%{_mandir}/man8
+%makeinstall
 
 %clean
 rm -rf %{buildroot}
 
 %files
 %defattr(-,root,root,-)
-%{_sbindir}/%{name}
-%{_mandir}/man8/%{name}.8.gz
-%doc README INSTALL COPYING
+%{!?_licensedir:%global license %%doc}
+%license COPYING
+%{_sbindir}/*
+%{_mandir}/man8/*
+%doc README
     
 %changelog
 * Thu May 28 2015 Peter Jones <pjones@redhat.com> - 0.12-1
@@ -82,7 +80,7 @@ rm -rf %{buildroot}
 * Thu Jan  3 2008 Matt Domsch <Matt_Domsch@dell.com> 0.5.4-1
 - split efibootmgr into its own RPM for Fedora/RHEL.
 
-* Thu Aug 24 2004 Matt Domsch <Matt_Domsch@dell.com>
+* Tue Aug 24 2004 Matt Domsch <Matt_Domsch@dell.com>
 - new home linux.dell.com
 
 * Fri May 18 2001 Matt Domsch <Matt_Domsch@dell.com>
diff --git a/filelist-rpm b/filelist-rpm
deleted file mode 100644
index 07cd431..0000000
--- a/filelist-rpm
+++ /dev/null
@@ -1,3 +0,0 @@
- %attr(0755,root,root) /usr/sbin
- %attr(0755,root,root) /usr/sbin/efibootmgr
- %attr(0444,root,root) /usr/share/man/man8/efibootmgr.8
diff --git a/src/.gitignore b/src/.gitignore
new file mode 100644
index 0000000..3b59c9d
--- /dev/null
+++ b/src/.gitignore
@@ -0,0 +1,4 @@
+efibootmgr
+eficonman
+efibootnext
+efibootdump
diff --git a/src/Makefile b/src/Makefile
index 6615d46..74054a8 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -1,2 +1,48 @@
-%:
-	+make -C ../ $*
+SRCDIR = $(realpath .)
+TOPDIR = $(realpath ..)
+
+include $(TOPDIR)/Make.version
+include $(TOPDIR)/Make.rules
+include $(TOPDIR)/Make.defaults
+
+SUBDIR_CFLAGS = -I$(SRCDIR)/include
+
+BINTARGETS=efibootmgr efibootdump
+TARGETS=$(BINTARGETS)
+
+all : deps $(TARGETS)
+
+EFIBOOTMGR_SOURCES = efibootmgr.c efi.c unparse_path.c
+EFICONMAN_SOURCES = eficonman.c
+EFIBOOTDUMP_SOURCES = efibootdump.c unparse_path.c
+EFIBOOTNEXT_SOURCES = efibootnext.c
+ALL_SOURCES=$(EFIBOOTMGR_SOURCES)
+-include $(call deps-of,$(ALL_SOURCES))
+
+efibootmgr : $(call objects-of,$(EFIBOOTMGR_SOURCES))
+efibootmgr : PKGS=efivar efiboot
+
+eficonman : $(call objects-of,$(EFICONMAN_SOURCES))
+eficonman : PKGS=efivar efiboot popt
+
+efibootdump : $(call objects-of,$(EFIBOOTDUMP_SOURCES))
+efibootdump : PKGS=efivar efiboot popt
+
+efibootnext : $(call objects-of,$(EFIBOOTNEXT_SOURCES))
+efibootnext : PKGS=efivar efiboot popt
+
+deps : $(ALL_SOURCES)
+	$(MAKE) -f $(TOPDIR)/Make.deps deps SOURCES="$(ALL_SOURCES)" SUBDIR_CFLAGS="$(SUBDIR_CFLAGS)"
+
+clean :
+	@rm -rfv *.o *.a *.so $(TARGETS)
+	@rm -rfv .*.d
+
+install :
+	$(INSTALL) -d -m 755 $(DESTDIR)/$(sbindir)/
+	$(INSTALL) -m 755 efibootmgr $(DESTDIR)/$(sbindir)/efibootmgr
+	$(INSTALL) -d -m 755 $(DESTDIR)/$(mandir)/man8/
+	$(INSTALL) -m 644 efibootmgr.8 $(DESTDIR)/$(mandir)/man8/efibootmgr.8
+	$(INSTALL) -m 644 efibootdump.8 $(DESTDIR)/$(mandir)/man8/efibootdump.8
+
+.PHONY : all deps clean install
diff --git a/src/lib/efi.c b/src/efi.c
similarity index 88%
rename from src/lib/efi.c
rename to src/efi.c
index c2b8152..17ecac3 100644
--- a/src/lib/efi.c
+++ b/src/efi.c
@@ -402,6 +402,67 @@ make_linux_load_option(uint8_t **data, size_t *data_size,
 	return needed;
 }
 
+static ssize_t
+read_stdin(uint8_t *data_out, ssize_t data_size_out)
+{
+	static uint8_t *data = NULL;
+	static ssize_t data_size = 0;
+	off_t pos = 0;
+	ssize_t allocated;
+
+	if (data_out && data_size_out) {
+		if (!data || data_size != data_size_out) {
+			errno = EINVAL;
+			return -1;
+		}
+		memcpy(data_out, data, data_size);
+		return data_size;
+	}
+	allocated = 4096;
+	data = malloc(allocated);
+	if (!data)
+		return -1;
+	memset(data, 0, allocated);
+
+	while (1) {
+		ssize_t ret;
+		if (allocated - pos == 0) {
+			allocated += 4096;
+			/*
+			 * there's really no way a variable is going to be
+			 * 64k and work, so bail before we suck up all of
+			 * memory.
+			 */
+			if (allocated > 4096 * 16) {
+				errno = ENOSPC;
+err:
+				free(data);
+				data = 0;
+				data_size = 0;
+				return -1;
+			}
+
+			uint8_t *data_new;
+			data_new = realloc(data, allocated);
+			if (!data_new)
+				goto err;
+			data = data_new;
+		}
+		ret = fread(data+pos, 1, allocated-pos, stdin);
+		if (ret == 0) {
+			if (ferror(stdin)) {
+				errno = EIO;
+				goto err;
+			}
+			if (feof(stdin))
+				break;
+		}
+		data_size += ret;
+		pos += ret;
+	}
+	return data_size;
+}
+
 ssize_t
 get_extra_args(uint8_t *data, ssize_t data_size)
 {
@@ -410,12 +471,14 @@ get_extra_args(uint8_t *data, ssize_t data_size)
 	off_t off = 0;
 
 	if (opts.extra_opts_file) {
-		needed = efi_loadopt_args_from_file(data, data_size,
+		if (!strcmp(opts.extra_opts_file, "-"))
+			needed = read_stdin(data, data_size);
+		else
+			needed = efi_loadopt_args_from_file(data, data_size,
 						     opts.extra_opts_file);
-		if (needed < 0) {
+		if (needed < 0)
 			fprintf(stderr, "efibootmgr: get_extra_args: %m\n");
-			return -1;
-		}
+		return needed;
 	}
 	for (i = opts.optind; i < opts.argc; i++) {
 		int space = (i < opts.argc - 1) ? 1 : 0;
@@ -424,7 +487,7 @@ get_extra_args(uint8_t *data, ssize_t data_size)
 			sz = efi_loadopt_args_as_ucs2(
 						(uint16_t *)(data+off),
 						data_size?data_size+off:0,
-						opts.argv[i]);
+						(uint8_t *)opts.argv[i]);
 			if (sz < 0)
 				return -1;
 			off += sz;
@@ -436,7 +499,7 @@ get_extra_args(uint8_t *data, ssize_t data_size)
 		} else {
 			sz = efi_loadopt_args_as_utf8(data+off,
 						data_size?data_size+off:0,
-						opts.argv[i]);
+						(uint8_t *)opts.argv[i]);
 			if (sz < 0)
 				return -1;
 			off += sz;
diff --git a/src/efibootdump.8 b/src/efibootdump.8
new file mode 100644
index 0000000..a864b05
--- /dev/null
+++ b/src/efibootdump.8
@@ -0,0 +1,32 @@
+.TH "EFIBOOTDUMP" "8" "24 February 2016" "" ""
+
+.SH NAME
+efibootdump \- dump a boot entries from a variable or a file
+.SH SYNOPSIS
+
+\fBefibootdump\fR [\fB-?\fR|\fB--help\fR] [\fB--usage\fR]
+.br
+	[\fB-f\fR \fI<file1>\fR [... \fB-f\fR \fI<fileN>\fR]]
+.br
+	[[\fB-g\fR \fI{guid}\fR] \fI<name0>\fR [... [\fI<nameN>\fR]]]
+.SH "DESCRIPTION"
+.PP
+\fBefibootdump\fR is a userspace application used to display individual UEFI boot options, from a file or a UEFI variable.  This allows e.g. saved files from efivarfs to be displayed, as well as variables on the running machine.
+
+.SH "OPTIONS"
+The following is a list of options accepted by efibootmgr:
+.TP
+\fB-g | --guid\fR \fI{guid}\fR
+Any variables specified by name have the specified GUID.
+.TP
+\fB-f | --file\fR \fI<file>\fR
+Read a single boot variable from the specified file.
+.TP
+\fI<nameN>\fR
+Display the specified variable on the local machine.  If no GUID is specified, EFI Global Variable is the default.
+.SH "BUGS"
+.PP
+Please direct any bugs, features, patches, etc. to the Red Hat installer team at https://github.com/rhinstaller/efibootmgr \&.
+.SH "SEE ALSO"
+.PP
+efibootmgr(8)
diff --git a/src/efibootdump.c b/src/efibootdump.c
new file mode 100644
index 0000000..3e448c2
--- /dev/null
+++ b/src/efibootdump.c
@@ -0,0 +1,274 @@
+/*
+ * efibootdump.c - dump a variable as if it's a Boot#### variable
+ *
+ * Copyright 2015 Red Hat, Inc.
+ *
+ * See "COPYING" for license terms.
+ *
+ * Author: Peter Jones <pjones@redhat.com>
+ */
+
+#include <ctype.h>
+#include <efiboot.h>
+#include <efivar.h>
+#include <err.h>
+#include <inttypes.h>
+#include <libintl.h>
+#include <locale.h>
+#include <popt.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <uchar.h>
+#include <unistd.h>
+
+#include "unparse_path.h"
+
+#define  _(String) gettext (String)
+#define Q_(String) dgettext (NULL, String)
+#define C_(Context,String) dgettext (Context,String)
+
+static void
+print_boot_entry(efi_load_option *loadopt, size_t data_size)
+{
+	char *text_path = NULL;
+	size_t text_path_len = 0;
+	uint8_t *optional_data = NULL;
+	size_t optional_data_len = 0;
+	uint16_t pathlen;
+	const unsigned char const *desc;
+	char *raw;
+	size_t raw_len;
+
+	ssize_t rc;
+	efidp dp = NULL;
+
+	printf("%c ", (efi_loadopt_attrs(loadopt) & LOAD_OPTION_ACTIVE)
+	              ? '*' : ' ');
+
+	desc = efi_loadopt_desc(loadopt, data_size);
+	if (!desc)
+		printf("<invalid description> ");
+	else if (desc[0])
+		printf("%s ", desc);
+
+	dp = efi_loadopt_path(loadopt, data_size);
+	pathlen = efi_loadopt_pathlen(loadopt, data_size);
+
+	rc = efidp_format_device_path(NULL, 0, dp, pathlen);
+	if (rc < 0) {
+		printf("<bad device path>");
+		return;
+	}
+	text_path_len = rc + 1;
+	text_path = alloca(text_path_len);
+	if (!text_path)
+		err(100, "Couldn't allocate memory");
+	rc = efidp_format_device_path(text_path, text_path_len,
+				      dp, pathlen);
+	if (rc < 0) {
+		printf("<bad device path>");
+		return;
+	}
+	if (text_path && text_path_len >= 1)
+		printf("%s", text_path);
+
+	rc = efi_loadopt_optional_data(loadopt, data_size,
+				       &optional_data, &optional_data_len);
+	if (rc < 0) {
+		printf("<bad optional_data>");
+		return;
+	}
+
+	rc = unparse_raw_text(NULL, 0, optional_data, optional_data_len);
+	if (rc < 0) {
+		printf("<bad optional data>");
+		return;
+	}
+
+	raw_len = rc + 1;
+	raw = alloca(raw_len);
+	if (!raw)
+		err(101, "Couldn't allocate memory");
+
+	rc = unparse_raw_text(raw, raw_len, optional_data, optional_data_len);
+	if (rc < 0) {
+		printf("<bad optional data>");
+	} else if (rc > 0) {
+		for (unsigned int i = 0; i < optional_data_len; i++)
+			putchar(isprint(optional_data[i])
+				? optional_data[i]
+				: '.');
+	}
+
+	printf("\n");
+}
+
+int
+main(int argc, char *argv[])
+{
+	const char **names = NULL;
+	const char **files = NULL;
+	char *guidstr = NULL;
+	efi_guid_t guid = efi_guid_global;
+
+	setlocale(LC_ALL, "");
+	bindtextdomain("efibootdump", LOCALEDIR);
+	textdomain("efibootdump");
+
+	struct poptOption options[] = {
+		{.argInfo = POPT_ARG_INTL_DOMAIN,
+		 .arg = "efibootdump" },
+		{.longName = "guid",
+		 .shortName = 'g',
+		 .argInfo = POPT_ARG_STRING |
+			    POPT_ARGFLAG_OPTIONAL |
+			    POPT_ARGFLAG_STRIP,
+		 .arg = &guidstr,
+		 .descrip = _("GUID namespace the variable is in"),
+		 .argDescrip = "{guid}"},
+		{.longName = "file",
+		 .shortName = 'f',
+		 .argInfo = POPT_ARG_ARGV |
+			    POPT_ARGFLAG_OPTIONAL |
+			    POPT_ARGFLAG_STRIP,
+		 .arg = &files,
+		 .descrip = _("File to read variable data from"),
+		 .argDescrip = "<file>"},
+		POPT_AUTOALIAS
+		POPT_AUTOHELP
+		POPT_TABLEEND
+	};
+	efi_load_option *loadopt;
+	uint8_t *data = NULL;
+	size_t data_size = 0;
+
+	poptContext optcon;
+	optcon = poptGetContext("efibootdump", argc, (const char **)argv,
+				options, 0);
+
+	poptSetOtherOptionHelp(optcon, "[OPTIONS...] [name0 [... [nameN]]]");
+
+	int rc;
+	rc = poptReadDefaultConfig(optcon, 0);
+	if (rc < 0 && !(rc == POPT_ERROR_ERRNO && errno == ENOENT))
+		errx(1, _("poptReadDefaultConfig failed: %s: %s"),
+			poptBadOption(optcon, 0), poptStrerror(rc));
+
+	while ((rc = poptGetNextOpt(optcon)) > 0)
+		;
+
+	if (rc < -1)
+		errx(2, "Invalid argument: \"%s\": %s",
+		     poptBadOption(optcon, 0), poptStrerror(rc));
+
+	argc = poptStrippedArgv(optcon, argc, argv);
+	names = poptGetArgs(optcon);
+	if (!names && !files) {
+		poptPrintUsage(optcon, stderr, 0);
+		exit(4);
+	}
+
+	if (names && (!names[0] || names[0][0] == '\0')) {
+		poptPrintUsage(optcon, stderr, 0);
+		exit(4);
+	}
+
+	if (files && (!files[0] || files[0][0] == '\0')) {
+		poptPrintUsage(optcon, stderr, 0);
+		exit(4);
+	}
+
+	if (names) {
+		if (guidstr) {
+			rc = efi_id_guid_to_guid(guidstr, &guid);
+			if (rc < 0)
+				err(5, "Could not parse guid \"%s\"", guidstr);
+		}
+		free(guidstr);
+		guidstr = NULL;
+		rc = efi_guid_to_str(&guid, &guidstr);
+		if (rc < 0)
+			err(6, "Guid lookup failed");
+	}
+
+	for (unsigned int i = 0;
+	     files != NULL && files[i] != NULL && files[i][0] != '\0';
+	     i++) {
+		struct stat statbuf;
+		FILE *f;
+		size_t n;
+		const char *filename = files[i];
+
+		memset(&statbuf, 0, sizeof(statbuf));
+		rc = stat(filename, &statbuf);
+		if (rc < 0)
+			err(7, "Could not stat \"%s\"", filename);
+
+		data_size = statbuf.st_size;
+		if (data_size == 0)
+			errx(11, "File \"%s\" is empty", filename);
+
+		data = alloca(data_size);
+		if (data == NULL)
+			err(8, "Could not allocate memory");
+
+		f = fopen(filename, "r");
+		if (!f)
+			err(9, "Could not open \"%s\"", filename);
+
+		n = fread(data, 1, data_size, f);
+		if (n < data_size)
+			err(10, "Could not read \"%s\"", filename);
+
+		printf("%s: ", filename);
+		loadopt = (efi_load_option *)(data + 4);
+		if (data_size <= 8)
+			errx(11, "Data is not a valid load option");
+		if (efi_loadopt_is_valid(loadopt, data_size - 4)) {
+			print_boot_entry(loadopt, data_size - 4);
+		} else {
+			loadopt = (efi_load_option *)data;
+			if (!efi_loadopt_is_valid(loadopt, data_size))
+				errx(11, "Data is not a valid load option");
+			print_boot_entry(loadopt, data_size);
+		}
+
+		fclose(f);
+	}
+
+	for (unsigned int i = 0;
+	     names && names[i] != NULL && names[i][0] != '\0';
+	     i++) {
+		uint32_t attrs = 0;
+
+		rc = efi_get_variable(guid, names[i], &data, &data_size,
+				      &attrs);
+		if (rc < 0) {
+			warn("couldn't read variable %s-%s", names[i], guidstr);
+			continue;
+		}
+
+		loadopt = (efi_load_option *)data;
+		if (!efi_loadopt_is_valid(loadopt, data_size)) {
+			if (data && data_size > 0) {
+				free(data);
+				continue;
+			}
+		}
+
+		printf("%s", names[i]);
+		if (efi_guid_cmp(&efi_guid_global, &guid))
+			printf("-%s", guidstr);
+		printf(": ");
+		print_boot_entry(loadopt, data_size);
+		if (data && data_size > 0)
+			free(data);
+	}
+
+	if (guidstr)
+		free(guidstr);
+
+	poptFreeContext(optcon);
+	return 0;
+}
diff --git a/src/man/man8/efibootmgr.8 b/src/efibootmgr.8
similarity index 91%
rename from src/man/man8/efibootmgr.8
rename to src/efibootmgr.8
index 998dff0..b335335 100644
--- a/src/man/man8/efibootmgr.8
+++ b/src/efibootmgr.8
@@ -9,7 +9,7 @@
 efibootmgr \- manipulate the EFI Boot Manager
 .SH SYNOPSIS
 
-\fBefibootmgr\fR [ \fB-a\fR ] [ \fB-A\fR ] [ \fB-b \fIXXXX\fB\fR ] [ \fB-B \fIXXXX\fB\fR ] [ \fB-c\fR ] [ \fB-d \fIDISK\fB\fR ] [ \fB-D\fR ] [ \fB-e \fI1|3|-1\fB\fR ] [ \fB-E \fINUM\fB\fR ] [ \fB-g\fR ] [ \fB-H \fIXXXX\fB\fR ] [ \fB-i \fINAME\fB\fR ] [ \fB-l \fINAME\fB\fR ] [ \fB-L \fILABEL\fB\fR ] [ \fB-n \fIXXXX\fB\fR ] [ \fB-N\fR ] [ \fB-o \fIXXXX\fB,\fIYYYY\fB,\fIZZZZ\fB\fR\fI ...\fR ] [ \fB-O\fR ] [ \fB-p \fIPART\fB\fR ] [ \fB-q\fR ] [ \fB-t \fIseconds\fB\fR ] [ \fB-T\fR ] [ \fB-u\fR ] [ \fB-U \fIXXXX\fB\fR ] [ \fB-v\fR ] [ \fB-V\fR ] [ \fB-w\fR ] [ \fB-@ \fIfile\fB\fR ]
+\fBefibootmgr\fR [ \fB-a\fR ] [ \fB-A\fR ] [ \fB-b \fIXXXX\fB\fR ] [ \fB-B \fIXXXX\fB\fR ] [ \fB-c\fR ] [ \fB-d \fIDISK\fB\fR ] [ \fB-D\fR ] [ \fB-e \fI1|3|-1\fB\fR ] [ \fB-E \fINUM\fB\fR ] [ \fB-g\fR ] [ \fB-H \fIXXXX\fB\fR ] [ \fB-i \fINAME\fB\fR ] [ \fB-l \fINAME\fB\fR ] [ \fB-L \fILABEL\fB\fR ] [ \fB-m \fIt|f\fB\fR ] [ \fB-M \fIX\fB\fR ] [ \fB-n \fIXXXX\fB\fR ] [ \fB-N\fR ] [ \fB-o \fIXXXX\fB,\fIYYYY\fB,\fIZZZZ\fB\fR\fI ...\fR ] [ \fB-O\fR ] [ \fB-p \fIPART\fB\fR ] [ \fB-q\fR ] [ \fB-t \fIseconds\fB\fR ] [ \fB-T\fR ] [ \fB-u\fR ] [ \fB-U \fIXXXX\fB\fR ] [ \fB-v\fR ] [ \fB-V\fR ] [ \fB-w\fR ] [ \fB-@ \fIfile\fB\fR ]
 
 .SH "DESCRIPTION"
 .PP
@@ -72,6 +72,12 @@ Specify a loader (defaults to \fI\\\\elilo.efi\fR)
 \fB-L | --label \fILABEL\fB\fR
 Boot manager display label (defaults to "Linux")
 .TP
+\fB-m | --mirror-below-4G \fIt|f\fB\fR
+Set t if you want to mirror memory below 4GB
+.TP
+\fB-M | --mirror-above-4G \fIX\fB\fR
+X percentage memory to mirror above 4GB. Floating-point value with up to 2 decimal places is accepted.
+.TP
 \fB-n | --bootnext \fIXXXX\fB\fR
 Set BootNext to XXXX (hex)
 .TP
diff --git a/src/efibootmgr/efibootmgr.c b/src/efibootmgr.c
similarity index 82%
rename from src/efibootmgr/efibootmgr.c
rename to src/efibootmgr.c
index a5b5bf9..199eb28 100644
--- a/src/efibootmgr/efibootmgr.c
+++ b/src/efibootmgr.c
@@ -30,8 +30,6 @@
 
 */
 
-#define _GNU_SOURCE
-
 #include <ctype.h>
 #include <err.h>
 #include <errno.h>
@@ -123,6 +121,7 @@ read_vars(char **namelist,
 			entry->attributes = entry->attributes & ~(1 << 31);
 
 			entry->name = namelist[i];
+			entry->guid = EFI_GLOBAL_GUID;
 			list_add_tail(&entry->list, head);
 		}
 	}
@@ -219,13 +218,12 @@ warn_duplicate_name(list_t *boot_list)
 
 	list_for_each(pos, boot_list) {
 		boot = list_entry(pos, var_entry_t, list);
-		load_option = (efi_load_option *)
-			boot->data;
-		desc = efi_loadopt_desc(load_option);
+		load_option = (efi_load_option *)boot->data;
+		desc = efi_loadopt_desc(load_option, boot->data_size);
 		if (!strcmp((char *)opts.label, (char *)desc)) {
-			fprintf(stderr, "** Warning ** : %.8s has same label %s\n",
-			       boot->name,
-			       opts.label);
+			fprintf(stderr,
+				"** Warning ** : %.8s has same label %s\n",
+				boot->name, opts.label);
 		}
 	}
 }
@@ -305,7 +303,7 @@ make_boot_var(list_t *boot_list)
 			    EFI_VARIABLE_BOOTSERVICE_ACCESS |
 			    EFI_VARIABLE_RUNTIME_ACCESS;
 	rc = efi_set_variable(boot->guid, boot->name, boot->data,
-				boot->data_size, boot->attributes);
+				boot->data_size, boot->attributes, 0644);
 	if (rc < 0)
 		goto err;
 	list_add_tail(&boot->list, boot_list);
@@ -363,7 +361,8 @@ set_boot_u16(const char *name, uint16_t num)
 	return efi_set_variable(EFI_GLOBAL_GUID, name, (uint8_t *)&num,
 				sizeof (num), EFI_VARIABLE_NON_VOLATILE |
 					      EFI_VARIABLE_BOOTSERVICE_ACCESS |
-					      EFI_VARIABLE_RUNTIME_ACCESS);
+					      EFI_VARIABLE_RUNTIME_ACCESS,
+					      0644);
 }
 
 static int
@@ -399,7 +398,7 @@ add_to_boot_order(uint16_t num)
 	boot_order->data_size = new_data_size;
 
 	rc = efi_set_variable(EFI_GLOBAL_GUID, "BootOrder", boot_order->data,
-			boot_order->data_size, boot_order->attributes);
+			boot_order->data_size, boot_order->attributes, 0644);
 	free(boot_order->data);
 	free(boot_order);
 	return rc;
@@ -453,7 +452,8 @@ remove_dupes_from_boot_order(void)
 	boot_order->data_size = new_data_size;
 	efi_del_variable(EFI_GLOBAL_GUID, "BootOrder");
 	rc = efi_set_variable(EFI_GLOBAL_GUID, "BootOrder", boot_order->data,
-				boot_order->data_size, boot_order->attributes);
+				boot_order->data_size, boot_order->attributes,
+				0644);
 	free(boot_order->data);
 	free(boot_order);
 	return rc;
@@ -494,15 +494,16 @@ remove_from_boot_order(uint16_t num)
 	if (new_i == old_i)
 		goto all_done;
 
-	/* BootOrder variable needs to be updated */
-	efi_del_variable(EFI_GLOBAL_GUID, "BootOrder");
-
-	if (new_i == 0)
+	/* BootOrder should have nothing when new_i == 0 */
+	if (new_i == 0) {
+		efi_del_variable(EFI_GLOBAL_GUID, "BootOrder");
 		goto all_done;
+	}
 
 	boot_order->data_size = sizeof(data[0]) * new_i;
 	rc = efi_set_variable(EFI_GLOBAL_GUID, "BootOrder", boot_order->data,
-				boot_order->data_size, boot_order->attributes);
+				boot_order->data_size, boot_order->attributes,
+				0644);
 all_done:
 	free(boot_order->data);
 	free(boot_order);
@@ -535,6 +536,15 @@ read_boot_u16(const char *name)
 }
 
 static int
+hex_could_be_lower_case(uint16_t num)
+{
+	return ((((num & 0x000f) >>  0) > 9) ||
+		(((num & 0x00f0) >>  4) > 9) ||
+		(((num & 0x0f00) >>  8) > 9) ||
+		(((num & 0xf000) >> 12) > 9));
+}
+
+static int
 delete_boot_var(uint16_t num)
 {
 	int rc;
@@ -544,22 +554,20 @@ delete_boot_var(uint16_t num)
 
 	snprintf(name, sizeof(name), "Boot%04X", num);
 	rc = efi_del_variable(EFI_GLOBAL_GUID, name);
+	if (rc < 0)
+		warn("Could not delete Boot%04X", num);
 
 	/* For backwards compatibility, try to delete abcdef entries as well */
-	if (rc < 0) {
-		if (errno == ENOENT) {
-			snprintf(name, sizeof(name), "Boot%04x", num);
-			rc = efi_del_variable(EFI_GLOBAL_GUID, name);
-		} else if (errno == EPERM) {
-			warn("Could not delete Boot%04X", num);
-			return rc;
-		}
+	if (rc < 0 && errno == ENOENT && hex_could_be_lower_case(num)) {
+		snprintf(name, sizeof(name), "Boot%04x", num);
+		rc = efi_del_variable(EFI_GLOBAL_GUID, name);
+		if (rc < 0 && errno != ENOENT)
+			warn("Could not delete Boot%04x", num);
 	}
 
-	if (rc < 0) {
-		warnx("Boot entry %04X not found", num);
+	if (rc < 0)
 		return rc;
-	}
+
 	list_for_each_safe(pos, n, &boot_entry_list) {
 		boot = list_entry(pos, var_entry_t, list);
 		if (boot->num == num) {
@@ -802,7 +810,8 @@ set_boot_order(int keep_old_entries)
 	rc = efi_set_variable(EFI_GLOBAL_GUID, "BootOrder", data, data_size,
 			      EFI_VARIABLE_NON_VOLATILE |
 			      EFI_VARIABLE_BOOTSERVICE_ACCESS |
-			      EFI_VARIABLE_RUNTIME_ACCESS);
+			      EFI_VARIABLE_RUNTIME_ACCESS,
+			      0644);
 	free(data);
 	return rc;
 }
@@ -821,8 +830,7 @@ show_boot_vars()
 	list_for_each(pos, &boot_entry_list) {
 		boot = list_entry(pos, var_entry_t, list);
 		load_option = (efi_load_option *)boot->data;
-		description = efi_loadopt_desc(load_option);
-		dp = efi_loadopt_path(load_option);
+		description = efi_loadopt_desc(load_option, boot->data_size);
 		if (boot->name)
 			printf("%.8s", boot->name);
 		else
@@ -835,9 +843,12 @@ show_boot_vars()
 		if (opts.verbose) {
 			char *text_path = NULL;
 			size_t text_path_len = 0;
-			uint16_t pathlen = efi_loadopt_pathlen(load_option);
+			uint16_t pathlen;
 			ssize_t rc;
 
+			pathlen = efi_loadopt_pathlen(load_option,
+						      boot->data_size);
+			dp = efi_loadopt_path(load_option, boot->data_size);
 			rc = efidp_format_device_path(text_path, text_path_len,
 						      dp, pathlen);
 			if (rc < 0)
@@ -935,7 +946,8 @@ set_active_state()
 							boot->name,
 							boot->data,
 							boot->data_size,
-							boot->attributes);
+							boot->attributes,
+							0644);
 				}
 			}
 			else if (opts.active == 0) {
@@ -949,7 +961,8 @@ set_active_state()
 							boot->name,
 							boot->data,
 							boot->data_size,
-							boot->attributes);
+							boot->attributes,
+							0644);
 				}
 			}
 		}
@@ -960,6 +973,115 @@ set_active_state()
 	return -1;
 }
 
+static int
+get_mirror(int which, int *below4g, int *above4g, int *mirrorstatus)
+{
+	int rc;
+	uint8_t *data;
+	ADDRESS_RANGE_MIRROR_VARIABLE_DATA *abm;
+	size_t data_size;
+	uint32_t attributes;
+	char *name;
+
+	if (which)
+		name = ADDRESS_RANGE_MIRROR_VARIABLE_REQUEST;
+	else
+		name = ADDRESS_RANGE_MIRROR_VARIABLE_CURRENT;
+
+	rc = efi_get_variable(ADDRESS_RANGE_MIRROR_VARIABLE_GUID, name,
+				&data, &data_size, &attributes);
+	if (rc == 0) {
+		abm = (ADDRESS_RANGE_MIRROR_VARIABLE_DATA *)data;
+		if (!which && abm->mirror_version != MIRROR_VERSION) {
+			fprintf(stderr, "** Warning ** : unrecognised version for memory mirror i/f\n");
+			return 2;
+		}
+		*below4g = abm->mirror_memory_below_4gb;
+		*above4g = abm->mirror_amount_above_4gb;
+		*mirrorstatus = abm->mirror_status;
+	}
+	return rc;
+}
+
+static int
+set_mirror(int below4g, int above4g)
+{
+	int s, status, rc;
+	uint8_t *data;
+	ADDRESS_RANGE_MIRROR_VARIABLE_DATA abm;
+	size_t data_size;
+	uint32_t attributes;
+	int oldbelow4g, oldabove4g;
+
+	if ((s = get_mirror(0, &oldbelow4g, &oldabove4g, &status)) == 0) {
+		if (oldbelow4g == below4g && oldabove4g == above4g)
+			return 0;
+	} else {
+		fprintf(stderr, "** Warning ** : platform does not support memory mirror\n");
+		return s;
+	}
+
+	data = (uint8_t *)&abm;
+	data_size = sizeof (abm);
+	attributes = EFI_VARIABLE_NON_VOLATILE
+		| EFI_VARIABLE_BOOTSERVICE_ACCESS
+		| EFI_VARIABLE_RUNTIME_ACCESS;
+
+	abm.mirror_version = MIRROR_VERSION;
+	abm.mirror_amount_above_4gb = opts.set_mirror_hi ? above4g : oldabove4g;
+	abm.mirror_memory_below_4gb = opts.set_mirror_lo ? below4g : oldbelow4g;
+	abm.mirror_status = 0;
+	data = (uint8_t *)&abm;
+	rc = efi_set_variable(ADDRESS_RANGE_MIRROR_VARIABLE_GUID,
+			      ADDRESS_RANGE_MIRROR_VARIABLE_REQUEST, data,
+			      data_size, attributes, 0644);
+	return rc;
+}
+
+static void
+show_mirror(void)
+{
+	int status;
+	int below4g, above4g;
+	int rbelow4g, rabove4g;
+
+	if (get_mirror(0, &below4g, &above4g, &status) == 0) {
+		if (status == 0) {
+			printf("MirroredPercentageAbove4G: %d.%.2d\n", above4g/100, above4g%100);
+			printf("MirrorMemoryBelow4GB: %s\n", below4g ? "true" : "false");
+		} else {
+			printf("MirrorStatus: ");
+			switch (status) {
+			case 1:
+				printf("Platform does not support address range mirror\n");
+				break;
+			case 2:
+				printf("Invalid version number\n");
+				break;
+			case 3:
+				printf("MirroredMemoryAbove4GB > 50.00%%\n");
+				break;
+			case 4:
+				printf("DIMM configuration does not allow mirror\n");
+				break;
+			case 5:
+				printf("OEM specific method\n");
+				break;
+			default:
+				printf("%u\n", status);
+				break;
+			}
+			printf("DesiredMirroredPercentageAbove4G: %d.%.2d\n", above4g/100, above4g%100);
+			printf("DesiredMirrorMemoryBelow4GB: %s\n", below4g ? "true" : "false");
+		}
+	}
+	if ((get_mirror(1, &rbelow4g, &rabove4g, &status) == 0) &&
+		(above4g != rabove4g || below4g != rbelow4g)) {
+		printf("RequestMirroredPercentageAbove4G: %d.%.2d\n", rabove4g/100, rabove4g%100);
+		printf("RequestMirrorMemoryBelow4GB: %s\n", rbelow4g ? "true" : "false");
+	}
+}
+
 static void
 usage()
 {
@@ -987,6 +1109,8 @@ usage()
 #endif
 	printf("\t-l | --loader name     (defaults to \\EFI\\redhat\\grub.efi)\n");
 	printf("\t-L | --label label     Boot manager display label (defaults to \"Linux\")\n");
+	printf("\t-m | --mirror-below-4G t|f mirror memory below 4GB\n");
+	printf("\t-M | --mirror-above-4G X percentage memory to mirror above 4GB\n");
 	printf("\t-n | --bootnext XXXX   set BootNext to XXXX (hex)\n");
 	printf("\t-N | --delete-bootnext delete BootNext\n");
 	printf("\t-o | --bootorder XXXX,YYYY,ZZZZ,...     explicitly set BootOrder (hex)\n");
@@ -1023,6 +1147,7 @@ parse_opts(int argc, char **argv)
 {
 	int c, rc;
 	unsigned int num;
+	float fnum;
 	int option_index = 0;
 
 	while (1)
@@ -1035,7 +1160,7 @@ parse_opts(int argc, char **argv)
 			{"bootnum",          required_argument, 0, 'b'},
 			{"delete-bootnum",         no_argument, 0, 'B'},
 			{"create",                 no_argument, 0, 'c'},
-			{"create-only",		   no_argument, 0, 'C'},
+			{"create-only",            no_argument, 0, 'C'},
 			{"remove-dups",            no_argument, 0, 'D'},
 			{"disk",             required_argument, 0, 'd'},
 			{"iface",            required_argument, 0, 'i'},
@@ -1045,6 +1170,8 @@ parse_opts(int argc, char **argv)
 			{"keep",                   no_argument, 0, 'k'},
 			{"loader",           required_argument, 0, 'l'},
 			{"label",            required_argument, 0, 'L'},
+			{"mirror-below-4G",  required_argument, 0, 'm'},
+			{"mirror-above-4G",  required_argument, 0, 'M'},
 			{"bootnext",         required_argument, 0, 'n'},
 			{"delete-bootnext",        no_argument, 0, 'N'},
 			{"bootorder",        required_argument, 0, 'o'},
@@ -1064,7 +1191,7 @@ parse_opts(int argc, char **argv)
 		};
 
 		c = getopt_long (argc, argv,
-				 "AaBb:cCDd:e:E:gH:i:l:L:n:No:Op:qt:TuU:v::Vw"
+				 "AaBb:cCDd:e:E:gH:i:l:L:M:m:n:No:Op:qt:TuU:v::Vw"
 				 "@:h",
 				 long_options, &option_index);
 		if (c == -1)
@@ -1093,13 +1220,11 @@ parse_opts(int argc, char **argv)
 				print_error_arrow("Invalid bootnum value",
 					optarg,
 					(intptr_t)endptr - (intptr_t)optarg);
-				exit(1);
-			}
-			if (result > 0xffff) {
-				fprintf(stderr, "Invalid bootnum value: %lX\n",
-					result);
-				exit(1);
+				exit(28);
 			}
+			if (result > 0xffff)
+				errx(29, "Invalid bootnum value: %lX\n",
+				     result);
 
 			opts.bootnum = result;
 			break;
@@ -1119,26 +1244,19 @@ parse_opts(int argc, char **argv)
 			break;
 		case 'e':
 			rc = sscanf(optarg, "%u", &num);
-			if (rc == 1) opts.edd_version = num;
-			else {
-				fprintf (stderr,"invalid numeric value %s\n",
-					 optarg);
-				exit(1);
-			}
-			if (num != 0 && num != 1 && num != 3) {
-				fprintf (stderr, "invalid EDD version %d\n",
-					 num);
-				exit(1);
-			}
+			if (rc == 1)
+				opts.edd_version = num;
+			else
+				errx(30, "invalid numeric value %s\n", optarg);
+			if (num != 0 && num != 1 && num != 3)
+				errx(31, "invalid EDD version %d\n", num);
 			break;
 		case 'E':
 			rc = sscanf(optarg, "%x", &num);
-			if (rc == 1) opts.edd10_devicenum = num;
-			else {
-				fprintf (stderr,"invalid hex value %s\n",
-					 optarg);
-				exit(1);
-			}
+			if (rc == 1)
+				opts.edd10_devicenum = num;
+			else
+				errx(32, "invalid hex value %s\n", optarg);
 			break;
 		case 'g':
 			opts.forcegpt = 1;
@@ -1163,6 +1281,28 @@ parse_opts(int argc, char **argv)
 		case 'L':
 			opts.label = (unsigned char *)optarg;
 			break;
+		case 'm':
+			opts.set_mirror_lo = 1;
+			switch (optarg[0]) {
+			case '1': case 'y': case 't':
+				opts.below4g = 1;
+				break;
+			case '0': case 'n': case 'f':
+				opts.below4g = 0;
+				break;
+			default:
+				errx(33, "invalid boolean value %s\n", optarg);
+			}
+			break;
+		case 'M':
+			opts.set_mirror_hi = 1;
+			rc = sscanf(optarg, "%f", &fnum);
+			if (rc == 1 && fnum <= 50 && fnum >= 0)
+				/* percent to basis points */
+				opts.above4g = fnum * 100;
+			else
+				errx(34, "invalid numeric value %s\n", optarg);
+			break;
 		case 'N':
 			opts.delete_bootnext = 1;
 			break;
@@ -1175,13 +1315,11 @@ parse_opts(int argc, char **argv)
 				print_error_arrow("Invalid BootNext value",
 					optarg,
 					(intptr_t)endptr - (intptr_t)optarg);
-				exit(1);
-			}
-			if (result > 0xffff) {
-				fprintf(stderr, "Invalid BootNext value: %lX\n",
-					result);
-				exit(1);
+				exit(35);
 			}
+			if (result > 0xffff)
+				errx(36, "Invalid BootNext value: %lX\n",
+				     result);
 			opts.bootnext = result;
 			break;
 		}
@@ -1193,11 +1331,10 @@ parse_opts(int argc, char **argv)
 			break;
 		case 'p':
 			rc = sscanf(optarg, "%u", &num);
-			if (rc == 1) opts.part = num;
-			else {
-				fprintf (stderr,"invalid numeric value %s\n",optarg);
-				exit(1);
-			}
+			if (rc == 1)
+				opts.part = num;
+			else
+				errx(37, "invalid numeric value %s\n", optarg);
 			break;
 		case 'q':
 			opts.quiet = 1;
@@ -1207,10 +1344,8 @@ parse_opts(int argc, char **argv)
 			if (rc == 1) {
 				opts.timeout = num;
 				opts.set_timeout = 1;
-			}
-			else {
-				fprintf (stderr,"invalid numeric value %s\n",optarg);
-				exit(1);
+			} else {
+				errx(38, "invalid numeric value %s\n", optarg);
 			}
 			break;
 		case 'T':
@@ -1222,14 +1357,16 @@ parse_opts(int argc, char **argv)
 		case 'v':
 			opts.verbose = 1;
 			if (optarg) {
-				if (!strcmp(optarg, "v"))  opts.verbose = 2;
-				if (!strcmp(optarg, "vv")) opts.verbose = 3;
+				if (!strcmp(optarg, "v"))
+					opts.verbose = 2;
+				if (!strcmp(optarg, "vv"))
+					opts.verbose = 3;
 				rc = sscanf(optarg, "%u", &num);
-				if (rc == 1)  opts.verbose = num;
-				else {
-					fprintf (stderr,"invalid numeric value %s\n",optarg);
-					exit(1);
-				}
+				if (rc == 1)
+					opts.verbose = num;
+				else
+					errx(39, "invalid numeric value %s\n",
+					     optarg);
 			}
 			break;
 		case 'V':
@@ -1360,6 +1497,10 @@ main(int argc, char **argv)
 			err(14, "Could not set Timeout");
 	}
 
+	if (opts.set_mirror_lo || opts.set_mirror_hi) {
+		ret=set_mirror(opts.below4g, opts.above4g);
+	}
+
 	if (!opts.quiet && ret == 0) {
 		num = read_boot_u16("BootNext");
 		if (num >= 0) {
@@ -1375,6 +1516,7 @@ main(int argc, char **argv)
 		}
 		show_boot_order();
 		show_boot_vars();
+		show_mirror();
 	}
 	free_vars(&boot_entry_list);
 	free_array(boot_names);
diff --git a/src/efibootmgr/.gitignore b/src/efibootmgr/.gitignore
deleted file mode 100644
index efc8f8a..0000000
--- a/src/efibootmgr/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-efibootmgr
diff --git a/src/efibootmgr/Makefile b/src/efibootmgr/Makefile
deleted file mode 100644
index 6615d46..0000000
--- a/src/efibootmgr/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-%:
-	+make -C ../ $*
diff --git a/src/efibootmgr/module.mk b/src/efibootmgr/module.mk
deleted file mode 100644
index 8b03b92..0000000
--- a/src/efibootmgr/module.mk
+++ /dev/null
@@ -1,23 +0,0 @@
-efibootmgr_SRCDIR := src/efibootmgr
-efibootmgr_OBJECTS := efibootmgr.o
-efibootmgr_TARGETS := efibootmgr
-efibootmgr_FULLTARGET :=  \
-	$(patsubst %, $(efibootmgr_SRCDIR)/%, $(efibootmgr_TARGETS))
-efibootmgr_FULLOBJECT :=  \
-	$(patsubst %, $(efibootmgr_SRCDIR)/%, $(efibootmgr_OBJECT))
-
-efibootmgr_LIBS    := efi.o unparse_path.o
-efibootmgr_LIBDIR  := src/lib
-efibootmgr_FULLLIB := \
-	$(patsubst %,$(efibootmgr_LIBDIR)/%,$(efibootmgr_LIBS))
-LIBS = $(shell pkg-config --libs efivar efiboot)
-
-ALLDEPS += $(efibootmgr_FULLTARGET)
-CLEANLIST += $(efibootmgr_FULLTARGET)
-CLEANLIST += $(efibootmgr_FULLOBJECT)
-bindir_TARGETS += $(efibootmgr_FULLTARGET)
-
-$(efibootmgr_FULLTARGET): \
-	$(efibootmgr_FULLOBJECT) \
-	$(efibootmgr_FULLLIB)
-	$(CC) $(CFLAGS) $(LDFLAGS) $(efibootmgr_SRCDIR)/efibootmgr.c $^ $(LIBS) -o $@
diff --git a/src/efibootnext.c b/src/efibootnext.c
new file mode 100644
index 0000000..8886f69
--- /dev/null
+++ b/src/efibootnext.c
@@ -0,0 +1,211 @@
+/*
+ * efibootnext - Attempt to set a BootNext variable from existing boot
+ * options.
+ *
+ * Copyright 2015 Red Hat, Inc.
+ * Author: Peter Jones <pjones@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this library; if not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include <alloca.h>
+#include <err.h>
+#include <errno.h>
+#include <string.h>
+#include <popt.h>
+
+typedef enum {
+ notnot, // just a regular match sense
+ ignore, // ignore this match - only consider its children
+ not,    // ! <match>
+ and,    // <match> -a <match>
+ or,     // <match> -o <match>
+} match_sense;
+
+struct matcher {
+	int sense;
+	struct matcher *matchers;
+
+	char *bootnum;
+	char *disk;
+	char *edd;
+	char *edd_devnum;
+	char *loader;
+	char *label;
+	int gpt;
+	int in_boot_order;
+};
+
+int
+main(int argc, char *argv[])
+{
+	int err_if_not_found = 1;
+	int err_if_set_fails = 1;
+
+	int which = 0;
+	char *sorter = NULL;
+
+	struct matcher *matchers;
+	struct matcher *matcher;
+
+	poptContext optCon;
+
+	matcher = matchers = calloc(1, sizeof(struct matcher));
+	struct poptOption matchopts[] = {
+		/* options to specify match criteria */
+		{"bootnum", 'n', POPT_ARG_STRING, matcher->bootnum, NULL,
+			"boot entry number (hex)", "<####>" },
+		{"disk", 'd', POPT_ARG_STRING, matcher->disk, NULL,
+			"disk containing loader", "<disk>" },
+		/* keep edd and device together despite alphabetism */
+		{"edd", 'e', POPT_ARG_STRING, matcher->edd, NULL, 
+			"EDD version", "[1|3|[any]]" },
+		{"device", 'E', POPT_ARG_STRING, matcher->edd_devnum, NULL,
+			"EDD 1.0 device number (hex)", "[##|[80]]", },
+		/* keep gpt and mbr together despite alphabetism */
+		{"gpt", 'g', POPT_ARG_VAL, &matcher->gpt, 1,
+			"only match GPT partitioned disks", },
+		{"mbr", 'm', POPT_ARG_VAL, &matcher->gpt, 2,
+			"only match MBR partitioned disks", },
+		{"loader", 'l', POPT_ARG_STRING, matcher->loader, NULL,
+			"loader path", "<path>", },
+		{"label", 'L', POPT_ARG_STRING, matcher->label, NULL,
+			"boot entry label", "<label>", },
+		/* keep i-b-o and n-i-b-o together. */
+		{"in-boot-order", 'b', POPT_ARG_VAL,
+			&matcher->in_boot_order, 1,
+			"only match entries in the boot order", },
+		{"not-in-boot-order", 'B', POPT_ARG_VAL,
+			&matcher->in_boot_order, 2,
+			"only match entires not in the boot order", },
+
+		/* this is stuff about our match groups, not about the match
+		 * itself */
+#if 0
+		{"not", '!', ... },
+		{"start", '(', ...},
+		{"end", ')', ... },
+		{"and", 'a', ... },
+		{"or", 'o', ... },
+#endif
+		POPT_TABLEEND
+	};
+
+	struct poptOption options[] = {
+		{NULL, '\0', POPT_ARG_INTL_DOMAIN, "efibootnext" },
+		/* options not about our match criteria */
+		{"missing-ok", 'm', POPT_ARG_VAL, &err_if_not_found, 0,
+			"return success if there's no variable matching "
+			"the criteria", },
+		{"ignore-efi-errors", 'i', POPT_ARG_VAL, &err_if_set_fails, 0,
+			"return success if setting UEFI variables fails", },
+
+		/* options about determining /which/ match to use */
+		{"use-first", 'f', POPT_ARG_VAL, &which, 0,
+			"use the first matching entry", },
+		{"use-last", 'F', POPT_ARG_VAL, &which, 1,
+			"use the last matching entry", },
+		{"sorter", 's', POPT_ARG_STRING, &sorter, NULL,
+			"run <sorter_path> to sort matches", "<sorter_path>", },
+
+		/* options to specify match criteria */
+		/* these are also in matchopts, but with different vals */
+		{"bootnum", 'n', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'n', NULL, NULL },
+		{"disk", 'd', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'd', NULL, NULL },
+		/* keep edd and device together despite alphabetism */
+		{"edd", 'e', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'e', NULL, NULL },
+		{"device", 'E', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'E', NULL, NULL },
+		/* keep gpt and mbr together despite alphabetism */
+		{"gpt", 'g', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'g', NULL, NULL },
+		{"mbr", 'm', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'm', NULL, NULL },
+		{"loader", 'l', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'l', NULL, NULL },
+		{"label", 'L', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'L', NULL, NULL },
+		/* keep i-b-o and n-i-b-o together. */
+		{"in-boot-order", 'b', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN,
+			NULL, 'b', NULL, NULL },
+		{"not-in-boot-order", 'B',
+			POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL,
+			'B', NULL, NULL },
+		/* and the things that can start the first match group */
+		{"not", '!', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL, '!',
+			NULL, NULL },
+		{"start", '(', POPT_ARG_NONE|POPT_ARGFLAG_DOC_HIDDEN, NULL, '(',
+			NULL, NULL },
+		POPT_AUTOALIAS
+		POPT_AUTOHELP
+		POPT_TABLEEND
+	};
+	int rc;
+
+	optCon = poptGetContext("efibootnext", argc, (const char **)argv,
+				options, 0);
+	poptSetOtherOptionHelp(optCon, "[OPTIONS]* <match criteria>");
+
+	if (!matcher)
+		err(3, "Could not allocate memory");
+	memset(matchers, 0, sizeof (*matchers));
+
+	rc = poptReadDefaultConfig(optCon, 0);
+	if (rc < 0 && !(rc == POPT_ERROR_ERRNO && errno == ENOENT))
+		errx(1, "poptReadDefaultConfig failed: %s", poptStrerror(rc));
+
+	while ((rc = poptGetNextOpt(optCon)) > 0) {
+		switch (rc) {
+		case 'n':
+			break;
+		case 'd':
+			break;
+		case 'e':
+			break;
+		case 'E':
+			break;
+		case 'g':
+			break;
+		case 'm':
+			break;
+		case 'l':
+			break;
+		case 'L':
+			break;
+		case 'b':
+			break;
+		case 'B':
+			break;
+		case '!':
+			break;
+		case '(':
+			break;
+	}
+
+	if (rc < -1)
+		errx(2, "Invalid argument: \"%s\": %s",
+		     poptBadOption(optCon, 0), poptStrerror(rc));
+
+	if (poptPeekArg(optCon))
+		errx(2, "Invalid argument: \"%s\"", poptPeekArg(optCon));
+
+	poptFreeContext(optCon);
+
+	return 0;
+}
+
diff --git a/src/eficonman.c b/src/eficonman.c
new file mode 100644
index 0000000..2c2be38
--- /dev/null
+++ b/src/eficonman.c
@@ -0,0 +1,169 @@
+/*
+ * eficonman.c - console manager for UEFI
+ *
+ * Copyright 2015 Red Hat, Inc.
+ *
+ * See "COPYING" for license terms.
+ *
+ * Author: Peter Jones <pjones@redhat.com>
+ */
+
+#include <efivar.h>
+#include <err.h>
+#include <inttypes.h>
+#include <libintl.h>
+#include <locale.h>
+#include <popt.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <uchar.h>
+#include <unistd.h>
+
+#define  _(String) gettext (String)
+#define Q_(String) dgettext (NULL, String)
+#define C_(Context,String) dgettext (Context,String)
+
+/* ConIn-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * ConInDev-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * ConOut-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * ConOutDev-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * ErrOut-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * ErrOutDev-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * Key0000-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * Key0001-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * Lang-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ * LangCodes-8be4df61-93ca-11d2-aa0d-00e098032b8c
+ */
+
+#define ACTION_INACTION		0x00
+#define ACTION_INFO		0x01
+
+static int
+do_list(void)
+{
+	struct {
+		char *varname;
+		char *label;
+	} vars[] = {
+		{"ConInDev", "Available console input devices"},
+		{"ConOutDev", "Available console ouput devices"},
+		{"ErrOutDev", "Available error output devices"},
+		{"ConIn", "Configured console input devices"},
+		{"ConOut", "Configured console ouptut devices"},
+		{"ErrOut", "Configured error output devices"},
+		{NULL, NULL}
+	};
+	for (int i = 0; vars[i].varname != NULL; i++) {
+		uint8_t *data;
+		size_t data_size;
+		uint32_t attrs;
+		int rc;
+		const_efidp whole_dp, dp;
+
+		rc = efi_get_variable(efi_guid_global, vars[i].varname,
+				      &data, &data_size, &attrs);
+		if (rc < 0) {
+			printf("%s: none\n", vars[i].label);
+			continue;
+		}
+		whole_dp = (const_efidp)data;
+		printf("%s:\n", vars[i].label);
+		if (!efidp_is_valid(whole_dp, data_size)) {
+			printf("\tdata is invalid\n");
+			continue;
+		}
+		dp = whole_dp;
+		while (dp) {
+			ssize_t sz, ssz;
+			char *s = NULL;
+
+			if (efidp_is_multiinstance(dp)) {
+				sz = efidp_instance_size(dp);
+				if (sz < 0)
+					err(1, "efidp_instance_size()");
+			} else {
+				sz = efidp_size(dp);
+				if (sz < 0)
+					err(1, "efidp_size()");
+			}
+
+			ssz = efidp_format_device_path(NULL, 0, dp, sz);
+			if (ssz < 0)
+				err(1, "efidp_format_device_path()");
+
+			s = alloca(ssz + 1);
+			ssz = efidp_format_device_path(s, ssz, dp, sz);
+			if (ssz < 0)
+				err(1, "efidp_format_device_path()");
+			s[ssz] = '\0';
+			printf("\t%s\n", s);
+
+			if (!efidp_is_multiinstance(dp))
+				break;
+
+			rc = efidp_get_next_end(dp, &dp);
+			if (rc < 0)
+				break;
+
+			rc = efidp_next_instance(dp, &dp);
+			if (rc < 0)
+				break;
+		}
+	}
+	return 0;
+}
+
+int
+main(int argc, char *argv[])
+{
+	int action = 0;
+	int quiet = 0;
+
+	setlocale(LC_ALL, "");
+	bindtextdomain("eficonman", LOCALEDIR);
+	textdomain("eficonman");
+
+	struct poptOption options[] = {
+		{.argInfo = POPT_ARG_INTL_DOMAIN,
+		 .arg = "eficonman" },
+		{.longName = "info",
+		 .shortName = 'i',
+		 .argInfo = POPT_ARG_VAL|POPT_ARGFLAG_OR,
+		 .arg = &action,
+		 .val = ACTION_INFO,
+		 .descrip = _("Display console information"), },
+		{.longName = "quiet",
+		 .shortName = 'q',
+		 .argInfo = POPT_ARG_VAL,
+		 .arg = &quiet,
+		 .val = 1,
+		 .descrip = _("Work quietly"), },
+		POPT_AUTOALIAS
+		POPT_AUTOHELP
+		POPT_TABLEEND
+	};
+
+	poptContext optcon;
+	optcon = poptGetContext("eficonman", argc, (const char **)argv, options, 0);
+
+	int rc;
+	rc = poptReadDefaultConfig(optcon, 0);
+	if (rc < 0 && !(rc == POPT_ERROR_ERRNO && errno == ENOENT))
+		errx(1, _("poptReadDefaultConfig failed: %s: %s"),
+			poptBadOption(optcon, 0), poptStrerror(rc));
+
+	while ((rc = poptGetNextOpt(optcon)) > 0)
+		;
+
+	switch (action) {
+	case ACTION_INFO:
+		do_list();
+		break;
+	case ACTION_INACTION:
+	default:
+		poptPrintUsage(optcon, stderr, 0);
+		exit(1);
+	}
+	return 0;
+}
diff --git a/src/include/efi.h b/src/include/efi.h
index b8d3b12..b1e760e 100644
--- a/src/include/efi.h
+++ b/src/include/efi.h
@@ -41,6 +41,8 @@
  *******************************************************/
 #define BLKX_UNKNOWN_GUID \
 EFI_GUID( 0x47c7b225, 0xc42a, 0x11d2, 0x8e57, 0x00, 0xa0, 0xc9, 0x69, 0x72, 0x3b)
+#define ADDRESS_RANGE_MIRROR_VARIABLE_GUID \
+EFI_GUID( 0x7b9be2e0, 0xe28a, 0x4197, 0xad3e, 0x32, 0xf0, 0x62, 0xf9, 0x46, 0x2c)
 
 /* Exported functions */
 
@@ -49,4 +51,16 @@ extern ssize_t make_linux_load_option(uint8_t **data, size_t *data_size,
 		       uint8_t *optional_data, size_t optional_data_size);
 extern ssize_t get_extra_args(uint8_t *data, ssize_t data_size);
 
+typedef struct {
+	uint8_t		mirror_version;
+	uint8_t		mirror_memory_below_4gb;
+	uint16_t	mirror_amount_above_4gb;
+	uint8_t		mirror_status;
+} __attribute__((packed)) ADDRESS_RANGE_MIRROR_VARIABLE_DATA;
+
+#define        MIRROR_VERSION  1
+
+#define ADDRESS_RANGE_MIRROR_VARIABLE_CURRENT "MirrorCurrent"
+#define ADDRESS_RANGE_MIRROR_VARIABLE_REQUEST "MirrorRequest"
+
 #endif /* EFI_H */
diff --git a/src/include/efibootmgr.h b/src/include/efibootmgr.h
index f5738b3..dc02fcb 100644
--- a/src/include/efibootmgr.h
+++ b/src/include/efibootmgr.h
@@ -61,6 +61,8 @@ typedef struct {
 	int bootnext;
 	int verbose;
 	int active;
+	int below4g;
+	int above4g;
 	int deduplicate;
 	unsigned int delete_boot:1;
 	unsigned int delete_bootorder:1;
@@ -73,8 +75,10 @@ typedef struct {
 	unsigned int forcegpt:1;
 	unsigned int set_timeout:1;
 	unsigned int delete_timeout:1;
+	unsigned int set_mirror_lo:1;
+	unsigned int set_mirror_hi:1;
 	unsigned int no_boot_order:1;
-	unsigned short int timeout;
+	short int timeout;
 } efibootmgr_opt_t;
 
 extern efibootmgr_opt_t opts;
diff --git a/src/include/module.mk b/src/include/module.mk
deleted file mode 100644
index 071d6df..0000000
--- a/src/include/module.mk
+++ /dev/null
@@ -1 +0,0 @@
-CFLAGS += -Isrc/include
diff --git a/src/lib/Makefile b/src/lib/Makefile
deleted file mode 100644
index 6615d46..0000000
--- a/src/lib/Makefile
+++ /dev/null
@@ -1,2 +0,0 @@
-%:
-	+make -C ../ $*
diff --git a/src/lib/module.mk b/src/lib/module.mk
deleted file mode 100644
index a0c62b7..0000000
--- a/src/lib/module.mk
+++ /dev/null
@@ -1,3 +0,0 @@
-CFLAGS += -Isrc/lib
-
-CLEANLIST += src/lib/*.o
diff --git a/src/module.mk b/src/module.mk
deleted file mode 100644
index f56f5b4..0000000
--- a/src/module.mk
+++ /dev/null
@@ -1,21 +0,0 @@
-#add our stuff first... our children need to wait for us to finish
-INSTALLDEPS += bindir_LIST
-
-  MODULES := src/efibootmgr src/lib src/include
-  include $(patsubst %,%/module.mk,$(MODULES))
-
-
-# Common stuff to copy into the common directories
-#  Note that the stuff below bindir_LIST is all on one line...
-bindir_LIST:    
-	@if [ ! -z "$(bindir_TARGETS)" ]; then \
-	  echo "R-M-: %attr(0755,root,root) $(BINDIR)" ;\
-	  for file in $(bindir_TARGETS) ;\
-	  do                                              \
-	    echo "-C--: $(BUILDDIR)/$$file $(BINDIR)/"                ;\
-	    echo "R---: %attr(0755,root,root) $(BINDIR)/`basename $$file`" ;\
-	  done ;\
-	  echo  ;\
-	fi
-
-
diff --git a/src/lib/unparse_path.c b/src/unparse_path.c
similarity index 100%
rename from src/lib/unparse_path.c
rename to src/unparse_path.c
diff --git a/tools/install.pl b/tools/install.pl
deleted file mode 100755
index 57c7c00..0000000
--- a/tools/install.pl
+++ /dev/null
@@ -1,156 +0,0 @@
-#!/usr/bin/perl -w
-
-#Pragmas 
-	use strict;
-
-#Parse command line...
-	my ($copy, $link);
-	my $type = shift @ARGV;
-	if( $type =~ /^copy$/i ) {
-	  $copy = 1;
-	} 
-	if( $type =~ /^link$/i ) {
-	  $link = 1;
-	}
-
-#Main program loop
-	open (RPMOUT, "> filelist-rpm") or die;
-
-	while( <> ){
-		chomp;
-		s/^\s*//;
-		s/\s*$//;
-		s/\s*#.*$//;
-		next if m/^$/;
-	
-		my $line = $_;
-		($line =~ m/^R...:(.*)/)  && print RPMOUT $1 . "\n";
-		($line =~ m/^..M.:(.*)/)  && MakeDir( $1 );
-		($line =~ m/^.C..:(.*)/)  && ($copy) && CopyFile( $1 );
-		($line =~ m/^.C..:(.*)/)  && ($link) && LinkFile( $1 );
-		($line =~ m/^R...:(.*)/)  && ChangeAttrs( $1 );
-	}
-
-sub CopyFile {
-	my ($src, $dst) = ParseCLine( shift );
-
-	if( -d $dst ) {
-		$src =~ m|^.*/(.*)$|;
-		my $file = $1;
-		$dst .= "/" if ! ($dst=~m|/$|);
-		$dst .= $file;
-	}
-	if( -e $dst ) {
-		unlink $dst;
-	}
-
-	open INPUT, "<", $src or goto out1;
-	open OUTPUT, ">", $dst or goto out2;
-	while(<INPUT>){ print OUTPUT $_ }
-	close OUTPUT;
-
-	print "Installed File: $dst\n";
-out2:
-	close INPUT;
-out1:	
-	return;	
-}
-
-sub LinkFile {
-	my ($src, $dst) = ParseCLine( shift );
-	if( -d $dst ) {
-		$src =~ m|^.*/(.*)$|;
-		my $file = $1;
-		$dst .= "/" if ! ($dst=~m|/$|);
-		$dst .= $file;
-	}
-	if( -e $dst ) {
-		unlink $dst;
-	}
-	symlink $src, $dst 
-	   or warn "Linking $src to $dst failed $!\n";
-	print "Installed File: $dst\n";
-}
-
-sub ParseCLine {
-	my $line = shift;
-	$line =~ s/^\s*//;
-	$line =~ s/\s*$//;
-	$line =~ m/^(.*?)\s+(.*?)$/;
-	return ($1, $2);
-}
-
-sub ParseRLine {
-	my $line = shift;
-	my @directives;
-	my @retval;
-	$line =~ s/^\s*//;
-	$line =~ s/\s*$//;
-	my @words = split( /\s+/, $line );
-	foreach my $word (@words) {
-		if( $word =~ /^\%(.*)/ ) {
-			push @directives, $word;
-		} else {
-			push @retval, $word;
-		}
-	}
-	return \@retval, \@directives;
-}
-
-sub MakeDir {
-	#R-M-: %attr(0755,root,ali) /opt/ali
-	my $line = shift;
-
-	#$line =~ m/\%attr\((.{1,5}),(\w+),(\w+)\)\s+(.*)/;
-	my ($file_ref, $directive_ref) = ParseRLine( $line );
-	
-	my $dir = $file_ref->[0];
-
-	if( ! -d $dir ) {
-		mkdir $dir 
-		  or warn "Make Dir: -->$dir<-- failed $!\n";
-	}
-	print "Made Dir: $dir\n";
-}
-
-sub GetUID {
-	my $name = shift;
-	my (undef, undef, $uid, undef) = getpwnam( $name ) ;
-	$uid = defined($uid) ? $uid : -1;
-	return $uid;
-}
-
-sub GetGID {
-	my $name = shift;
-	my (undef, undef, $gid, undef) = getgrnam( $name ) ;
-	$gid = defined($gid) ? $gid : -1;
-	return $gid;
-}
-
-sub ChangeAttrs {
-	my $line = shift;
-
-	my ($file_ref, $directive_ref) = ParseRLine( $line );
-	my ($attr) = grep { /^\%attr/ } @$directive_ref;
-	$attr =~ m/\%attr\((.{1,5}),(\w+),(\w+)\)/;
-	my $perms = $1;
-	my $owner = $2;
-	my $group = $3;
-	my $file = $file_ref->[0];
-
-	my $uid = GetUID($owner);
-	my $gid = GetGID($group); 
-
-	chown $uid, $gid, $file;
-	chmod oct($perms), $file;
-}
-
-
-
-
-
-
-
-
-
-

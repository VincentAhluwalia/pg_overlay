From bc5f6774560aa591cf7461bc2a7b5e8cb8c79c00 Mon Sep 17 00:00:00 2001
From: Joachim Bauch <jojo@struktur.de>
Date: Mon, 10 Nov 2014 16:19:32 +0100
Subject: [PATCH 03/57] webrtc: generate "real" ephemeral keys

By default, the browser caches generated keypairs for ECDHE key
exchange for the lifetime of the application. This means the same
keypair would be used for all WebRTC peer connections.

We obviously do not want that.
---
 net/third_party/nss/ssl/ssl3ecc.c | 42 +++++++++++----------------------------
 1 file changed, 12 insertions(+), 30 deletions(-)

diff --git a/net/third_party/nss/ssl/ssl3ecc.c b/net/third_party/nss/ssl/ssl3ecc.c
index ab5ab14..f8365b62 100644
--- a/net/third_party/nss/ssl/ssl3ecc.c
+++ b/net/third_party/nss/ssl/ssl3ecc.c
@@ -155,6 +155,7 @@ static const Bits2Curve bits2curve [] = {
    {  65535,     ec_noName    }
 };
 
+#if 0
 typedef struct ECDHEKeyPairStr {
     ssl3KeyPair *  pair;
     int            error;  /* error code of the call-once function */
@@ -163,6 +164,7 @@ typedef struct ECDHEKeyPairStr {
 
 /* arrays of ECDHE KeyPairs */
 static ECDHEKeyPair gECDHEKeyPairs[ec_pastLastName];
+#endif
 
 SECStatus
 ssl3_ECName2Params(PLArenaPool * arena, ECName curve, SECKEYECParams * params)
@@ -485,6 +487,7 @@ ssl3_GetCurveNameForServerSocket(sslSocket *ss)
                                           requiredECCbits);
 }
 
+#if 0
 /* function to clear out the lists */
 static SECStatus
 ssl3_ShutdownECDHECurves(void *appData, void *nssData)
@@ -511,6 +514,7 @@ ssl3_ECRegister(void)
     }
     return (PRStatus)rv;
 }
+#endif
 
 /* Create an ECDHE key pair for a given curve */
 static SECStatus
@@ -519,10 +523,12 @@ ssl3_CreateECDHEphemeralKeyPair(ECName ec_curve, ssl3KeyPair** keyPair)
     SECKEYPrivateKey *    privKey  = NULL;
     SECKEYPublicKey *     pubKey   = NULL;
     SECKEYECParams        ecParams = { siBuffer, NULL, 0 };
+    SECStatus status;
 
-    if (ssl3_ECName2Params(NULL, ec_curve, &ecParams) != SECSuccess) {
-        return SECFailure;
-    }
+    fprintf(stderr, "*** Using patched ssl3_CreateECDHEphemeralKeys\n");
+    status = ssl3_ECName2Params(NULL, ec_curve, &ecParams);
+    if (status != SECSuccess)
+        return status;
     privKey = SECKEY_CreateECPrivateKey(&ecParams, &pubKey, NULL);
     SECITEM_FreeItem(&ecParams, PR_FALSE);
 
@@ -540,6 +546,7 @@ ssl3_CreateECDHEphemeralKeyPair(ECName ec_curve, ssl3KeyPair** keyPair)
     return SECSuccess;
 }
 
+#if 0
 /* CallOnce function, called once for each named curve. */
 static PRStatus
 ssl3_CreateECDHEphemeralKeyPairOnce(void * arg)
@@ -558,6 +565,7 @@ ssl3_CreateECDHEphemeralKeyPairOnce(void * arg)
     gECDHEKeyPairs[ec_curve].pair = keyPair;
     return PR_SUCCESS;
 }
+#endif
 
 /*
  * Creates the ephemeral public and private ECDH keys used by
@@ -571,33 +579,7 @@ ssl3_CreateECDHEphemeralKeyPairOnce(void * arg)
 static SECStatus
 ssl3_CreateECDHEphemeralKeys(sslSocket *ss, ECName ec_curve)
 {
-    ssl3KeyPair *         keyPair        = NULL;
-
-    /* if there's no global key for this curve, make one. */
-    if (gECDHEKeyPairs[ec_curve].pair == NULL) {
-        PRStatus status;
-
-        status = PR_CallOnce(&gECDHEKeyPairs[ec_noName].once, ssl3_ECRegister);
-        if (status != PR_SUCCESS) {
-            PORT_SetError(gECDHEKeyPairs[ec_noName].error);
-            return SECFailure;
-        }
-        status = PR_CallOnceWithArg(&gECDHEKeyPairs[ec_curve].once,
-                                    ssl3_CreateECDHEphemeralKeyPairOnce,
-                                    (void *)ec_curve);
-        if (status != PR_SUCCESS) {
-            PORT_SetError(gECDHEKeyPairs[ec_curve].error);
-            return SECFailure;
-        }
-    }
-
-    keyPair = gECDHEKeyPairs[ec_curve].pair;
-    PORT_Assert(keyPair != NULL);
-    if (!keyPair)
-        return SECFailure;
-    ss->ephemeralECDHKeyPair = ssl3_GetKeyPairRef(keyPair);
-
-    return SECSuccess;
+	return ssl3_CreateECDHEphemeralKeyPair(ec_curve, &ss->ephemeralECDHKeyPair);
 }
 
 SECStatus
-- 
2.6.6


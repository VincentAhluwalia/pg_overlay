From 3cd6e57bd75737e7905243974288ed5ce14b95ee Mon Sep 17 00:00:00 2001
From: Tilmann Meyer <me@atiltedtree.dev>
Date: Fri, 15 Apr 2022 14:06:55 +0200
Subject: [PATCH 01/11] Guard X11 specific code with MOZ_X11

---
 gfx/thebes/gfxPlatformGtk.cpp                 |  2 +-
 .../RenderCompositorOGLSWGL.cpp               |  4 +-
 toolkit/components/remote/nsRemoteService.cpp |  2 +-
 toolkit/xre/nsGDKErrorHandler.cpp             | 15 +++-
 widget/gtk/nsClipboard.cpp                    | 16 ++--
 widget/gtk/nsDragService.cpp                  |  4 +-
 widget/gtk/nsGtkKeyUtils.cpp                  | 30 ++++++-
 widget/gtk/nsGtkKeyUtils.h                    | 12 ++-
 widget/gtk/nsPrintDialogGTK.cpp               |  5 +-
 widget/gtk/nsUserIdleServiceGTK.cpp           | 14 +++-
 widget/gtk/nsUserIdleServiceGTK.h             | 12 ++-
 widget/gtk/nsWindow.cpp                       | 81 +++++++++++++------
 widget/gtk/nsWindow.h                         | 10 +++
 13 files changed, 159 insertions(+), 48 deletions(-)

diff --git a/gfx/thebes/gfxPlatformGtk.cpp b/gfx/thebes/gfxPlatformGtk.cpp
index 35d9cdeba4f12..415532297892d 100644
--- a/gfx/thebes/gfxPlatformGtk.cpp
+++ b/gfx/thebes/gfxPlatformGtk.cpp
@@ -31,7 +31,6 @@
 #include "mozilla/FontPropertyTypes.h"
 #include "mozilla/gfx/2D.h"
 #include "mozilla/gfx/Logging.h"
-#include "mozilla/gfx/XlibDisplay.h"
 #include "mozilla/Monitor.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/StaticPrefs_gfx.h"
@@ -45,6 +44,7 @@
 #include "VsyncSource.h"
 
 #ifdef MOZ_X11
+#  include "mozilla/gfx/XlibDisplay.h"
 #  include <gdk/gdkx.h>
 #  include <X11/extensions/Xrandr.h>
 #  include "cairo-xlib.h"
diff --git a/gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp b/gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp
index 00a6c3ef6d6d3..84fc63266866a 100644
--- a/gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp
+++ b/gfx/webrender_bindings/RenderCompositorOGLSWGL.cpp
@@ -27,7 +27,9 @@
 #ifdef MOZ_WIDGET_GTK
 #  include "mozilla/widget/GtkCompositorWidget.h"
 #  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#  endif
 #endif
 
 namespace mozilla {
diff --git a/toolkit/components/remote/nsRemoteService.cpp b/toolkit/components/remote/nsRemoteService.cpp
index b2499d8191ed3..ef4b95cbb2204 100644
--- a/toolkit/components/remote/nsRemoteService.cpp
+++ b/toolkit/components/remote/nsRemoteService.cpp
@@ -12,11 +12,11 @@
 
 #ifdef MOZ_WIDGET_GTK
 #  include "mozilla/WidgetUtilsGtk.h"
-#  include "nsGTKRemoteServer.h"
 #  ifdef MOZ_ENABLE_DBUS
 #    include "nsDBusRemoteServer.h"
 #    include "nsDBusRemoteClient.h"
 #  else
+#    include "nsGTKRemoteServer.h"
 #    include "nsXRemoteClient.h"
 #  endif
 #elif defined(XP_WIN)
diff --git a/toolkit/xre/nsGDKErrorHandler.cpp b/toolkit/xre/nsGDKErrorHandler.cpp
index 421abdf12f906..0d0088409f004 100644
--- a/toolkit/xre/nsGDKErrorHandler.cpp
+++ b/toolkit/xre/nsGDKErrorHandler.cpp
@@ -6,14 +6,18 @@
 #include "nsGDKErrorHandler.h"
 
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
+#ifdef MOZ_X11
+#  include <gdk/gdkx.h>
+#endif
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 
 #include "nsDebug.h"
 #include "nsString.h"
-#include "nsX11ErrorHandler.h"
+#ifdef MOZ_X11
+#  include "nsX11ErrorHandler.h"
+#endif
 
 #include "prenv.h"
 
@@ -26,6 +30,7 @@
  */
 static void GdkErrorHandler(const gchar* log_domain, GLogLevelFlags log_level,
                             const gchar* message, gpointer user_data) {
+#ifdef MOZ_X11
   if (strstr(message, "X Window System error")) {
     XErrorEvent event;
     nsDependentCString buffer(message);
@@ -92,7 +97,9 @@ static void GdkErrorHandler(const gchar* log_domain, GLogLevelFlags log_level,
     event.resourceid = 0;
 
     X11Error(event.display, &event);
-  } else {
+  } else
+#endif
+  {
     g_log_default_handler(log_domain, log_level, message, user_data);
     MOZ_CRASH_UNSAFE(message);
   }
@@ -103,7 +110,9 @@ void InstallGdkErrorHandler() {
                     (GLogLevelFlags)(G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL |
                                      G_LOG_FLAG_RECURSION),
                     GdkErrorHandler, nullptr);
+#ifdef MOZ_X11
   if (PR_GetEnv("MOZ_X_SYNC")) {
     XSynchronize(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()), X11True);
   }
+#endif
 }
diff --git a/widget/gtk/nsClipboard.cpp b/widget/gtk/nsClipboard.cpp
index ba9a06a3fdd1c..61110a8dbedc5 100644
--- a/widget/gtk/nsClipboard.cpp
+++ b/widget/gtk/nsClipboard.cpp
@@ -9,7 +9,9 @@
 
 #include "nsArrayUtils.h"
 #include "nsClipboard.h"
-#include "nsClipboardX11.h"
+#if defined(MOZ_X11)
+#  include "nsClipboardX11.h"
+#endif
 #if defined(MOZ_WAYLAND)
 #  include "nsClipboardWayland.h"
 #endif
@@ -33,11 +35,11 @@
 #include "mozilla/StaticPrefs_widget.h"
 #include "mozilla/TimeStamp.h"
 #include "WidgetUtilsGtk.h"
+#include "GRefPtr.h"
 
 #include "imgIContainer.h"
 
 #include <gtk/gtk.h>
-#include <gtk/gtkx.h>
 
 #include "mozilla/Encoding.h"
 
@@ -202,16 +204,16 @@ nsClipboard::~nsClipboard() {
 NS_IMPL_ISUPPORTS(nsClipboard, nsIClipboard, nsIObserver)
 
 nsresult nsClipboard::Init(void) {
+#if defined(MOZ_X11)
   if (widget::GdkIsX11Display()) {
     mContext = new nsRetrievalContextX11();
+  }
+#endif
 #if defined(MOZ_WAYLAND)
-  } else if (widget::GdkIsWaylandDisplay()) {
+  if (widget::GdkIsWaylandDisplay()) {
     mContext = new nsRetrievalContextWayland();
-#endif
-  } else {
-    NS_WARNING("Missing nsRetrievalContext for nsClipboard!");
-    return NS_OK;
   }
+#endif
 
   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
   if (os) {
diff --git a/widget/gtk/nsDragService.cpp b/widget/gtk/nsDragService.cpp
index 93a59e6cd0e03..7f64b1223cbe4 100644
--- a/widget/gtk/nsDragService.cpp
+++ b/widget/gtk/nsDragService.cpp
@@ -34,7 +34,9 @@
 #include "mozilla/WidgetUtilsGtk.h"
 #include "GRefPtr.h"
 
-#include "gfxXlibSurface.h"
+#ifdef MOZ_X11
+#  include "gfxXlibSurface.h"
+#endif
 #include "gfxContext.h"
 #include "nsImageToPixbuf.h"
 #include "nsPresContext.h"
diff --git a/widget/gtk/nsGtkKeyUtils.cpp b/widget/gtk/nsGtkKeyUtils.cpp
index f7f93bdf5850b..7fd24d53f6f7c 100644
--- a/widget/gtk/nsGtkKeyUtils.cpp
+++ b/widget/gtk/nsGtkKeyUtils.cpp
@@ -12,11 +12,13 @@
 #include <gdk/gdkkeysyms.h>
 #include <algorithm>
 #include <gdk/gdk.h>
-#include <gdk/gdkx.h>
 #include <dlfcn.h>
 #include <gdk/gdkkeysyms-compat.h>
-#include <X11/XKBlib.h>
-#include "X11UndefineNone.h"
+#ifdef MOZ_X11
+#  include <gdk/gdkx.h>
+#  include <X11/XKBlib.h>
+#  include "X11UndefineNone.h"
+#endif
 #include "IMContextWrapper.h"
 #include "WidgetUtils.h"
 #include "WidgetUtilsGtk.h"
@@ -55,7 +57,9 @@ namespace widget {
 
 KeymapWrapper* KeymapWrapper::sInstance = nullptr;
 guint KeymapWrapper::sLastRepeatableHardwareKeyCode = 0;
+#ifdef MOZ_X11
 Time KeymapWrapper::sLastRepeatableKeyTime = 0;
+#endif
 KeymapWrapper::RepeatState KeymapWrapper::sRepeatState =
     KeymapWrapper::NOT_PRESSED;
 
@@ -354,9 +358,11 @@ KeymapWrapper::KeymapWrapper()
 
   g_object_ref(mGdkKeymap);
 
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     InitXKBExtension();
   }
+#endif
 
   Init();
 }
@@ -373,16 +379,20 @@ void KeymapWrapper::Init() {
   mModifierKeys.Clear();
   memset(mModifierMasks, 0, sizeof(mModifierMasks));
 
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     InitBySystemSettingsX11();
   }
+#endif
 #ifdef MOZ_WAYLAND
-  else {
+  if (GdkIsWaylandDisplay()) {
     InitBySystemSettingsWayland();
   }
 #endif
 
+#ifdef MOZ_X11
   gdk_window_add_filter(nullptr, FilterEvents, this);
+#endif
 
   MOZ_LOG(gKeyLog, LogLevel::Info,
           ("%p Init, CapsLock=0x%X, NumLock=0x%X, "
@@ -395,6 +405,7 @@ void KeymapWrapper::Init() {
            GetModifierMask(SUPER), GetModifierMask(HYPER)));
 }
 
+#ifdef MOZ_X11
 void KeymapWrapper::InitXKBExtension() {
   PodZero(&mKeyboardState);
 
@@ -626,6 +637,7 @@ void KeymapWrapper::InitBySystemSettingsX11() {
   XFreeModifiermap(xmodmap);
   XFree(xkeymap);
 }
+#endif
 
 #ifdef MOZ_WAYLAND
 void KeymapWrapper::SetModifierMask(xkb_keymap* aKeymap,
@@ -789,7 +801,9 @@ void KeymapWrapper::InitBySystemSettingsWayland() {
 #endif
 
 KeymapWrapper::~KeymapWrapper() {
+#ifdef MOZ_X11
   gdk_window_remove_filter(nullptr, FilterEvents, this);
+#endif
   if (mOnKeysChangedSignalHandle) {
     g_signal_handler_disconnect(mGdkKeymap, mOnKeysChangedSignalHandle);
   }
@@ -800,6 +814,7 @@ KeymapWrapper::~KeymapWrapper() {
   MOZ_LOG(gKeyLog, LogLevel::Info, ("%p Destructor", this));
 }
 
+#ifdef MOZ_X11
 /* static */
 GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
                                             GdkEvent* aGdkEvent,
@@ -913,6 +928,7 @@ GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
 
   return GDK_FILTER_CONTINUE;
 }
+#endif
 
 static void ResetBidiKeyboard() {
   // Reset the bidi keyboard settings for the new GdkKeymap
@@ -1777,6 +1793,7 @@ void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
   // key release events, the result isn't what we want.
   guint modifierState = aGdkKeyEvent->state;
   GdkDisplay* gdkDisplay = gdk_display_get_default();
+#ifdef MOZ_X11
   if (aGdkKeyEvent->is_modifier && GdkIsX11Display(gdkDisplay)) {
     Display* display = gdk_x11_display_get_xdisplay(gdkDisplay);
     if (XEventsQueued(display, QueuedAfterReading)) {
@@ -1793,6 +1810,7 @@ void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
       }
     }
   }
+#endif
   InitInputEvent(aKeyEvent, modifierState);
 
   switch (aGdkKeyEvent->keyval) {
@@ -2039,11 +2057,15 @@ bool KeymapWrapper::IsLatinGroup(guint8 aGroup) {
 }
 
 bool KeymapWrapper::IsAutoRepeatableKey(guint aHardwareKeyCode) {
+#ifdef MOZ_X11
   uint8_t indexOfArray = aHardwareKeyCode / 8;
   MOZ_ASSERT(indexOfArray < ArrayLength(mKeyboardState.auto_repeats),
              "invalid index");
   char bitMask = 1 << (aHardwareKeyCode % 8);
   return (mKeyboardState.auto_repeats[indexOfArray] & bitMask) != 0;
+#else
+  return false;
+#endif
 }
 
 /* static */
diff --git a/widget/gtk/nsGtkKeyUtils.h b/widget/gtk/nsGtkKeyUtils.h
index 18188c9b00a11..6fcc3e9305927 100644
--- a/widget/gtk/nsGtkKeyUtils.h
+++ b/widget/gtk/nsGtkKeyUtils.h
@@ -13,7 +13,9 @@
 #include "nsTArray.h"
 
 #include <gdk/gdk.h>
-#include <X11/XKBlib.h>
+#ifdef MOZ_X11
+#  include <X11/XKBlib.h>
+#endif
 #ifdef MOZ_WAYLAND
 #  include <gdk/gdkwayland.h>
 #  include <xkbcommon/xkbcommon.h>
@@ -248,8 +250,10 @@ class KeymapWrapper {
    * Initializing methods.
    */
   void Init();
+#ifdef MOZ_X11
   void InitXKBExtension();
   void InitBySystemSettingsX11();
+#endif
 #ifdef MOZ_WAYLAND
   void InitBySystemSettingsWayland();
 #endif
@@ -325,6 +329,7 @@ class KeymapWrapper {
    */
   int mXKBBaseEventCode;
 
+#ifdef MOZ_X11
   /**
    * Only auto_repeats[] stores valid value.  If you need to use other
    * members, you need to listen notification events for them.
@@ -332,6 +337,7 @@ class KeymapWrapper {
    * InitXKBExtension().
    */
   XKeyboardState mKeyboardState;
+#endif
 
   /**
    * Pointer of the singleton instance.
@@ -342,7 +348,9 @@ class KeymapWrapper {
    * Auto key repeat management.
    */
   static guint sLastRepeatableHardwareKeyCode;
+#ifdef MOZ_X11
   static Time sLastRepeatableKeyTime;
+#endif
   enum RepeatState { NOT_PRESSED, FIRST_PRESS, REPEATING };
   static RepeatState sRepeatState;
 
@@ -448,6 +456,7 @@ class KeymapWrapper {
    */
   static uint32_t GetDOMKeyCodeFromKeyPairs(guint aGdkKeyval);
 
+#ifdef MOZ_X11
   /**
    * FilterEvents() listens all events on all our windows.
    * Be careful, this may make damage to performance if you add expensive
@@ -455,6 +464,7 @@ class KeymapWrapper {
    */
   static GdkFilterReturn FilterEvents(GdkXEvent* aXEvent, GdkEvent* aGdkEvent,
                                       gpointer aData);
+#endif
 
   /**
    * MaybeDispatchContextMenuEvent() may dispatch eContextMenu event if
diff --git a/widget/gtk/nsPrintDialogGTK.cpp b/widget/gtk/nsPrintDialogGTK.cpp
index bfd86467cdbdb..1fd1f5baea0de 100644
--- a/widget/gtk/nsPrintDialogGTK.cpp
+++ b/widget/gtk/nsPrintDialogGTK.cpp
@@ -28,7 +28,10 @@
 #include "nsIObserverService.h"
 
 // for gdk_x11_window_get_xid
-#include <gdk/gdkx.h>
+#include <gdk/gdk.h>
+#ifdef MOZ_X11
+#  include <gdk/gdkx.h>
+#endif
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
diff --git a/widget/gtk/nsUserIdleServiceGTK.cpp b/widget/gtk/nsUserIdleServiceGTK.cpp
index 884d52a6cab9b..37fe8d1bd4140 100644
--- a/widget/gtk/nsUserIdleServiceGTK.cpp
+++ b/widget/gtk/nsUserIdleServiceGTK.cpp
@@ -17,6 +17,7 @@ using mozilla::LogLevel;
 
 static mozilla::LazyLogModule sIdleLog("nsIUserIdleService");
 
+#ifdef MOZ_X11
 typedef bool (*_XScreenSaverQueryExtension_fn)(Display* dpy, int* event_base,
                                                int* error_base);
 
@@ -25,12 +26,14 @@ typedef XScreenSaverInfo* (*_XScreenSaverAllocInfo_fn)(void);
 typedef void (*_XScreenSaverQueryInfo_fn)(Display* dpy, Drawable drw,
                                           XScreenSaverInfo* info);
 
-static bool sInitialized = false;
 static _XScreenSaverQueryExtension_fn _XSSQueryExtension = nullptr;
 static _XScreenSaverAllocInfo_fn _XSSAllocInfo = nullptr;
 static _XScreenSaverQueryInfo_fn _XSSQueryInfo = nullptr;
+#endif
+static bool sInitialized = false;
 
 static void Initialize() {
+#ifdef MOZ_X11
   if (!mozilla::widget::GdkIsX11Display()) {
     return;
   }
@@ -59,14 +62,21 @@ static void Initialize() {
     MOZ_LOG(sIdleLog, LogLevel::Warning, ("Failed to get XSSQueryInfo!\n"));
 
   sInitialized = true;
+#endif
 }
 
+#ifdef MOZ_X11
 nsUserIdleServiceGTK::nsUserIdleServiceGTK() : mXssInfo(nullptr) {
+#else
+nsUserIdleServiceGTK::nsUserIdleServiceGTK() {
+#endif
   Initialize();
 }
 
 nsUserIdleServiceGTK::~nsUserIdleServiceGTK() {
+#ifdef MOZ_X11
   if (mXssInfo) XFree(mXssInfo);
+#endif
 
 // It is not safe to unload libXScrnSaver until each display is closed because
 // the library registers callbacks through XESetCloseDisplay (Bug 397607).
@@ -80,6 +90,7 @@ nsUserIdleServiceGTK::~nsUserIdleServiceGTK() {
 }
 
 bool nsUserIdleServiceGTK::PollIdleTime(uint32_t* aIdleTime) {
+#ifdef MOZ_X11
   if (!sInitialized) {
     // For some reason, we could not find xscreensaver.
     return false;
@@ -109,6 +120,7 @@ bool nsUserIdleServiceGTK::PollIdleTime(uint32_t* aIdleTime) {
   }
   // If we get here, we couldn't get to XScreenSaver:
   MOZ_LOG(sIdleLog, LogLevel::Warning, ("XSSQueryExtension returned false!\n"));
+#endif
   return false;
 }
 
diff --git a/widget/gtk/nsUserIdleServiceGTK.h b/widget/gtk/nsUserIdleServiceGTK.h
index 9b9ba31846e3b..e596283e24ea7 100644
--- a/widget/gtk/nsUserIdleServiceGTK.h
+++ b/widget/gtk/nsUserIdleServiceGTK.h
@@ -9,10 +9,13 @@
 #define nsUserIdleServiceGTK_h__
 
 #include "nsUserIdleService.h"
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-#include <gdk/gdkx.h>
+#ifdef MOZ_X11
+#  include <X11/Xlib.h>
+#  include <X11/Xutil.h>
+#  include <gdk/gdkx.h>
+#endif
 
+#ifdef MOZ_X11
 typedef struct {
   Window window;               // Screen saver window
   int state;                   // ScreenSaver(Off,On,Disabled)
@@ -21,6 +24,7 @@ typedef struct {
   unsigned long idle;          // milliseconds idle
   unsigned long event_mask;    // event stuff
 } XScreenSaverInfo;
+#endif
 
 class nsUserIdleServiceGTK : public nsUserIdleService {
  public:
@@ -40,7 +44,9 @@ class nsUserIdleServiceGTK : public nsUserIdleService {
 
  private:
   ~nsUserIdleServiceGTK();
+#ifdef MOZ_X11
   XScreenSaverInfo* mXssInfo;
+#endif
 
  protected:
   nsUserIdleServiceGTK();
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index 5afb6050f8538..0c0c97024fe45 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -60,7 +60,9 @@
 #include "mozilla/UniquePtrExtensions.h"
 #include "mozilla/WidgetUtils.h"
 #include "mozilla/WritingModes.h"
-#include "mozilla/X11Util.h"
+#ifdef MOZ_X11
+#  include "mozilla/X11Util.h"
+#endif
 #include "mozilla/XREAppData.h"
 #include "NativeKeyBindings.h"
 #include "nsAppDirectoryServiceDefs.h"
@@ -92,7 +94,6 @@
 #include "ScreenHelperGTK.h"
 #include "SystemTimeConverter.h"
 #include "WidgetUtilsGtk.h"
-#include "mozilla/X11Util.h"
 
 #ifdef ACCESSIBILITY
 #  include "mozilla/a11y/LocalAccessible.h"
@@ -112,6 +113,7 @@
 #  include "WindowSurfaceX11SHM.h"
 #endif
 #ifdef MOZ_WAYLAND
+#  include <gdk/gdkkeysyms-compat.h>
 #  include "nsIClipboard.h"
 #  include "nsView.h"
 #endif
@@ -120,8 +122,10 @@ using namespace mozilla;
 using namespace mozilla::gfx;
 using namespace mozilla::layers;
 using namespace mozilla::widget;
+#ifdef MOZ_X11
 using mozilla::gl::GLContextEGL;
 using mozilla::gl::GLContextGLX;
+#endif
 
 // Don't put more than this many rects in the dirty region, just fluff
 // out to the bounding-box if there are more
@@ -264,6 +268,7 @@ bool nsWindow::sTransparentMainWindow = false;
 
 namespace mozilla {
 
+#ifdef MOZ_X11
 class CurrentX11TimeGetter {
  public:
   explicit CurrentX11TimeGetter(GdkWindow* aWindow)
@@ -311,6 +316,7 @@ class CurrentX11TimeGetter {
   GdkWindow* mWindow;
   TimeStamp mAsyncUpdateStart;
 };
+#endif
 
 }  // namespace mozilla
 
@@ -2500,6 +2506,7 @@ static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
     return false;
   }
 
+#ifdef MOZ_X11
   Display* xdisplay = gdk_x11_get_default_xdisplay();
   GdkScreen* screen = gdk_window_get_screen(gdk_window);
   Window root_win = GDK_WINDOW_XID(gdk_screen_get_root_window(screen));
@@ -2563,6 +2570,7 @@ static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
 
   wmName = reinterpret_cast<const char*>(prop_return);
   return true;
+#endif
 }
 
 #define kDesktopMutterSchema "org.gnome.mutter"
@@ -2620,6 +2628,7 @@ void nsWindow::GetWorkspaceID(nsAString& workspaceID) {
     return;
   }
 
+#ifdef MOZ_X11
   LOG("nsWindow::GetWorkspaceID()\n");
 
   // Get the gdk window for this widget.
@@ -2654,6 +2663,7 @@ void nsWindow::GetWorkspaceID(nsAString& workspaceID) {
   LOG("  got workspace ID %d", (int32_t)wm_desktop[0]);
   workspaceID.AppendInt((int32_t)wm_desktop[0]);
   g_free(wm_desktop);
+#endif
 }
 
 void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
@@ -2666,6 +2676,7 @@ void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
     return;
   }
 
+#ifdef MOZ_X11
   // Get the gdk window for this widget.
   GdkWindow* gdk_window = gtk_widget_get_window(mShell);
   if (!gdk_window) {
@@ -2701,6 +2712,7 @@ void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
 
   XFlush(xdisplay);
   LOG("  moved to workspace");
+#endif
 }
 
 using SetUserTimeFunc = void (*)(GdkWindow*, guint32);
@@ -2740,10 +2752,14 @@ guint32 nsWindow::GetLastUserInputTime() {
   // WM_DELETE_WINDOW delete events, but not usually mouse motion nor
   // button and key releases.  Therefore use the most recent of
   // gdk_x11_display_get_user_time and the last time that we have seen.
+#ifdef MOZ_X11
   GdkDisplay* gdkDisplay = gdk_display_get_default();
   guint32 timestamp = GdkIsX11Display(gdkDisplay)
                           ? gdk_x11_display_get_user_time(gdkDisplay)
                           : gtk_get_current_event_time();
+#else
+  guint32 timestamp = gtk_get_current_event_time();
+#endif
 
   if (sLastUserInputTime != GDK_CURRENT_TIME &&
       TimestampIsNewerThan(sLastUserInputTime, timestamp)) {
@@ -2998,6 +3014,7 @@ void nsWindow::UpdateClientOffsetFromFrameExtents() {
     return;
   }
 
+#ifdef MOZ_X11
   GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
 
   GdkAtom type_returned;
@@ -3031,6 +3048,7 @@ void nsWindow::UpdateClientOffsetFromFrameExtents() {
 
   LOG("nsWindow::UpdateClientOffsetFromFrameExtents %d,%d\n", mClientOffset.x,
       mClientOffset.y);
+#endif
 }
 
 LayoutDeviceIntPoint nsWindow::GetClientOffset() {
@@ -3048,9 +3066,11 @@ gboolean nsWindow::OnPropertyNotifyEvent(GtkWidget* aWidget,
   if (!mGdkWindow) {
     return FALSE;
   }
+#ifdef MOZ_X11
   if (GetCurrentTimeGetter()->PropertyNotifyHandler(aWidget, aEvent)) {
     return TRUE;
   }
+#endif
   return FALSE;
 }
 
@@ -3185,9 +3205,11 @@ void* nsWindow::GetNativeData(uint32_t aDataType) {
       return GetToplevelWidget();
 
     case NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID:
+#ifdef MOZ_X11
       if (GdkIsX11Display()) {
         return (void*)GDK_WINDOW_XID(gdk_window_get_toplevel(mGdkWindow));
       }
+#endif
       NS_WARNING(
           "nsWindow::GetNativeData(): NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID is not "
           "handled on Wayland!");
@@ -3208,11 +3230,13 @@ void* nsWindow::GetNativeData(uint32_t aDataType) {
       return nullptr;
     case NS_NATIVE_EGL_WINDOW: {
       void* eglWindow = nullptr;
+#ifdef MOZ_X11
       if (GdkIsX11Display()) {
         eglWindow = mGdkWindow ? (void*)GDK_WINDOW_XID(mGdkWindow) : nullptr;
       }
+#endif
 #ifdef MOZ_WAYLAND
-      else {
+      if (GdkIsWaylandDisplay()) {
         eglWindow = moz_container_wayland_get_egl_window(
             mContainer, FractionalScaleFactor());
       }
@@ -3503,7 +3527,7 @@ gboolean nsWindow::OnExposeEvent(cairo_t* cr) {
   if (!listener) return FALSE;
 
   LOG("received expose event %p 0x%lx (rects follow):\n", mGdkWindow,
-      GdkIsX11Display() ? gdk_x11_window_get_xid(mGdkWindow) : 0);
+      GetX11Window());
   LayoutDeviceIntRegion exposeRegion;
   if (!ExtractExposeRegion(exposeRegion, cr)) {
     return FALSE;
@@ -4050,6 +4074,7 @@ void nsWindow::OnMotionNotifyEvent(GdkEventMotion* aEvent) {
     MOZ_ASSERT(gdk_window, "gdk_window_get_toplevel should not return null");
 
     bool canDrag = true;
+#ifdef MOZ_X11
     if (GdkIsX11Display()) {
       // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
       // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
@@ -4060,6 +4085,7 @@ void nsWindow::OnMotionNotifyEvent(GdkEventMotion* aEvent) {
         canDrag = false;
       }
     }
+#endif
 
     if (canDrag) {
       gdk_window_begin_move_drag(gdk_window, 1, aEvent->x_root, aEvent->y_root,
@@ -4511,15 +4537,18 @@ TimeStamp nsWindow::GetEventTimeStamp(guint32 aEventTime) {
         BaseTimeDurationPlatformUtils::TicksFromMilliseconds(timestampTime);
     eventTimeStamp = TimeStamp::FromSystemTime(tick);
   } else {
+#ifdef MOZ_X11
     CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
     MOZ_ASSERT(getCurrentTime,
                "Null current time getter despite having a window");
     eventTimeStamp =
         TimeConverter().GetTimeStampFromSystemTime(aEventTime, *getCurrentTime);
+#endif
   }
   return eventTimeStamp;
 }
 
+#ifdef MOZ_X11
 mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
   MOZ_ASSERT(mGdkWindow, "Expected mGdkWindow to be set");
   if (MOZ_UNLIKELY(!mCurrentTimeGetter)) {
@@ -4527,6 +4556,7 @@ mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
   }
   return mCurrentTimeGetter.get();
 }
+#endif
 
 gboolean nsWindow::OnKeyPressEvent(GdkEventKey* aEvent) {
   LOG("OnKeyPressEvent");
@@ -4707,6 +4737,7 @@ void nsWindow::OnWindowStateEvent(GtkWidget* aWidget,
   //
   // This may be fixed in Gtk 3.24+ but some DE still have this issue
   // (Bug 1624199) so let's remove it for Wayland only.
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     if (!mIsShown) {
       aEvent->changed_mask = static_cast<GdkWindowState>(
@@ -4717,6 +4748,7 @@ void nsWindow::OnWindowStateEvent(GtkWidget* aWidget,
           aEvent->changed_mask | GDK_WINDOW_STATE_MAXIMIZED);
     }
   }
+#endif
 
   // This is a workaround for https://gitlab.gnome.org/GNOME/gtk/issues/1395
   // Gtk+ controls window active appearance by window-state-event signal.
@@ -5231,8 +5263,16 @@ void nsWindow::DisableRenderingToWindow() {
 }
 
 Window nsWindow::GetX11Window() {
-  return GdkIsX11Display() && mGdkWindow ? gdk_x11_window_get_xid(mGdkWindow)
-                                         : X11None;
+#ifdef MOZ_X11
+  if (GdkIsX11Display()) {
+    return mGdkWindow ? gdk_x11_window_get_xid(mGdkWindow) : X11None;
+  }
+#endif
+#ifdef MOZ_WAYLAND
+  if (GdkIsWaylandDisplay()) {
+    return (Window) nullptr;
+  }
+#endif
 }
 
 void nsWindow::EnsureGdkWindow() {
@@ -5319,8 +5359,7 @@ void nsWindow::ConfigureGdkWindow() {
     EnsureGrabs();
   }
 
-  LOG("  finished, new GdkWindow %p XID 0x%lx\n", mGdkWindow,
-      GdkIsX11Display() ? gdk_x11_window_get_xid(mGdkWindow) : 0);
+  LOG("  finished, new GdkWindow %p XID 0x%lx\n", mGdkWindow, GetX11Window());
 }
 
 void nsWindow::ReleaseGdkWindow() {
@@ -5861,9 +5900,7 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
 
   LOG("  nsWindow type %d %s\n", mWindowType, mIsPIPWindow ? "PIP window" : "");
   LOG("  mShell %p mContainer %p mGdkWindow %p XID 0x%lx\n", mShell, mContainer,
-      mGdkWindow,
-      (GdkIsX11Display() && mGdkWindow) ? gdk_x11_window_get_xid(mGdkWindow)
-                                        : 0);
+      mGdkWindow, GetX11Window());
 
   // Set default application name when it's empty.
   if (mGtkWindowAppName.IsEmpty()) {
@@ -6563,18 +6600,6 @@ void nsWindow::ApplyTransparencyBitmap() {
   XShapeCombineMask(xDisplay, xDrawable, ShapeBounding, 0, 0, maskPixmap,
                     ShapeSet);
   XFreePixmap(xDisplay, maskPixmap);
-#else
-  cairo_surface_t* maskBitmap;
-  maskBitmap = cairo_image_surface_create_for_data(
-      (unsigned char*)mTransparencyBitmap, CAIRO_FORMAT_A1,
-      mTransparencyBitmapWidth, mTransparencyBitmapHeight,
-      GetBitmapStride(mTransparencyBitmapWidth));
-  if (!maskBitmap) return;
-
-  cairo_region_t* maskRegion = gdk_cairo_region_create_from_surface(maskBitmap);
-  gtk_widget_shape_combine_region(mShell, maskRegion);
-  cairo_region_destroy(maskRegion);
-  cairo_surface_destroy(maskBitmap);
 #endif  // MOZ_X11
 }
 
@@ -6704,6 +6729,7 @@ void nsWindow::UpdateTitlebarTransparencyBitmap() {
     cairo_surface_destroy(surface);
   }
 
+#ifdef MOZ_X11
   if (!mNeedsShow) {
     Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
     Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
@@ -6724,6 +6750,7 @@ void nsWindow::UpdateTitlebarTransparencyBitmap() {
 
     XFreePixmap(xDisplay, maskPixmap);
   }
+#endif
 }
 
 void nsWindow::GrabPointer(guint32 aTime) {
@@ -6749,6 +6776,7 @@ void nsWindow::GrabPointer(guint32 aTime) {
     return;
   }
 
+#ifdef MOZ_X11
   gint retval;
   // Note that we need GDK_TOUCH_MASK below to work around a GDK/X11 bug that
   // causes touch events that would normally be received by this client on
@@ -6775,6 +6803,7 @@ void nsWindow::GrabPointer(guint32 aTime) {
                           &nsWindow::CheckForRollupDuringGrab);
     NS_DispatchToCurrentThread(event.forget());
   }
+#endif
 }
 
 void nsWindow::ReleaseGrabs(void) {
@@ -6788,7 +6817,9 @@ void nsWindow::ReleaseGrabs(void) {
     return;
   }
 
+#ifdef MOZ_X11
   gdk_pointer_ungrab(GDK_CURRENT_TIME);
+#endif
 }
 
 GtkWidget* nsWindow::GetToplevelWidget() { return mShell; }
@@ -6999,7 +7030,7 @@ static bool IsFullscreenSupported(GtkWidget* aShell) {
   GdkScreen* screen = gtk_widget_get_screen(aShell);
   GdkAtom atom = gdk_atom_intern("_NET_WM_STATE_FULLSCREEN", FALSE);
   return gdk_x11_screen_supports_net_wm_hint(screen, atom);
-#elif
+#else
   return true;
 #endif
 }
@@ -8282,6 +8313,7 @@ bool nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
     return false;
   }
 
+#ifdef MOZ_X11
   if (GdkIsX11Display()) {
     // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
     // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
@@ -8297,6 +8329,7 @@ bool nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
       }
     }
   }
+#endif
 
   // FIXME: It would be nice to have the widget position at the time
   // of the event, but it's relatively unlikely that the widget has
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index f9be816f281a0..af2b633f7f0ea 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -77,6 +77,10 @@ extern mozilla::LazyLogModule gWidgetVsync;
 
 #endif /* MOZ_LOGGING */
 
+#if defined(MOZ_WAYLAND) && !defined(MOZ_X11)
+typedef uintptr_t Window;
+#endif
+
 class gfxPattern;
 class nsIFrame;
 #if !GTK_CHECK_VERSION(3, 18, 0)
@@ -102,7 +106,9 @@ namespace mozilla {
 enum class NativeKeyBindingsType : uint8_t;
 
 class TimeStamp;
+#ifdef MOZ_X11
 class CurrentX11TimeGetter;
+#endif
 }  // namespace mozilla
 
 class nsWindow final : public nsBaseWidget {
@@ -280,7 +286,9 @@ class nsWindow final : public nsBaseWidget {
 
   WidgetEventTime GetWidgetEventTime(guint32 aEventTime);
   mozilla::TimeStamp GetEventTimeStamp(guint32 aEventTime);
+#ifdef MOZ_X11
   mozilla::CurrentX11TimeGetter* GetCurrentTimeGetter();
+#endif
 
   void SetInputContext(const InputContext& aContext,
                        const InputContextAction& aAction) override;
@@ -842,7 +850,9 @@ class nsWindow final : public nsBaseWidget {
    */
   RefPtr<mozilla::widget::IMContextWrapper> mIMContext;
 
+#ifdef MOZ_X11
   mozilla::UniquePtr<mozilla::CurrentX11TimeGetter> mCurrentTimeGetter;
+#endif
   static GtkWindowDecoration sGtkWindowDecoration;
 
   static bool sTransparentMainWindow;
-- 
2.35.1

